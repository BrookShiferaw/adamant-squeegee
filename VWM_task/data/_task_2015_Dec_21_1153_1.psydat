ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
V/Users/Brook/Documents/GoogleDrive/Code/notebooks/adamant-squeegee/VWM_task/data/_task_2015_Dec_21_1153
p8
sS'runtimeInfo'
p9
NsS'name'
p10
Vtask
p11
sS'dataNames'
p12
(lp13
S'start.keys'
p14
aS'start.rt'
p15
asS'autoLog'
p16
I01
sS'extraInfo'
p17
(dp18
S'date'
p19
V2015_Dec_21_1153
p20
sS'frameRate'
p21
cnumpy.core.multiarray
scalar
p22
(cnumpy
dtype
p23
(S'f8'
I0
I1
tRp24
(I3
S'<'
NNNI-1
I-1
I0
tbS'l\x82\x830\xc1\xffM@'
tRp25
sS'expName'
p26
g11
sS'session'
p27
V001
p28
sS'participant'
p29
V
ssS'loopsUnfinished'
p30
(lp31
g1
(cpsychopy.data
TrialHandler
p32
g3
NtRp33
(dp34
S'origin'
p35
V#!/usr/bin/env python2\u000a# -*- coding: utf-8 -*-\u000a"""\u000aThis experiment was created using PsychoPy2 Experiment Builder (v1.82.01), Mon Nov 30 07:57:42 2015\u000aIf you publish work using this script please cite the relevant PsychoPy publications\u000a  Peirce, JW (2007) PsychoPy - Psychophysics software in Python. Journal of Neuroscience Methods, 162(1-2), 8-13.\u000a  Peirce, JW (2009) Generating stimuli for neuroscience using PsychoPy. Frontiers in Neuroinformatics, 2:10. doi: 10.3389/neuro.11.010.2008\u000a"""\u000a\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, event, logging, sound, gui\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = u'task'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the Window\u000awin = visual.Window(size=(1280, 800), fullscr=True, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a smaller size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[21, 21][0], height=[21, 21][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 10],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -10],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-10, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[10, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task1########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'task2'\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'task1'\u000a\u000a \u000a#########start of task2########\u000a\u000a\u000awin.close()\u000acore.quit()\u000a
p36
sS'thisTrial'
p37
g1
(cpsychopy.data
TrialType
p38
c__builtin__
dict
p39
(dp40
Vdownbox
p41
Vyellow
p42
sVtargettest
p43
Vred
p44
sVcorrAns
p45
Vright
p46
sVupbox
p47
Vgreen
p48
sVrightbox
p49
Vblue
p50
sVleftbox
p51
g44
stRp52
sS'_exp'
p53
I203255152
sg10
S'task2'
p54
sg6
S'/Users/Brook/Documents/GoogleDrive/Code/notebooks/adamant-squeegee/VWM_task/VWMtask_b.py'
p55
sS'thisRepN'
p56
I0
sg16
I01
sg17
g18
sS'data'
p57
g1
(cpsychopy.data
DataHandler
p58
g39
(dp59
S'ran'
p60
cnumpy.ma.core
_mareconstruct
p61
(cnumpy.ma.core
MaskedArray
p62
cnumpy
ndarray
p63
(I0
tp64
S'b'
tRp65
(I1
(I48
I1
tg23
(S'f4'
I0
I1
tRp66
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p67
g61
(g62
g63
g64
S'b'
tRp68
(I1
(I48
I1
tg66
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x00\x01\x01\x01\x01\x01\x01\x01'
NtbstRp69
(dp70
S'isNumeric'
p71
(dp72
g60
I01
sg67
I01
ssS'trials'
p73
g33
sS'dataTypes'
p74
(lp75
g60
ag67
asS'dataShape'
p76
(lp77
I48
aI1
asbsS'method'
p78
S'fullRandom'
p79
sS'sequenceIndices'
p80
cnumpy.core.multiarray
_reconstruct
p81
(g63
(I0
tS'b'
tRp82
(I1
(I48
I1
tg23
(S'O4'
I0
I1
tRp83
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp84
I40
aI41
aI0
aI17
aI19
aI20
aI8
aI7
aI47
aI27
aI42
aI1
aI13
aI28
aI43
aI4
aI9
aI23
aI38
aI24
aI22
aI15
aI2
aI11
aI14
aI32
aI35
aI25
aI39
aI46
aI18
aI45
aI33
aI31
aI36
aI26
aI3
aI34
aI5
aI37
aI21
aI30
aI16
aI12
aI44
aI29
aI10
aI6
atbsS'finished'
p85
I00
sS'nReps'
p86
I1
sS'nRemaining'
p87
I47
sS'trialList'
p88
(lp89
g1
(g38
g39
(dp90
g41
g42
sg43
g48
sg45
Vdown
p91
sg47
g48
sg49
g50
sg51
g44
stRp92
ag1
(g38
g39
(dp93
g41
g44
sg43
g48
sg45
g91
sg47
g48
sg49
g42
sg51
g50
stRp94
ag1
(g38
g39
(dp95
g41
g50
sg43
g48
sg45
g91
sg47
g48
sg49
g44
sg51
g42
stRp96
ag1
(g38
g39
(dp97
g41
g48
sg43
g44
sg45
g91
sg47
g44
sg49
g42
sg51
g50
stRp98
ag1
(g38
g39
(dp99
g41
g50
sg43
g44
sg45
g91
sg47
g44
sg49
g48
sg51
g42
stRp100
ag1
(g38
g39
(dp101
g41
g42
sg43
g44
sg45
g91
sg47
g44
sg49
g50
sg51
g48
stRp102
ag1
(g38
g39
(dp103
g41
g50
sg43
g42
sg45
g91
sg47
g42
sg49
g48
sg51
g44
stRp104
ag1
(g38
g39
(dp105
g41
g48
sg43
g42
sg45
g91
sg47
g42
sg49
g44
sg51
g50
stRp106
ag1
(g38
g39
(dp107
g41
g44
sg43
g42
sg45
g91
sg47
g42
sg49
g50
sg51
g48
stRp108
ag1
(g38
g39
(dp109
g41
g48
sg43
g50
sg45
g91
sg47
g50
sg49
g42
sg51
g44
stRp110
ag1
(g38
g39
(dp111
g41
g44
sg43
g50
sg45
g91
sg47
g50
sg49
g48
sg51
g42
stRp112
ag1
(g38
g39
(dp113
g41
g42
sg43
g50
sg45
g91
sg47
g50
sg49
g44
sg51
g48
stRp114
ag1
(g38
g39
(dp115
g41
g44
sg43
g48
sg45
Vleft
p116
sg47
g42
sg49
g48
sg51
g50
stRp117
ag1
(g38
g39
(dp118
g41
g50
sg43
g48
sg45
g116
sg47
g44
sg49
g48
sg51
g42
stRp119
ag1
(g38
g39
(dp120
g41
g42
sg43
g48
sg45
g116
sg47
g50
sg49
g48
sg51
g44
stRp121
ag1
(g38
g39
(dp122
g41
g50
sg43
g44
sg45
g116
sg47
g48
sg49
g44
sg51
g42
stRp123
ag1
(g38
g39
(dp124
g41
g42
sg43
g44
sg45
g116
sg47
g50
sg49
g44
sg51
g48
stRp125
ag1
(g38
g39
(dp126
g41
g48
sg43
g44
sg45
g116
sg47
g42
sg49
g44
sg51
g50
stRp127
ag1
(g38
g39
(dp128
g41
g44
sg43
g42
sg45
g116
sg47
g50
sg49
g42
sg51
g48
stRp129
ag1
(g38
g39
(dp130
g41
g50
sg43
g42
sg45
g116
sg47
g48
sg49
g42
sg51
g44
stRp131
ag1
(g38
g39
(dp132
g41
g48
sg43
g42
sg45
g116
sg47
g44
sg49
g42
sg51
g50
stRp133
ag1
(g38
g39
(dp134
g41
g44
sg43
g50
sg45
g116
sg47
g48
sg49
g50
sg51
g42
stRp135
ag1
(g38
g39
(dp136
g41
g42
sg43
g50
sg45
g116
sg47
g44
sg49
g50
sg51
g48
stRp137
ag1
(g38
g39
(dp138
g41
g48
sg43
g50
sg45
g116
sg47
g42
sg49
g50
sg51
g44
stRp139
ag1
(g38
g39
(dp140
g41
g48
sg43
g48
sg45
Vup
p141
sg47
g42
sg49
g50
sg51
g44
stRp142
ag1
(g38
g39
(dp143
g41
g48
sg43
g48
sg45
g141
sg47
g44
sg49
g42
sg51
g50
stRp144
ag1
(g38
g39
(dp145
g41
g48
sg43
g48
sg45
g141
sg47
g50
sg49
g44
sg51
g42
stRp146
ag1
(g38
g39
(dp147
g41
g44
sg43
g44
sg45
g141
sg47
g48
sg49
g42
sg51
g50
stRp148
ag1
(g38
g39
(dp149
g41
g44
sg43
g44
sg45
g141
sg47
g50
sg49
g48
sg51
g42
stRp150
ag1
(g38
g39
(dp151
g41
g44
sg43
g44
sg45
g141
sg47
g42
sg49
g50
sg51
g48
stRp152
ag1
(g38
g39
(dp153
g41
g42
sg43
g42
sg45
g141
sg47
g50
sg49
g48
sg51
g44
stRp154
ag1
(g38
g39
(dp155
g41
g42
sg43
g42
sg45
g141
sg47
g48
sg49
g44
sg51
g50
stRp156
ag1
(g38
g39
(dp157
g41
g42
sg43
g42
sg45
g141
sg47
g44
sg49
g50
sg51
g48
stRp158
ag1
(g38
g39
(dp159
g41
g50
sg43
g50
sg45
g141
sg47
g48
sg49
g42
sg51
g44
stRp160
ag1
(g38
g39
(dp161
g41
g50
sg43
g50
sg45
g141
sg47
g44
sg49
g48
sg51
g42
stRp162
ag1
(g38
g39
(dp163
g41
g50
sg43
g50
sg45
g141
sg47
g42
sg49
g44
sg51
g48
stRp164
ag1
(g38
g39
(dp165
g41
g44
sg43
g48
sg45
g46
sg47
g50
sg49
g42
sg51
g48
stRp166
ag1
(g38
g39
(dp167
g41
g50
sg43
g48
sg45
g46
sg47
g42
sg49
g44
sg51
g48
stRp168
ag1
(g38
g39
(dp169
g41
g42
sg43
g48
sg45
g46
sg47
g44
sg49
g50
sg51
g48
stRp170
ag1
(g38
g39
(dp171
g41
g50
sg43
g44
sg45
g46
sg47
g42
sg49
g48
sg51
g44
stRp172
ag52
ag1
(g38
g39
(dp173
g41
g48
sg43
g44
sg45
g46
sg47
g50
sg49
g42
sg51
g44
stRp174
ag1
(g38
g39
(dp175
g41
g44
sg43
g42
sg45
g46
sg47
g48
sg49
g50
sg51
g42
stRp176
ag1
(g38
g39
(dp177
g41
g50
sg43
g42
sg45
g46
sg47
g44
sg49
g48
sg51
g42
stRp178
ag1
(g38
g39
(dp179
g41
g48
sg43
g42
sg45
g46
sg47
g50
sg49
g44
sg51
g42
stRp180
ag1
(g38
g39
(dp181
g41
g44
sg43
g50
sg45
g46
sg47
g42
sg49
g48
sg51
g50
stRp182
ag1
(g38
g39
(dp183
g41
g42
sg43
g50
sg45
g46
sg47
g48
sg49
g44
sg51
g50
stRp184
ag1
(g38
g39
(dp185
g41
g48
sg43
g50
sg45
g46
sg47
g44
sg49
g42
sg51
g50
stRp186
asS'seed'
p187
NsS'thisIndex'
p188
I40
sS'thisN'
p189
I0
sS'thisTrialN'
p190
I0
sS'nTotal'
p191
I48
sS'_warnUseOfNext'
p192
I01
sbasS'saveWideText'
p193
I01
sS'thisEntry'
p194
(dp195
sS'version'
p196
S''
sS'_paramNamesSoFar'
p197
(lp198
sS'entries'
p199
(lp200
(dp201
g15
F0.28618407249450684
sg26
g11
sg14
S'return'
p202
sg27
g28
sg19
g20
sg29
V
sg21
g25
sasS'loops'
p203
(lp204
g33
asS'savePickle'
p205
I00
sb.