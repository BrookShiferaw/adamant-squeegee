ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cEyetracking\u005cDocuments\u005cadamant-squeegee\u005cBrook\u005cVWM_task\u005cdata/02_test1_2015_Dec_16_1624
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'test1'
p11
sS'dataNames'
p12
(lp13
S'start.keys'
p14
aS'start.rt'
p15
aS'answer2.keys'
p16
aS'answer2.corr'
p17
aS'answer2.rt'
p18
aS'answer1.keys'
p19
aS'answer1.corr'
p20
aS'answer1.rt'
p21
asS'autoLog'
p22
I01
sS'extraInfo'
p23
(dp24
S'date'
p25
V2015_Dec_16_1624
p26
sS'frameRate'
p27
cnumpy.core.multiarray
scalar
p28
(cnumpy
dtype
p29
(S'f8'
I0
I1
tRp30
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x84\x983-H\xc0q@'
tRp31
sS'expName'
p32
g11
sS'session'
p33
V001
p34
sS'participant'
p35
V02
p36
ssS'loopsUnfinished'
p37
(lp38
sS'saveWideText'
p39
I01
sS'thisEntry'
p40
(dp41
sS'version'
p42
S''
sS'_paramNamesSoFar'
p43
(lp44
Vdownbox
p45
aVtargettest
p46
aVcorrAns
p47
aVupbox
p48
aVrightbox
p49
aVleftbox
p50
asS'entries'
p51
(lp52
(dp53
g15
F7.7829172076162649
sg32
g11
sg14
S'return'
p54
sg33
g34
sg25
g26
sg35
g36
sg27
g31
sa(dp55
g33
g34
sg35
g36
sg27
g31
sg18
F0.72877579191845143
sg15
F7.1400882264133543
sg32
g11
sg14
S'return'
p56
sg16
S'up'
p57
sg25
g26
sg17
I1
sa(dp58
g45
Vgreen
p59
sg35
g36
sg21
F1.193369898119272
sS'task1.thisTrialN'
p60
I0
sg48
Vblue
p61
sg20
I0
sg19
S'up'
p62
sg27
g31
sg49
Vyellow
p63
sg46
Vred
p64
sg32
g11
sg33
g34
sg47
Vright
p65
sS'task1.thisIndex'
p66
I41
sg25
g26
sS'task1.thisRepN'
p67
I0
sS'task1.thisN'
p68
I0
sg50
g64
sa(dp69
g45
g64
sg35
g36
sg21
F0.87039968792305444
sS'task1.thisTrialN'
p70
I1
sg48
g63
sg20
I0
sg19
S'down'
p71
sg27
g31
sg49
g59
sg46
g61
sg32
g11
sg33
g34
sg47
g65
sS'task1.thisIndex'
p72
I45
sg25
g26
sS'task1.thisRepN'
p73
I0
sS'task1.thisN'
p74
I1
sg50
g61
sa(dp75
g45
g59
sg35
g36
sg21
F1.1402598544154898
sS'task1.thisTrialN'
p76
I2
sg48
g63
sg20
I1
sg19
S'left'
p77
sg27
g31
sg49
g64
sg46
g64
sg32
g11
sg33
g34
sg47
Vleft
p78
sS'task1.thisIndex'
p79
I17
sg25
g26
sS'task1.thisRepN'
p80
I0
sS'task1.thisN'
p81
I2
sg50
g61
sa(dp82
g45
g63
sg35
g36
sg21
F0.81992277060999186
sS'task1.thisTrialN'
p83
I3
sg48
g61
sg20
I1
sg19
S'left'
p84
sg27
g31
sg49
g64
sg46
g64
sg32
g11
sg33
g34
sg47
g78
sS'task1.thisIndex'
p85
I16
sg25
g26
sS'task1.thisRepN'
p86
I0
sS'task1.thisN'
p87
I3
sg50
g59
sa(dp88
g45
g64
sg35
g36
sg21
F0.59894578704552259
sS'task1.thisTrialN'
p89
I4
sg48
g61
sg20
I1
sg19
S'right'
p90
sg27
g31
sg49
g63
sg46
g59
sg32
g11
sg33
g34
sg47
g65
sS'task1.thisIndex'
p91
I36
sg25
g26
sS'task1.thisRepN'
p92
I0
sS'task1.thisN'
p93
I4
sg50
g59
sa(dp94
g45
g61
sg35
g36
sg21
F0.72397084954718594
sS'task1.thisTrialN'
p95
I5
sg48
g63
sg20
I1
sg19
S'up'
p96
sg27
g31
sg49
g64
sg46
g61
sg32
g11
sg33
g34
sg47
Vup
p97
sS'task1.thisIndex'
p98
I35
sg25
g26
sS'task1.thisRepN'
p99
I0
sS'task1.thisN'
p100
I5
sg50
g59
sa(dp101
g45
g64
sg35
g36
sg21
F1.3982337393681519
sS'task1.thisTrialN'
p102
I6
sg48
g59
sg20
I1
sg19
S'right'
p103
sg27
g31
sg49
g61
sg46
g63
sg32
g11
sg33
g34
sg47
g65
sS'task1.thisIndex'
p104
I42
sg25
g26
sS'task1.thisRepN'
p105
I0
sS'task1.thisN'
p106
I6
sg50
g63
sa(dp107
g45
g59
sg35
g36
sg21
F0.50091251559570082
sS'task1.thisTrialN'
p108
I7
sg48
g63
sg20
I1
sg19
S'left'
p109
sg27
g31
sg49
g61
sg46
g61
sg32
g11
sg33
g34
sg47
g78
sS'task1.thisIndex'
p110
I23
sg25
g26
sS'task1.thisRepN'
p111
I0
sS'task1.thisN'
p112
I7
sg50
g64
sa(dp113
g45
g61
sg35
g36
sg21
F0.69983674487957614
sS'task1.thisTrialN'
p114
I8
sg48
g63
sg20
I0
sg19
S'up'
p115
sg27
g31
sg49
g64
sg46
g59
sg32
g11
sg33
g34
sg47
g65
sS'task1.thisIndex'
p116
I37
sg25
g26
sS'task1.thisRepN'
p117
I0
sS'task1.thisN'
p118
I8
sg50
g59
sa(dp119
g45
g61
sg35
g36
sg21
F0.76857969329648768
sS'task1.thisTrialN'
p120
I9
sg48
g59
sg20
I1
sg19
S'left'
p121
sg27
g31
sg49
g64
sg46
g64
sg32
g11
sg33
g34
sg47
g78
sS'task1.thisIndex'
p122
I15
sg25
g26
sS'task1.thisRepN'
p123
I0
sS'task1.thisN'
p124
I9
sg50
g63
sa(dp125
g45
g63
sg35
g36
sg21
F1.158342067112244
sS'task1.thisTrialN'
p126
I10
sg48
g64
sg20
I1
sg19
S'right'
p127
sg27
g31
sg49
g61
sg46
g59
sg32
g11
sg33
g34
sg47
g65
sS'task1.thisIndex'
p128
I38
sg25
g26
sS'task1.thisRepN'
p129
I0
sS'task1.thisN'
p130
I10
sg50
g59
sa(dp131
g45
g64
sg35
g36
sg21
F0.4068228385222028
sS'task1.thisTrialN'
p132
I11
sg48
g61
sg20
I1
sg19
S'up'
p133
sg27
g31
sg49
g59
sg46
g64
sg32
g11
sg33
g34
sg47
g97
sS'task1.thisIndex'
p134
I28
sg25
g26
sS'task1.thisRepN'
p135
I0
sS'task1.thisN'
p136
I11
sg50
g63
sa(dp137
g45
g63
sg35
g36
sg21
F0.42565155281408806
sS'task1.thisTrialN'
p138
I12
sg48
g59
sg20
I1
sg19
S'down'
p139
sg27
g31
sg49
g61
sg46
g59
sg32
g11
sg33
g34
sg47
Vdown
p140
sS'task1.thisIndex'
p141
I0
sg25
g26
sS'task1.thisRepN'
p142
I0
sS'task1.thisN'
p143
I12
sg50
g64
sa(dp144
g45
g59
sg35
g36
sg21
F0.4348905927654414
sS'task1.thisTrialN'
p145
I13
sg48
g64
sg20
I1
sg19
S'up'
p146
sg27
g31
sg49
g63
sg46
g59
sg32
g11
sg33
g34
sg47
g97
sS'task1.thisIndex'
p147
I25
sg25
g26
sS'task1.thisRepN'
p148
I0
sS'task1.thisN'
p149
I13
sg50
g61
sa(dp150
g45
g59
sg35
g36
sg21
F0.57693762396957027
sS'task1.thisTrialN'
p151
I14
sg48
g61
sg20
I1
sg19
S'up'
p152
sg27
g31
sg49
g64
sg46
g59
sg32
g11
sg33
g34
sg47
g97
sS'task1.thisIndex'
p153
I26
sg25
g26
sS'task1.thisRepN'
p154
I0
sS'task1.thisN'
p155
I14
sg50
g63
sa(dp156
g45
g64
sg35
g36
sg21
F1.1752206382188888
sS'task1.thisTrialN'
p157
I15
sg48
g59
sg20
I1
sg19
S'down'
p158
sg27
g31
sg49
g63
sg46
g59
sg32
g11
sg33
g34
sg47
g140
sS'task1.thisIndex'
p159
I1
sg25
g26
sS'task1.thisRepN'
p160
I0
sS'task1.thisN'
p161
I15
sg50
g61
sa(dp162
g45
g63
sg35
g36
sg21
F1.1880507133464562
sS'task1.thisTrialN'
p163
I16
sg48
g64
sg20
I1
sg19
S'down'
p164
sg27
g31
sg49
g61
sg46
g64
sg32
g11
sg33
g34
sg47
g140
sS'task1.thisIndex'
p165
I5
sg25
g26
sS'task1.thisRepN'
p166
I0
sS'task1.thisN'
p167
I16
sg50
g59
sa(dp168
g45
g61
sg35
g36
sg21
F1.1255624024961435
sS'task1.thisTrialN'
p169
I17
sg48
g59
sg20
I1
sg19
S'up'
p170
sg27
g31
sg49
g63
sg46
g61
sg32
g11
sg33
g34
sg47
g97
sS'task1.thisIndex'
p171
I33
sg25
g26
sS'task1.thisRepN'
p172
I0
sS'task1.thisN'
p173
I17
sg50
g64
sa(dp174
g45
g61
sg35
g36
sg21
F1.1250735032990633
sS'task1.thisTrialN'
p175
I18
sg48
g63
sg20
I1
sg19
S'right'
p176
sg27
g31
sg49
g59
sg46
g64
sg32
g11
sg33
g34
sg47
g65
sS'task1.thisIndex'
p177
I39
sg25
g26
sS'task1.thisRepN'
p178
I0
sS'task1.thisN'
p179
I18
sg50
g64
sa(dp180
g45
g61
sg35
g36
sg21
F0.72335619675141061
sS'task1.thisTrialN'
p181
I19
sg48
g64
sg20
I1
sg19
S'left'
p182
sg27
g31
sg49
g59
sg46
g59
sg32
g11
sg33
g34
sg47
g78
sS'task1.thisIndex'
p183
I13
sg25
g26
sS'task1.thisRepN'
p184
I0
sS'task1.thisN'
p185
I19
sg50
g63
sa(dp186
g45
g59
sg35
g36
sg21
F0.98297193609687383
sS'task1.thisTrialN'
p187
I20
sg48
g64
sg20
I1
sg19
S'left'
p188
sg27
g31
sg49
g63
sg46
g63
sg32
g11
sg33
g34
sg47
g78
sS'task1.thisIndex'
p189
I20
sg25
g26
sS'task1.thisRepN'
p190
I0
sS'task1.thisN'
p191
I20
sg50
g61
sa(dp192
g45
g61
sg35
g36
sg21
F0.74016772065806435
sS'task1.thisTrialN'
p193
I21
sg48
g64
sg20
I1
sg19
S'up'
p194
sg27
g31
sg49
g59
sg46
g61
sg32
g11
sg33
g34
sg47
g97
sS'task1.thisIndex'
p195
I34
sg25
g26
sS'task1.thisRepN'
p196
I0
sS'task1.thisN'
p197
I21
sg50
g63
sa(dp198
g45
g63
sg35
g36
sg21
F1.1932836029191094
sS'task1.thisTrialN'
p199
I22
sg48
g64
sg20
I1
sg19
S'up'
p200
sg27
g31
sg49
g61
sg46
g63
sg32
g11
sg33
g34
sg47
g97
sS'task1.thisIndex'
p201
I32
sg25
g26
sS'task1.thisRepN'
p202
I0
sS'task1.thisN'
p203
I22
sg50
g59
sa(dp204
g45
g63
sg35
g36
sg21
F0.36772822593775345
sS'task1.thisTrialN'
p205
I23
sg48
g61
sg20
I1
sg19
S'up'
p206
sg27
g31
sg49
g59
sg46
g63
sg32
g11
sg33
g34
sg47
g97
sS'task1.thisIndex'
p207
I30
sg25
g26
sS'task1.thisRepN'
p208
I0
sS'task1.thisN'
p209
I23
sg50
g64
sa(dp210
g45
g61
sg35
g36
sg21
F0.66052623389987275
sS'task1.thisTrialN'
p211
I24
sg48
g63
sg20
I1
sg19
S'down'
p212
sg27
g31
sg49
g59
sg46
g63
sg32
g11
sg33
g34
sg47
g140
sS'task1.thisIndex'
p213
I6
sg25
g26
sS'task1.thisRepN'
p214
I0
sS'task1.thisN'
p215
I24
sg50
g64
sa(dp216
g45
g63
sg35
g36
sg21
F0.66142062429571524
sS'task1.thisTrialN'
p217
I25
sg48
g59
sg20
I1
sg19
S'right'
p218
sg27
g31
sg49
g61
sg46
g64
sg32
g11
sg33
g34
sg47
g65
sS'task1.thisIndex'
p219
I40
sg25
g26
sS'task1.thisRepN'
p220
I0
sS'task1.thisN'
p221
I25
sg50
g64
sa(dp222
g45
g61
sg35
g36
sg21
F1.0947453922672139
sS'task1.thisTrialN'
p223
I26
sg48
g64
sg20
I1
sg19
S'down'
p224
sg27
g31
sg49
g59
sg46
g64
sg32
g11
sg33
g34
sg47
g140
sS'task1.thisIndex'
p225
I4
sg25
g26
sS'task1.thisRepN'
p226
I0
sS'task1.thisN'
p227
I26
sg50
g63
sa(dp228
g45
g64
sg35
g36
sg21
F0.52054226748441579
sS'task1.thisTrialN'
p229
I27
sg48
g63
sg20
I1
sg19
S'left'
p230
sg27
g31
sg49
g59
sg46
g59
sg32
g11
sg33
g34
sg47
g78
sS'task1.thisIndex'
p231
I12
sg25
g26
sS'task1.thisRepN'
p232
I0
sS'task1.thisN'
p233
I27
sg50
g61
sa(dp234
g45
g64
sg35
g36
sg21
F0.9644139769989124
sS'task1.thisTrialN'
p235
I28
sg48
g63
sg20
I1
sg19
S'up'
p236
sg27
g31
sg49
g61
sg46
g64
sg32
g11
sg33
g34
sg47
g97
sS'task1.thisIndex'
p237
I29
sg25
g26
sS'task1.thisRepN'
p238
I0
sS'task1.thisN'
p239
I28
sg50
g59
sa(dp240
g45
g64
sg35
g36
sg21
F1.3973666169731587
sS'task1.thisTrialN'
p241
I29
sg48
g61
sg20
I1
sg19
S'left'
p242
sg27
g31
sg49
g63
sg46
g63
sg32
g11
sg33
g34
sg47
g78
sS'task1.thisIndex'
p243
I18
sg25
g26
sS'task1.thisRepN'
p244
I0
sS'task1.thisN'
p245
I29
sg50
g59
sa(dp246
g45
g64
sg35
g36
sg21
F0.75645152856304776
sS'task1.thisTrialN'
p247
I30
sg48
g59
sg20
I1
sg19
S'left'
p248
sg27
g31
sg49
g61
sg46
g61
sg32
g11
sg33
g34
sg47
g78
sS'task1.thisIndex'
p249
I21
sg25
g26
sS'task1.thisRepN'
p250
I0
sS'task1.thisN'
p251
I30
sg50
g63
sa(dp252
g45
g59
sg35
g36
sg21
F0.93250239717963268
sS'task1.thisTrialN'
p253
I31
sg48
g64
sg20
I1
sg19
S'down'
p254
sg27
g31
sg49
g63
sg46
g64
sg32
g11
sg33
g34
sg47
g140
sS'task1.thisIndex'
p255
I3
sg25
g26
sS'task1.thisRepN'
p256
I0
sS'task1.thisN'
p257
I31
sg50
g61
sa(dp258
g45
g63
sg35
g36
sg21
F0.95124866587138968
sS'task1.thisTrialN'
p259
I32
sg48
g61
sg20
I1
sg19
S'down'
p260
sg27
g31
sg49
g64
sg46
g61
sg32
g11
sg33
g34
sg47
g140
sS'task1.thisIndex'
p261
I11
sg25
g26
sS'task1.thisRepN'
p262
I0
sS'task1.thisN'
p263
I32
sg50
g59
sa(dp264
g45
g64
sg35
g36
sg21
F1.2537656305794371
sS'task1.thisTrialN'
p265
I33
sg48
g59
sg20
I1
sg19
S'up'
p266
sg27
g31
sg49
g63
sg46
g64
sg32
g11
sg33
g34
sg47
g97
sS'task1.thisIndex'
p267
I27
sg25
g26
sS'task1.thisRepN'
p268
I0
sS'task1.thisN'
p269
I33
sg50
g61
sa(dp270
g45
g63
sg35
g36
sg21
F1.0483384645303886
sS'task1.thisTrialN'
p271
I34
sg48
g64
sg20
I0
sg19
S'down'
p272
sg27
g31
sg49
g61
sg46
g61
sg32
g11
sg33
g34
sg47
g78
sS'task1.thisIndex'
p273
I22
sg25
g26
sS'task1.thisRepN'
p274
I0
sS'task1.thisN'
p275
I34
sg50
g59
sa(dp276
g45
g64
sg35
g36
sg21
F0.75533899417132488
sS'task1.thisTrialN'
p277
I35
sg48
g63
sg20
I1
sg19
S'down'
p278
sg27
g31
sg49
g61
sg46
g63
sg32
g11
sg33
g34
sg47
g140
sS'task1.thisIndex'
p279
I8
sg25
g26
sS'task1.thisRepN'
p280
I0
sS'task1.thisN'
p281
I35
sg50
g59
sa(dp282
g45
g64
sg35
g36
sg21
F0.55018258331983816
sS'task1.thisTrialN'
p283
I36
sg48
g61
sg20
I1
sg19
S'down'
p284
sg27
g31
sg49
g59
sg46
g61
sg32
g11
sg33
g34
sg47
g140
sS'task1.thisIndex'
p285
I10
sg25
g26
sS'task1.thisRepN'
p286
I0
sS'task1.thisN'
p287
I36
sg50
g63
sa(dp288
g45
g61
sg35
g36
sg21
F0.80682514828367857
sS'task1.thisTrialN'
p289
I37
sg48
g59
sg20
I0
sg19
S'left'
p290
sg27
g31
sg49
g64
sg46
g59
sg32
g11
sg33
g34
sg47
g140
sS'task1.thisIndex'
p291
I2
sg25
g26
sS'task1.thisRepN'
p292
I0
sS'task1.thisN'
p293
I37
sg50
g63
sa(dp294
g45
g63
sg35
g36
sg21
F0.99726999201448052
sS'task1.thisTrialN'
p295
I38
sg48
g59
sg20
I1
sg19
S'up'
p296
sg27
g31
sg49
g64
sg46
g63
sg32
g11
sg33
g34
sg47
g97
sS'task1.thisIndex'
p297
I31
sg25
g26
sS'task1.thisRepN'
p298
I0
sS'task1.thisN'
p299
I38
sg50
g61
sa(dp300
g45
g63
sg35
g36
sg21
F0.75612559576620697
sS'task1.thisTrialN'
p301
I39
sg48
g59
sg20
I0
sg19
S'down'
p302
sg27
g31
sg49
g64
sg46
g61
sg32
g11
sg33
g34
sg47
g65
sS'task1.thisIndex'
p303
I46
sg25
g26
sS'task1.thisRepN'
p304
I0
sS'task1.thisN'
p305
I39
sg50
g61
sa(dp306
g45
g59
sg35
g36
sg21
F1.046388000537263
sS'task1.thisTrialN'
p307
I40
sg48
g61
sg20
I1
sg19
S'right'
p308
sg27
g31
sg49
g64
sg46
g63
sg32
g11
sg33
g34
sg47
g65
sS'task1.thisIndex'
p309
I44
sg25
g26
sS'task1.thisRepN'
p310
I0
sS'task1.thisN'
p311
I40
sg50
g63
sa(dp312
g45
g61
sg35
g36
sg21
F0.51619606911117444
sS'task1.thisTrialN'
p313
I41
sg48
g59
sg20
I1
sg19
S'left'
p314
sg27
g31
sg49
g63
sg46
g63
sg32
g11
sg33
g34
sg47
g78
sS'task1.thisIndex'
p315
I19
sg25
g26
sS'task1.thisRepN'
p316
I0
sS'task1.thisN'
p317
I41
sg50
g64
sa(dp318
g45
g59
sg35
g36
sg21
F0.67327867542917375
sS'task1.thisTrialN'
p319
I42
sg48
g63
sg20
I0
sg19
S'left'
p320
sg27
g31
sg49
g64
sg46
g63
sg32
g11
sg33
g34
sg47
g140
sS'task1.thisIndex'
p321
I7
sg25
g26
sS'task1.thisRepN'
p322
I0
sS'task1.thisN'
p323
I42
sg50
g61
sa(dp324
g45
g63
sg35
g36
sg21
F0.35735194999870146
sS'task1.thisTrialN'
p325
I43
sg48
g61
sg20
I1
sg19
S'left'
p326
sg27
g31
sg49
g59
sg46
g59
sg32
g11
sg33
g34
sg47
g78
sS'task1.thisIndex'
p327
I14
sg25
g26
sS'task1.thisRepN'
p328
I0
sS'task1.thisN'
p329
I43
sg50
g64
sa(dp330
g45
g59
sg35
g36
sg21
F1.1589608903086628
sS'task1.thisTrialN'
p331
I44
sg48
g64
sg20
I1
sg19
S'right'
p332
sg27
g31
sg49
g63
sg46
g61
sg32
g11
sg33
g34
sg47
g65
sS'task1.thisIndex'
p333
I47
sg25
g26
sS'task1.thisRepN'
p334
I0
sS'task1.thisN'
p335
I44
sg50
g61
sa(dp336
g45
g59
sg35
g36
sg21
F0.99637592241924722
sS'task1.thisTrialN'
p337
I45
sg48
g61
sg20
I0
sg19
S'left'
p338
sg27
g31
sg49
g63
sg46
g61
sg32
g11
sg33
g34
sg47
g140
sS'task1.thisIndex'
p339
I9
sg25
g26
sS'task1.thisRepN'
p340
I0
sS'task1.thisN'
p341
I45
sg50
g64
sa(dp342
g45
g59
sg35
g36
sg21
F0.80534818508749595
sS'task1.thisTrialN'
p343
I46
sg48
g63
sg20
I1
sg19
S'up'
p344
sg27
g31
sg49
g61
sg46
g59
sg32
g11
sg33
g34
sg47
g97
sS'task1.thisIndex'
p345
I24
sg25
g26
sS'task1.thisRepN'
p346
I0
sS'task1.thisN'
p347
I46
sg50
g64
sa(dp348
g45
g61
sg35
g36
sg21
F1.5705501752054261
sS'task1.thisTrialN'
p349
I47
sg48
g64
sg20
I1
sg19
S'right'
p350
sg27
g31
sg49
g59
sg46
g63
sg32
g11
sg33
g34
sg47
g65
sS'task1.thisIndex'
p351
I43
sg25
g26
sS'task1.thisRepN'
p352
I0
sS'task1.thisN'
p353
I47
sg50
g63
sasS'loops'
p354
(lp355
g1
(cpsychopy.data
TrialHandler
p356
g3
NtRp357
(dp358
S'origin'
p359
Vfrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a smaller size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()
p360
sS'thisTrial'
p361
(lp362
sS'_exp'
p363
L471034960L
sg10
S'task2'
p364
sg6
S'C:/Users/Eyetracking/Documents/adamant-squeegee/Brook/VWM_task/VWMtask_b.py'
p365
sS'thisRepN'
p366
I1
sg22
I01
sg23
g24
sS'data'
p367
g1
(cpsychopy.data
DataHandler
p368
c__builtin__
dict
p369
(dp370
S'ran'
p371
cnumpy.ma.core
_mareconstruct
p372
(cnumpy.ma.core
MaskedArray
p373
cnumpy
ndarray
p374
(I0
tp375
S'b'
tRp376
(I1
(L48L
L1L
tg29
(S'f4'
I0
I1
tRp377
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
g372
(g373
g374
g375
S'b'
tRp378
(I1
(L48L
L1L
tg377
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p379
g372
(g373
g374
g375
S'b'
tRp380
(I1
(L48L
L1L
tg377
I00
S'\x00\x00\x1cB\x00\x00\x18B\x00\x00\x00A\x00\x00\x00\x00\x00\x00`A\x00\x00\xa8A\x00\x004B\x00\x00\xb0A\x00\x000B\x00\x008B\x00\x00\x08B\x00\x00\xb8A\x00\x00\x10A\x00\x00@A\x00\x00\xe8A\x00\x00\x0cB\x00\x00\xc0@\x00\x00\x80@\x00\x00\x80?\x00\x00 B\x00\x00\x98A\x00\x00,B\x00\x000A\x00\x00\x80A\x00\x00\xc8A\x00\x00\xe0@\x00\x00pA\x00\x00\x04B\x00\x00\xe0A\x00\x00PA\x00\x00\xd0A\x00\x00 A\x00\x00\xc0A\x00\x00<B\x00\x00\x90A\x00\x00\xf0A\x00\x00\x00@\x00\x00\x88A\x00\x00\xf8A\x00\x00$B\x00\x00@@\x00\x00\x14B\x00\x00\xd8A\x00\x00\xa0@\x00\x00\x10B\x00\x00\xa0A\x00\x00(B\x00\x00\x00B'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg18
g372
(g373
g374
g375
S'b'
tRp381
(I1
(L48L
L1L
tg377
I00
S"\x86\x96\x14?\xb5q\xbe?\xef\xe2\x10?\xdds>?\x7f\x90\x8b?\xce\xd3\x07?$p!?`&\x92?\xd7\x861?\xb4)\x8b?\x0c\xc7\x85?J\xe9U?\x87\x9c\xbc>\x9f\x07,?7f\x08?T\xfa9?v\xfb]?W\xbb\x14?\xd0\xbd\x07?\xcei=?\xbf\x9f\xf7>\xad\xbc\xd5?\x9f\xf25?\r\xe6\xf7>R\xa9%?\xde\x8dT?\xf0\xa9-?\xa2\xff\x1f?\xa0\x1f\x13?3\x8d0?\xf93&?\x92\xd0\x8f?\xcb\x1d\xd7>\r\x91:?\x1fD&?'\xe7\x08?\x7f\xff\x14?\xa8<A?7o\xbe>*\xd9U?\xc4\x14\x08?\xe26\x90?F:\x19?\x9cN&?nU\x11?\x0b\x8c<?T4\xef>\xf2\x9b\xa7>"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg16
cnumpy.core.multiarray
_reconstruct
p382
(g374
(I0
tS'b'
tRp383
(I1
(L48L
L1L
tg29
(S'O8'
I0
I1
tRp384
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp385
S'right'
p386
aS'down'
p387
aS'down'
p388
aS'down'
p389
aS'up'
p390
aS'down'
p391
aS'down'
p392
aS'down'
p393
aS'right'
p394
aS'up'
p395
aS'down'
p396
aS'down'
p397
aS'left'
p398
aS'right'
p399
aS'left'
p400
aS'left'
p401
aS'left'
p402
aS'left'
p403
aS'left'
p404
aS'left'
p405
aS'left'
p406
aS'right'
p407
aS'left'
p408
aS'left'
p409
aS'up'
p410
aS'up'
p411
aS'up'
p412
aS'up'
p413
aS'up'
p414
aS'up'
p415
aS'up'
p416
aS'down'
p417
aS'up'
p418
ag57
aS'up'
p419
aS'up'
p420
aS'right'
p421
aS'right'
p422
aS'right'
p423
aS'right'
p424
aS'down'
p425
aS'right'
p426
aS'up'
p427
aS'right'
p428
aS'right'
p429
aS'down'
p430
aS'right'
p431
aS'right'
p432
atbstRp433
(dp434
S'isNumeric'
p435
(dp436
g371
I01
sg18
I01
sg17
I01
sg379
I01
sg16
I00
ssS'trials'
p437
g357
sS'dataTypes'
p438
(lp439
g371
ag379
ag16
ag17
ag18
asS'dataShape'
p440
(lp441
L48L
aI1
asbsS'method'
p442
S'fullRandom'
p443
sS'sequenceIndices'
p444
g382
(g374
(I0
tS'b'
tRp445
(I1
(L48L
L1L
tg384
I00
(lp446
I3
aI18
aI36
aI40
aI17
aI43
aI16
aI25
aI2
aI12
aI31
aI22
aI13
aI29
aI4
aI26
aI23
aI37
aI34
aI20
aI45
aI5
aI7
aI11
aI32
aI24
aI30
aI42
aI28
aI14
aI35
aI38
aI47
aI27
aI10
aI15
aI44
aI41
aI1
aI0
aI19
aI39
aI46
aI21
aI8
aI6
aI9
aI33
atbsS'finished'
p447
I01
sS'nReps'
p448
I1
sS'nRemaining'
p449
I-1
sS'trialList'
p450
(lp451
g1
(cpsychopy.data
TrialType
p452
g369
(dp453
Vdownbox
p454
Vyellow
p455
sVtargettest
p456
Vgreen
p457
sVcorrAns
p458
Vdown
p459
sVupbox
p460
g457
sVrightbox
p461
Vblue
p462
sVleftbox
p463
Vred
p464
stRp465
ag1
(g452
g369
(dp466
g454
g464
sg456
g457
sg458
g459
sg460
g457
sg461
g455
sg463
g462
stRp467
ag1
(g452
g369
(dp468
g454
g462
sg456
g457
sg458
g459
sg460
g457
sg461
g464
sg463
g455
stRp469
ag1
(g452
g369
(dp470
g454
g457
sg456
g464
sg458
g459
sg460
g464
sg461
g455
sg463
g462
stRp471
ag1
(g452
g369
(dp472
g454
g462
sg456
g464
sg458
g459
sg460
g464
sg461
g457
sg463
g455
stRp473
ag1
(g452
g369
(dp474
g454
g455
sg456
g464
sg458
g459
sg460
g464
sg461
g462
sg463
g457
stRp475
ag1
(g452
g369
(dp476
g454
g462
sg456
g455
sg458
g459
sg460
g455
sg461
g457
sg463
g464
stRp477
ag1
(g452
g369
(dp478
g454
g457
sg456
g455
sg458
g459
sg460
g455
sg461
g464
sg463
g462
stRp479
ag1
(g452
g369
(dp480
g454
g464
sg456
g455
sg458
g459
sg460
g455
sg461
g462
sg463
g457
stRp481
ag1
(g452
g369
(dp482
g454
g457
sg456
g462
sg458
g459
sg460
g462
sg461
g455
sg463
g464
stRp483
ag1
(g452
g369
(dp484
g454
g464
sg456
g462
sg458
g459
sg460
g462
sg461
g457
sg463
g455
stRp485
ag1
(g452
g369
(dp486
g454
g455
sg456
g462
sg458
g459
sg460
g462
sg461
g464
sg463
g457
stRp487
ag1
(g452
g369
(dp488
g454
g464
sg456
g457
sg458
Vleft
p489
sg460
g455
sg461
g457
sg463
g462
stRp490
ag1
(g452
g369
(dp491
g454
g462
sg456
g457
sg458
g489
sg460
g464
sg461
g457
sg463
g455
stRp492
ag1
(g452
g369
(dp493
g454
g455
sg456
g457
sg458
g489
sg460
g462
sg461
g457
sg463
g464
stRp494
ag1
(g452
g369
(dp495
g454
g462
sg456
g464
sg458
g489
sg460
g457
sg461
g464
sg463
g455
stRp496
ag1
(g452
g369
(dp497
g454
g455
sg456
g464
sg458
g489
sg460
g462
sg461
g464
sg463
g457
stRp498
ag1
(g452
g369
(dp499
g454
g457
sg456
g464
sg458
g489
sg460
g455
sg461
g464
sg463
g462
stRp500
ag1
(g452
g369
(dp501
g454
g464
sg456
g455
sg458
g489
sg460
g462
sg461
g455
sg463
g457
stRp502
ag1
(g452
g369
(dp503
g454
g462
sg456
g455
sg458
g489
sg460
g457
sg461
g455
sg463
g464
stRp504
ag1
(g452
g369
(dp505
g454
g457
sg456
g455
sg458
g489
sg460
g464
sg461
g455
sg463
g462
stRp506
ag1
(g452
g369
(dp507
g454
g464
sg456
g462
sg458
g489
sg460
g457
sg461
g462
sg463
g455
stRp508
ag1
(g452
g369
(dp509
g454
g455
sg456
g462
sg458
g489
sg460
g464
sg461
g462
sg463
g457
stRp510
ag1
(g452
g369
(dp511
g454
g457
sg456
g462
sg458
g489
sg460
g455
sg461
g462
sg463
g464
stRp512
ag1
(g452
g369
(dp513
g454
g457
sg456
g457
sg458
Vup
p514
sg460
g455
sg461
g462
sg463
g464
stRp515
ag1
(g452
g369
(dp516
g454
g457
sg456
g457
sg458
g514
sg460
g464
sg461
g455
sg463
g462
stRp517
ag1
(g452
g369
(dp518
g454
g457
sg456
g457
sg458
g514
sg460
g462
sg461
g464
sg463
g455
stRp519
ag1
(g452
g369
(dp520
g454
g464
sg456
g464
sg458
g514
sg460
g457
sg461
g455
sg463
g462
stRp521
ag1
(g452
g369
(dp522
g454
g464
sg456
g464
sg458
g514
sg460
g462
sg461
g457
sg463
g455
stRp523
ag1
(g452
g369
(dp524
g454
g464
sg456
g464
sg458
g514
sg460
g455
sg461
g462
sg463
g457
stRp525
ag1
(g452
g369
(dp526
g454
g455
sg456
g455
sg458
g514
sg460
g462
sg461
g457
sg463
g464
stRp527
ag1
(g452
g369
(dp528
g454
g455
sg456
g455
sg458
g514
sg460
g457
sg461
g464
sg463
g462
stRp529
ag1
(g452
g369
(dp530
g454
g455
sg456
g455
sg458
g514
sg460
g464
sg461
g462
sg463
g457
stRp531
ag1
(g452
g369
(dp532
g454
g462
sg456
g462
sg458
g514
sg460
g457
sg461
g455
sg463
g464
stRp533
ag1
(g452
g369
(dp534
g454
g462
sg456
g462
sg458
g514
sg460
g464
sg461
g457
sg463
g455
stRp535
ag1
(g452
g369
(dp536
g454
g462
sg456
g462
sg458
g514
sg460
g455
sg461
g464
sg463
g457
stRp537
ag1
(g452
g369
(dp538
g454
g464
sg456
g457
sg458
Vright
p539
sg460
g462
sg461
g455
sg463
g457
stRp540
ag1
(g452
g369
(dp541
g454
g462
sg456
g457
sg458
g539
sg460
g455
sg461
g464
sg463
g457
stRp542
ag1
(g452
g369
(dp543
g454
g455
sg456
g457
sg458
g539
sg460
g464
sg461
g462
sg463
g457
stRp544
ag1
(g452
g369
(dp545
g454
g462
sg456
g464
sg458
g539
sg460
g455
sg461
g457
sg463
g464
stRp546
ag1
(g452
g369
(dp547
g454
g455
sg456
g464
sg458
g539
sg460
g457
sg461
g462
sg463
g464
stRp548
ag1
(g452
g369
(dp549
g454
g457
sg456
g464
sg458
g539
sg460
g462
sg461
g455
sg463
g464
stRp550
ag1
(g452
g369
(dp551
g454
g464
sg456
g455
sg458
g539
sg460
g457
sg461
g462
sg463
g455
stRp552
ag1
(g452
g369
(dp553
g454
g462
sg456
g455
sg458
g539
sg460
g464
sg461
g457
sg463
g455
stRp554
ag1
(g452
g369
(dp555
g454
g457
sg456
g455
sg458
g539
sg460
g462
sg461
g464
sg463
g455
stRp556
ag1
(g452
g369
(dp557
g454
g464
sg456
g462
sg458
g539
sg460
g455
sg461
g457
sg463
g462
stRp558
ag1
(g452
g369
(dp559
g454
g455
sg456
g462
sg458
g539
sg460
g457
sg461
g464
sg463
g462
stRp560
ag1
(g452
g369
(dp561
g454
g457
sg456
g462
sg458
g539
sg460
g464
sg461
g455
sg463
g462
stRp562
asS'seed'
p563
NsS'thisIndex'
p564
I33
sS'thisN'
p565
I48
sS'thisTrialN'
p566
I0
sS'nTotal'
p567
I48
sS'_warnUseOfNext'
p568
I01
sbag1
(g356
g3
NtRp569
(dp570
g359
Vfrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a smaller size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()
p571
sg361
(lp572
sg363
L471034960L
sg10
S'task1'
p573
sg6
g365
sg366
I1
sg22
I01
sg23
g24
sg367
g1
(g368
g369
(dp574
g371
g372
(g373
g374
g375
S'b'
tRp575
(I1
(L48L
L1L
tg377
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g372
(g373
g374
g375
S'b'
tRp576
(I1
(L48L
L1L
tg377
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g382
(g374
(I0
tS'b'
tRp577
(I1
(L48L
L1L
tg384
I00
(lp578
g139
ag158
ag290
ag254
ag224
ag164
ag212
ag320
ag278
ag338
ag284
ag260
ag230
ag182
ag326
ag121
ag84
ag77
ag242
ag314
ag188
ag248
ag272
ag109
ag344
ag146
ag152
ag266
ag133
ag236
ag206
ag296
ag200
ag170
ag194
ag96
ag90
ag115
ag127
ag176
ag218
ag62
ag103
ag350
ag308
ag71
ag302
ag332
atbsg21
g372
(g373
g374
g375
S'b'
tRp579
(I1
(L48L
L1L
tg377
I00
S"\x00\xef\xd9>\xa1m\x96?\x18\x8cN?z\xb8n?\x9e \x8c?\x0c\x12\x98??\x18)?\xfe[,?\xe5]A?~\x12\x7f?\xc4\xd8\x0c?\x08\x85s?BB\x05?\xdf-9?\xd6\xf6\xb6>\xa4\xc1D?u\xe6Q?\t\xf4\x91?\xe9\xdc\xb2?m%\x04?\x0c\xa4{?\xcf\xa6A?\xf4/\x86?\xcd;\x00?L+N?\xfb\xa9\xde>/\xb2\x13?d{\xa0?\x15K\xd0>\xd6\xe3v?\xe0F\xbc>\x16M\x7f?\x84\xbd\x98?n\x12\x90?\xa2{=?'V9?\x83T\x19?\x80(3?\x8eD\x94?i\x02\x90?\xddR)?X\xc0\x98?S\xf9\xb2?\xca\x07\xc9?\x0b\xf0\x85?\x84\xd2^?r\x91A?\xd5X\x94?"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg379
g372
(g373
g374
g375
S'b'
tRp580
(I1
(L48L
L1L
tg377
I00
S'\x00\x00@A\x00\x00pA\x00\x00\x14B\x00\x00\xf8A\x00\x00\xd0A\x00\x00\x80A\x00\x00\xc0A\x00\x00(B\x00\x00\x0cB\x00\x004B\x00\x00\x10B\x00\x00\x00B\x00\x00\xd8A\x00\x00\x98A\x00\x00,B\x00\x00\x10A\x00\x00@@\x00\x00\x00@\x00\x00\xe8A\x00\x00$B\x00\x00\xa0A\x00\x00\xf0A\x00\x00\x08B\x00\x00\xe0@\x00\x008B\x00\x00PA\x00\x00`A\x00\x00\x04B\x00\x000A\x00\x00\xe0A\x00\x00\xb8A\x00\x00\x18B\x00\x00\xb0A\x00\x00\x88A\x00\x00\xa8A\x00\x00\xa0@\x00\x00\x80@\x00\x00\x00A\x00\x00 A\x00\x00\x90A\x00\x00\xc8A\x00\x00\x00\x00\x00\x00\xc0@\x00\x00<B\x00\x00 B\x00\x00\x80?\x00\x00\x1cB\x00\x000B'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp581
(dp582
g435
(dp583
g371
I01
sg20
I01
sg19
I00
sg21
I01
sg379
I01
ssg437
g569
sg438
(lp584
g371
ag379
ag19
ag20
ag21
asg440
(lp585
L48L
aI1
asbsg442
g443
sg444
g382
(g374
(I0
tS'b'
tRp586
(I1
(L48L
L1L
tg384
I00
(lp587
I41
aI45
aI17
aI16
aI36
aI35
aI42
aI23
aI37
aI15
aI38
aI28
aI0
aI25
aI26
aI1
aI5
aI33
aI39
aI13
aI20
aI34
aI32
aI30
aI6
aI40
aI4
aI12
aI29
aI18
aI21
aI3
aI11
aI27
aI22
aI8
aI10
aI2
aI31
aI46
aI44
aI19
aI7
aI14
aI47
aI9
aI24
aI43
atbsg447
I01
sg448
I1
sg449
I-1
sg450
(lp588
g1
(g452
g369
(dp589
g45
g63
sg46
g59
sg47
g140
sg48
g59
sg49
g61
sg50
g64
stRp590
ag1
(g452
g369
(dp591
g45
g64
sg46
g59
sg47
g140
sg48
g59
sg49
g63
sg50
g61
stRp592
ag1
(g452
g369
(dp593
g45
g61
sg46
g59
sg47
g140
sg48
g59
sg49
g64
sg50
g63
stRp594
ag1
(g452
g369
(dp595
g45
g59
sg46
g64
sg47
g140
sg48
g64
sg49
g63
sg50
g61
stRp596
ag1
(g452
g369
(dp597
g45
g61
sg46
g64
sg47
g140
sg48
g64
sg49
g59
sg50
g63
stRp598
ag1
(g452
g369
(dp599
g45
g63
sg46
g64
sg47
g140
sg48
g64
sg49
g61
sg50
g59
stRp600
ag1
(g452
g369
(dp601
g45
g61
sg46
g63
sg47
g140
sg48
g63
sg49
g59
sg50
g64
stRp602
ag1
(g452
g369
(dp603
g45
g59
sg46
g63
sg47
g140
sg48
g63
sg49
g64
sg50
g61
stRp604
ag1
(g452
g369
(dp605
g45
g64
sg46
g63
sg47
g140
sg48
g63
sg49
g61
sg50
g59
stRp606
ag1
(g452
g369
(dp607
g45
g59
sg46
g61
sg47
g140
sg48
g61
sg49
g63
sg50
g64
stRp608
ag1
(g452
g369
(dp609
g45
g64
sg46
g61
sg47
g140
sg48
g61
sg49
g59
sg50
g63
stRp610
ag1
(g452
g369
(dp611
g45
g63
sg46
g61
sg47
g140
sg48
g61
sg49
g64
sg50
g59
stRp612
ag1
(g452
g369
(dp613
g45
g64
sg46
g59
sg47
g78
sg48
g63
sg49
g59
sg50
g61
stRp614
ag1
(g452
g369
(dp615
g45
g61
sg46
g59
sg47
g78
sg48
g64
sg49
g59
sg50
g63
stRp616
ag1
(g452
g369
(dp617
g45
g63
sg46
g59
sg47
g78
sg48
g61
sg49
g59
sg50
g64
stRp618
ag1
(g452
g369
(dp619
g45
g61
sg46
g64
sg47
g78
sg48
g59
sg49
g64
sg50
g63
stRp620
ag1
(g452
g369
(dp621
g45
g63
sg46
g64
sg47
g78
sg48
g61
sg49
g64
sg50
g59
stRp622
ag1
(g452
g369
(dp623
g45
g59
sg46
g64
sg47
g78
sg48
g63
sg49
g64
sg50
g61
stRp624
ag1
(g452
g369
(dp625
g45
g64
sg46
g63
sg47
g78
sg48
g61
sg49
g63
sg50
g59
stRp626
ag1
(g452
g369
(dp627
g45
g61
sg46
g63
sg47
g78
sg48
g59
sg49
g63
sg50
g64
stRp628
ag1
(g452
g369
(dp629
g45
g59
sg46
g63
sg47
g78
sg48
g64
sg49
g63
sg50
g61
stRp630
ag1
(g452
g369
(dp631
g45
g64
sg46
g61
sg47
g78
sg48
g59
sg49
g61
sg50
g63
stRp632
ag1
(g452
g369
(dp633
g45
g63
sg46
g61
sg47
g78
sg48
g64
sg49
g61
sg50
g59
stRp634
ag1
(g452
g369
(dp635
g45
g59
sg46
g61
sg47
g78
sg48
g63
sg49
g61
sg50
g64
stRp636
ag1
(g452
g369
(dp637
g45
g59
sg46
g59
sg47
g97
sg48
g63
sg49
g61
sg50
g64
stRp638
ag1
(g452
g369
(dp639
g45
g59
sg46
g59
sg47
g97
sg48
g64
sg49
g63
sg50
g61
stRp640
ag1
(g452
g369
(dp641
g45
g59
sg46
g59
sg47
g97
sg48
g61
sg49
g64
sg50
g63
stRp642
ag1
(g452
g369
(dp643
g45
g64
sg46
g64
sg47
g97
sg48
g59
sg49
g63
sg50
g61
stRp644
ag1
(g452
g369
(dp645
g45
g64
sg46
g64
sg47
g97
sg48
g61
sg49
g59
sg50
g63
stRp646
ag1
(g452
g369
(dp647
g45
g64
sg46
g64
sg47
g97
sg48
g63
sg49
g61
sg50
g59
stRp648
ag1
(g452
g369
(dp649
g45
g63
sg46
g63
sg47
g97
sg48
g61
sg49
g59
sg50
g64
stRp650
ag1
(g452
g369
(dp651
g45
g63
sg46
g63
sg47
g97
sg48
g59
sg49
g64
sg50
g61
stRp652
ag1
(g452
g369
(dp653
g45
g63
sg46
g63
sg47
g97
sg48
g64
sg49
g61
sg50
g59
stRp654
ag1
(g452
g369
(dp655
g45
g61
sg46
g61
sg47
g97
sg48
g59
sg49
g63
sg50
g64
stRp656
ag1
(g452
g369
(dp657
g45
g61
sg46
g61
sg47
g97
sg48
g64
sg49
g59
sg50
g63
stRp658
ag1
(g452
g369
(dp659
g45
g61
sg46
g61
sg47
g97
sg48
g63
sg49
g64
sg50
g59
stRp660
ag1
(g452
g369
(dp661
g45
g64
sg46
g59
sg47
g65
sg48
g61
sg49
g63
sg50
g59
stRp662
ag1
(g452
g369
(dp663
g45
g61
sg46
g59
sg47
g65
sg48
g63
sg49
g64
sg50
g59
stRp664
ag1
(g452
g369
(dp665
g45
g63
sg46
g59
sg47
g65
sg48
g64
sg49
g61
sg50
g59
stRp666
ag1
(g452
g369
(dp667
g45
g61
sg46
g64
sg47
g65
sg48
g63
sg49
g59
sg50
g64
stRp668
ag1
(g452
g369
(dp669
g45
g63
sg46
g64
sg47
g65
sg48
g59
sg49
g61
sg50
g64
stRp670
ag1
(g452
g369
(dp671
g45
g59
sg46
g64
sg47
g65
sg48
g61
sg49
g63
sg50
g64
stRp672
ag1
(g452
g369
(dp673
g45
g64
sg46
g63
sg47
g65
sg48
g59
sg49
g61
sg50
g63
stRp674
ag1
(g452
g369
(dp675
g45
g61
sg46
g63
sg47
g65
sg48
g64
sg49
g59
sg50
g63
stRp676
ag1
(g452
g369
(dp677
g45
g59
sg46
g63
sg47
g65
sg48
g61
sg49
g64
sg50
g63
stRp678
ag1
(g452
g369
(dp679
g45
g64
sg46
g61
sg47
g65
sg48
g63
sg49
g59
sg50
g61
stRp680
ag1
(g452
g369
(dp681
g45
g63
sg46
g61
sg47
g65
sg48
g59
sg49
g64
sg50
g61
stRp682
ag1
(g452
g369
(dp683
g45
g59
sg46
g61
sg47
g65
sg48
g64
sg49
g63
sg50
g61
stRp684
asg563
Nsg564
I43
sg565
I48
sg566
I0
sg567
I48
sg568
I01
sbasS'savePickle'
p685
I00
sb.