ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cEyetracking\u005cDocuments\u005cadamant-squeegee\u005cBrook\u005cVWM_task\u005cdata/test2_test1_2015_Dec_17_1247
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'test1'
p11
sS'dataNames'
p12
(lp13
S'start.keys'
p14
aS'start.rt'
p15
aS'answer1.keys'
p16
aS'answer1.corr'
p17
aS'answer1.rt'
p18
aS'answer2.keys'
p19
aS'answer2.corr'
p20
aS'answer2.rt'
p21
asS'autoLog'
p22
I01
sS'extraInfo'
p23
(dp24
S'date'
p25
V2015_Dec_17_1247
p26
sS'frameRate'
p27
cnumpy.core.multiarray
scalar
p28
(cnumpy
dtype
p29
(S'f8'
I0
I1
tRp30
(I3
S'<'
NNNI-1
I-1
I0
tbS'E<\x1b\x99P\xc4q@'
tRp31
sS'expName'
p32
g11
sS'session'
p33
V001
p34
sS'participant'
p35
Vtest2
p36
ssS'loopsUnfinished'
p37
(lp38
sS'saveWideText'
p39
I01
sS'thisEntry'
p40
(dp41
sS'version'
p42
S''
sS'_paramNamesSoFar'
p43
(lp44
Vdownbox
p45
aVtargettest
p46
aVcorrAns
p47
aVupbox
p48
aVrightbox
p49
aVleftbox
p50
asS'entries'
p51
(lp52
(dp53
g15
F2.9032691350234927
sg32
g11
sg14
S'return'
p54
sg33
g34
sg25
g26
sg35
g36
sg27
g31
sa(dp55
g45
Vgreen
p56
sg35
g36
sg18
F2.5435978770801739
sS'task1.thisTrialN'
p57
I0
sg48
Vyellow
p58
sg17
I1
sg16
S'down'
p59
sg27
g31
sg49
Vred
p60
sg46
g58
sg32
g11
sg33
g34
sg47
Vdown
p61
sS'task1.thisIndex'
p62
I7
sg25
g26
sS'task1.thisRepN'
p63
I0
sS'task1.thisN'
p64
I0
sg50
Vblue
p65
sa(dp66
g45
g60
sg35
g36
sg18
F0.94993770082010087
sS'task1.thisTrialN'
p67
I1
sg48
g65
sg17
I0
sg16
S'up'
p68
sg27
g31
sg49
g56
sg46
g65
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p69
I10
sg25
g26
sS'task1.thisRepN'
p70
I0
sS'task1.thisN'
p71
I1
sg50
g58
sa(dp72
g45
g56
sg35
g36
sg18
F2.1343394233826984
sS'task1.thisTrialN'
p73
I2
sg48
g65
sg17
I0
sg16
S'down'
p74
sg27
g31
sg49
g60
sg46
g56
sg32
g11
sg33
g34
sg47
Vup
p75
sS'task1.thisIndex'
p76
I26
sg25
g26
sS'task1.thisRepN'
p77
I0
sS'task1.thisN'
p78
I2
sg50
g58
sa(dp79
g45
g65
sg35
g36
sg18
F1.3828913363722677
sS'task1.thisTrialN'
p80
I3
sg48
g60
sg17
I0
sg16
S'right'
p81
sg27
g31
sg49
g56
sg46
g56
sg32
g11
sg33
g34
sg47
Vleft
p82
sS'task1.thisIndex'
p83
I13
sg25
g26
sS'task1.thisRepN'
p84
I0
sS'task1.thisN'
p85
I3
sg50
g58
sa(dp86
g45
g65
sg35
g36
sg18
F0.68613917033690086
sS'task1.thisTrialN'
p87
I4
sg48
g56
sg17
I0
sg16
S'down'
p88
sg27
g31
sg49
g60
sg46
g60
sg32
g11
sg33
g34
sg47
g82
sS'task1.thisIndex'
p89
I15
sg25
g26
sS'task1.thisRepN'
p90
I0
sS'task1.thisN'
p91
I4
sg50
g58
sa(dp92
g45
g56
sg35
g36
sg18
F0.9347087272749377
sS'task1.thisTrialN'
p93
I5
sg48
g58
sg17
I0
sg16
S'down'
p94
sg27
g31
sg49
g60
sg46
g60
sg32
g11
sg33
g34
sg47
g82
sS'task1.thisIndex'
p95
I17
sg25
g26
sS'task1.thisRepN'
p96
I0
sS'task1.thisN'
p97
I5
sg50
g65
sa(dp98
g45
g58
sg35
g36
sg18
F0.48635128268279004
sS'task1.thisTrialN'
p99
I6
sg48
g65
sg17
I0
sg16
S'down'
p100
sg27
g31
sg49
g56
sg46
g58
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p101
I30
sg25
g26
sS'task1.thisRepN'
p102
I0
sS'task1.thisN'
p103
I6
sg50
g60
sa(dp104
g45
g56
sg35
g36
sg18
F0.43679937482693276
sS'task1.thisTrialN'
p105
I7
sg48
g60
sg17
I1
sg16
S'right'
p106
sg27
g31
sg49
g58
sg46
g65
sg32
g11
sg33
g34
sg47
Vright
p107
sS'task1.thisIndex'
p108
I47
sg25
g26
sS'task1.thisRepN'
p109
I0
sS'task1.thisN'
p110
I7
sg50
g65
sa(dp111
g45
g65
sg35
g36
sg18
F0.45339559401691076
sS'task1.thisTrialN'
p112
I8
sg48
g60
sg17
I0
sg16
S'right'
p113
sg27
g31
sg49
g56
sg46
g65
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p114
I34
sg25
g26
sS'task1.thisRepN'
p115
I0
sS'task1.thisN'
p116
I8
sg50
g58
sa(dp117
g45
g60
sg35
g36
sg18
F0.42642858242697912
sS'task1.thisTrialN'
p118
I9
sg48
g56
sg17
I0
sg16
S'up'
p119
sg27
g31
sg49
g58
sg46
g56
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p120
I1
sg25
g26
sS'task1.thisRepN'
p121
I0
sS'task1.thisN'
p122
I9
sg50
g65
sa(dp123
g45
g65
sg35
g36
sg18
F0.69251152310289399
sS'task1.thisTrialN'
p124
I10
sg48
g58
sg17
I0
sg16
S'down'
p125
sg27
g31
sg49
g60
sg46
g56
sg32
g11
sg33
g34
sg47
g107
sS'task1.thisIndex'
p126
I37
sg25
g26
sS'task1.thisRepN'
p127
I0
sS'task1.thisN'
p128
I10
sg50
g56
sa(dp129
g45
g65
sg35
g36
sg18
F0.50000609518247074
sS'task1.thisTrialN'
p130
I11
sg48
g56
sg17
I0
sg16
S'right'
p131
sg27
g31
sg49
g58
sg46
g58
sg32
g11
sg33
g34
sg47
g82
sS'task1.thisIndex'
p132
I19
sg25
g26
sS'task1.thisRepN'
p133
I0
sS'task1.thisN'
p134
I11
sg50
g60
sa(dp135
g45
g65
sg35
g36
sg18
F5.2655128807241454
sS'task1.thisTrialN'
p136
I12
sg48
g60
sg17
I0
sg16
S'down'
p137
sg27
g31
sg49
g56
sg46
g58
sg32
g11
sg33
g34
sg47
g107
sS'task1.thisIndex'
p138
I43
sg25
g26
sS'task1.thisRepN'
p139
I0
sS'task1.thisN'
p140
I12
sg50
g58
sa(dp141
g45
g60
sg35
g36
sg18
F0.50218784967091779
sS'task1.thisTrialN'
p142
I13
sg48
g56
sg17
I0
sg16
S'left'
p143
sg27
g31
sg49
g65
sg46
g58
sg32
g11
sg33
g34
sg47
g107
sS'task1.thisIndex'
p144
I42
sg25
g26
sS'task1.thisRepN'
p145
I0
sS'task1.thisN'
p146
I13
sg50
g58
sa(dp147
g45
g56
sg35
g36
sg18
F0.0023264348701559356
sS'task1.thisTrialN'
p148
I14
sg48
g65
sg17
I0
sg16
S'down'
p149
sg27
g31
sg49
g58
sg46
g60
sg32
g11
sg33
g34
sg47
g107
sS'task1.thisIndex'
p150
I41
sg25
g26
sS'task1.thisRepN'
p151
I0
sS'task1.thisN'
p152
I14
sg50
g60
sa(dp153
g45
g60
sg35
g36
sg18
F1.2557686089126037
sS'task1.thisTrialN'
p154
I15
sg48
g56
sg17
I1
sg16
S'up'
p155
sg27
g31
sg49
g58
sg46
g60
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p156
I27
sg25
g26
sS'task1.thisRepN'
p157
I0
sS'task1.thisN'
p158
I15
sg50
g65
sa(dp159
g45
g65
sg35
g36
sg18
F0.54832998419124124
sS'task1.thisTrialN'
p160
I16
sg48
g56
sg17
I0
sg16
S'down'
p161
sg27
g31
sg49
g58
sg46
g65
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p162
I33
sg25
g26
sS'task1.thisRepN'
p163
I0
sS'task1.thisN'
p164
I16
sg50
g60
sa(dp165
g45
g65
sg35
g36
sg18
F0.60031804019990886
sS'task1.thisTrialN'
p166
I17
sg48
g56
sg17
I0
sg16
S'right'
p167
sg27
g31
sg49
g60
sg46
g56
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p168
I2
sg25
g26
sS'task1.thisRepN'
p169
I0
sS'task1.thisN'
p170
I17
sg50
g58
sa(dp171
g45
g60
sg35
g36
sg18
F1.1504624639424037
sS'task1.thisTrialN'
p172
I18
sg48
g65
sg17
I0
sg16
S'up'
p173
sg27
g31
sg49
g58
sg46
g56
sg32
g11
sg33
g34
sg47
g107
sS'task1.thisIndex'
p174
I36
sg25
g26
sS'task1.thisRepN'
p175
I0
sS'task1.thisN'
p176
I18
sg50
g56
sa(dp177
g45
g58
sg35
g36
sg18
F0.77369582345272647
sS'task1.thisTrialN'
p178
I19
sg48
g60
sg17
I0
sg16
S'up'
p179
sg27
g31
sg49
g65
sg46
g56
sg32
g11
sg33
g34
sg47
g107
sS'task1.thisIndex'
p180
I38
sg25
g26
sS'task1.thisRepN'
p181
I0
sS'task1.thisN'
p182
I19
sg50
g56
sa(dp183
g45
g60
sg35
g36
sg18
F0.82287271719405908
sS'task1.thisTrialN'
p184
I20
sg48
g58
sg17
I0
sg16
S'down'
p185
sg27
g31
sg49
g56
sg46
g65
sg32
g11
sg33
g34
sg47
g107
sS'task1.thisIndex'
p186
I45
sg25
g26
sS'task1.thisRepN'
p187
I0
sS'task1.thisN'
p188
I20
sg50
g65
sa(dp189
g45
g58
sg35
g36
sg18
F1.0122259734330328
sS'task1.thisTrialN'
p190
I21
sg48
g56
sg17
I0
sg16
S'right'
p191
sg27
g31
sg49
g65
sg46
g56
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p192
I0
sg25
g26
sS'task1.thisRepN'
p193
I0
sS'task1.thisN'
p194
I21
sg50
g60
sa(dp195
g45
g65
sg35
g36
sg18
F0.055725685996549146
sS'task1.thisTrialN'
p196
I22
sg48
g58
sg17
I0
sg16
S'right'
p197
sg27
g31
sg49
g60
sg46
g65
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p198
I35
sg25
g26
sS'task1.thisRepN'
p199
I0
sS'task1.thisN'
p200
I22
sg50
g56
sa(dp201
g45
g60
sg35
g36
sg18
F0.39021678318113118
sS'task1.thisTrialN'
p202
I23
sg48
g58
sg17
I0
sg16
S'down'
p203
sg27
g31
sg49
g56
sg46
g56
sg32
g11
sg33
g34
sg47
g82
sS'task1.thisIndex'
p204
I12
sg25
g26
sS'task1.thisRepN'
p205
I0
sS'task1.thisN'
p206
I23
sg50
g65
sa(dp207
g45
g58
sg35
g36
sg18
F1.0772942908029108
sS'task1.thisTrialN'
p208
I24
sg48
g60
sg17
I0
sg16
S'down'
p209
sg27
g31
sg49
g65
sg46
g58
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p210
I32
sg25
g26
sS'task1.thisRepN'
p211
I0
sS'task1.thisN'
p212
I24
sg50
g56
sa(dp213
g45
g58
sg35
g36
sg18
F2.6456860865591807
sS'task1.thisTrialN'
p214
I25
sg48
g65
sg17
I0
sg16
S'down'
p215
sg27
g31
sg49
g60
sg46
g60
sg32
g11
sg33
g34
sg47
g82
sS'task1.thisIndex'
p216
I16
sg25
g26
sS'task1.thisRepN'
p217
I0
sS'task1.thisN'
p218
I25
sg50
g56
sa(dp219
g45
g60
sg35
g36
sg18
F1.4639745850145118
sS'task1.thisTrialN'
p220
I26
sg48
g56
sg17
I0
sg16
S'down'
p221
sg27
g31
sg49
g65
sg46
g65
sg32
g11
sg33
g34
sg47
g82
sS'task1.thisIndex'
p222
I21
sg25
g26
sS'task1.thisRepN'
p223
I0
sS'task1.thisN'
p224
I26
sg50
g58
sa(dp225
g45
g56
sg35
g36
sg18
F0.023292899818443402
sS'task1.thisTrialN'
p226
I27
sg48
g60
sg17
I0
sg16
S'down'
p227
sg27
g31
sg49
g58
sg46
g56
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p228
I25
sg25
g26
sS'task1.thisRepN'
p229
I0
sS'task1.thisN'
p230
I27
sg50
g65
sa(dp231
g45
g56
sg35
g36
sg18
F0.99910432899105217
sS'task1.thisTrialN'
p232
I28
sg48
g58
sg17
I0
sg16
S'down'
p233
sg27
g31
sg49
g65
sg46
g56
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p234
I24
sg25
g26
sS'task1.thisRepN'
p235
I0
sS'task1.thisN'
p236
I28
sg50
g60
sa(dp237
g45
g56
sg35
g36
sg18
F3.4134888310591123
sS'task1.thisTrialN'
p238
I29
sg48
g58
sg17
I0
sg16
S'down'
p239
sg27
g31
sg49
g65
sg46
g65
sg32
g11
sg33
g34
sg47
g82
sS'task1.thisIndex'
p240
I23
sg25
g26
sS'task1.thisRepN'
p241
I0
sS'task1.thisN'
p242
I29
sg50
g60
sa(dp243
g45
g58
sg35
g36
sg18
F3.5865753287548614
sS'task1.thisTrialN'
p244
I30
sg48
g60
sg17
I1
sg16
S'down'
p245
sg27
g31
sg49
g65
sg46
g60
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p246
I5
sg25
g26
sS'task1.thisRepN'
p247
I0
sS'task1.thisN'
p248
I30
sg50
g56
sa(dp249
g45
g60
sg35
g36
sg18
F1.2676112274543812
sS'task1.thisTrialN'
p250
I31
sg48
g58
sg17
I0
sg16
S'down'
p251
sg27
g31
sg49
g65
sg46
g60
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p252
I29
sg25
g26
sS'task1.thisRepN'
p253
I0
sS'task1.thisN'
p254
I31
sg50
g56
sa(dp255
g45
g58
sg35
g36
sg18
F0.60020351493130875
sS'task1.thisTrialN'
p256
I32
sg48
g56
sg17
I1
sg16
S'right'
p257
sg27
g31
sg49
g65
sg46
g60
sg32
g11
sg33
g34
sg47
g107
sS'task1.thisIndex'
p258
I40
sg25
g26
sS'task1.thisRepN'
p259
I0
sS'task1.thisN'
p260
I32
sg50
g60
sa(dp261
g45
g58
sg35
g36
sg18
F1.6023920062007164
sS'task1.thisTrialN'
p262
I33
sg48
g65
sg17
I1
sg16
S'left'
p263
sg27
g31
sg49
g56
sg46
g56
sg32
g11
sg33
g34
sg47
g82
sS'task1.thisIndex'
p264
I14
sg25
g26
sS'task1.thisRepN'
p265
I0
sS'task1.thisN'
p266
I33
sg50
g60
sa(dp267
g45
g65
sg35
g36
sg18
F0.74126367887220113
sS'task1.thisTrialN'
p268
I34
sg48
g58
sg17
I1
sg16
S'down'
p269
sg27
g31
sg49
g56
sg46
g58
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p270
I6
sg25
g26
sS'task1.thisRepN'
p271
I0
sS'task1.thisN'
p272
I34
sg50
g60
sa(dp273
g45
g56
sg35
g36
sg18
F0.55011940141457671
sS'task1.thisTrialN'
p274
I35
sg48
g60
sg17
I0
sg16
S'up'
p275
sg27
g31
sg49
g58
sg46
g60
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p276
I3
sg25
g26
sS'task1.thisRepN'
p277
I0
sS'task1.thisN'
p278
I35
sg50
g65
sa(dp279
g45
g65
sg35
g36
sg18
F1.4982121867719798
sS'task1.thisTrialN'
p280
I36
sg48
g58
sg17
I1
sg16
S'right'
p281
sg27
g31
sg49
g56
sg46
g60
sg32
g11
sg33
g34
sg47
g107
sS'task1.thisIndex'
p282
I39
sg25
g26
sS'task1.thisRepN'
p283
I0
sS'task1.thisN'
p284
I36
sg50
g60
sa(dp285
g45
g58
sg35
g36
sg18
F1.6686626784926375
sS'task1.thisTrialN'
p286
I37
sg48
g60
sg17
I0
sg16
S'down'
p287
sg27
g31
sg49
g65
sg46
g65
sg32
g11
sg33
g34
sg47
g82
sS'task1.thisIndex'
p288
I22
sg25
g26
sS'task1.thisRepN'
p289
I0
sS'task1.thisN'
p290
I37
sg50
g56
sa(dp291
g45
g58
sg35
g36
sg18
F2.6733986351923704
sS'task1.thisTrialN'
p292
I38
sg48
g56
sg17
I1
sg16
S'right'
p293
sg27
g31
sg49
g60
sg46
g65
sg32
g11
sg33
g34
sg47
g107
sS'task1.thisIndex'
p294
I46
sg25
g26
sS'task1.thisRepN'
p295
I0
sS'task1.thisN'
p296
I38
sg50
g65
sa(dp297
g45
g60
sg35
g36
sg18
F0.13323683697262823
sS'task1.thisTrialN'
p298
I39
sg48
g65
sg17
I0
sg16
S'left'
p299
sg27
g31
sg49
g56
sg46
g60
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p300
I28
sg25
g26
sS'task1.thisRepN'
p301
I0
sS'task1.thisN'
p302
I39
sg50
g58
sa(dp303
g45
g60
sg35
g36
sg18
F0.59998248437068469
sS'task1.thisTrialN'
p304
I40
sg48
g65
sg17
I0
sg16
S'down'
p305
sg27
g31
sg49
g58
sg46
g58
sg32
g11
sg33
g34
sg47
g82
sS'task1.thisIndex'
p306
I18
sg25
g26
sS'task1.thisRepN'
p307
I0
sS'task1.thisN'
p308
I40
sg50
g56
sa(dp309
g45
g56
sg35
g36
sg18
F1.383499250613113
sS'task1.thisTrialN'
p310
I41
sg48
g65
sg17
I0
sg16
S'down'
p311
sg27
g31
sg49
g60
sg46
g58
sg32
g11
sg33
g34
sg47
g107
sS'task1.thisIndex'
p312
I44
sg25
g26
sS'task1.thisRepN'
p313
I0
sS'task1.thisN'
p314
I41
sg50
g58
sa(dp315
g45
g58
sg35
g36
sg18
F1.8918162873537767
sS'task1.thisTrialN'
p316
I42
sg48
g56
sg17
I0
sg16
S'down'
p317
sg27
g31
sg49
g60
sg46
g58
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p318
I31
sg25
g26
sS'task1.thisRepN'
p319
I0
sS'task1.thisN'
p320
I42
sg50
g65
sa(dp321
g45
g56
sg35
g36
sg18
F0.74476327594902614
sS'task1.thisTrialN'
p322
I43
sg48
g65
sg17
I1
sg16
S'down'
p323
sg27
g31
sg49
g58
sg46
g65
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p324
I9
sg25
g26
sS'task1.thisRepN'
p325
I0
sS'task1.thisN'
p326
I43
sg50
g60
sa(dp327
g45
g58
sg35
g36
sg18
F0.32524342233546122
sS'task1.thisTrialN'
p328
I44
sg48
g65
sg17
I1
sg16
S'down'
p329
sg27
g31
sg49
g60
sg46
g65
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p330
I11
sg25
g26
sS'task1.thisRepN'
p331
I0
sS'task1.thisN'
p332
I44
sg50
g56
sa(dp333
g45
g56
sg35
g36
sg18
F0.56735753954808388
sS'task1.thisTrialN'
p334
I45
sg48
g60
sg17
I0
sg16
S'down'
p335
sg27
g31
sg49
g58
sg46
g58
sg32
g11
sg33
g34
sg47
g82
sS'task1.thisIndex'
p336
I20
sg25
g26
sS'task1.thisRepN'
p337
I0
sS'task1.thisN'
p338
I45
sg50
g65
sa(dp339
g45
g60
sg35
g36
sg18
F0.65550350055946183
sS'task1.thisTrialN'
p340
I46
sg48
g58
sg17
I1
sg16
S'down'
p341
sg27
g31
sg49
g65
sg46
g58
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p342
I8
sg25
g26
sS'task1.thisRepN'
p343
I0
sS'task1.thisN'
p344
I46
sg50
g56
sa(dp345
g45
g65
sg35
g36
sg18
F0.69812486526461726
sS'task1.thisTrialN'
p346
I47
sg48
g60
sg17
I1
sg16
S'down'
p347
sg27
g31
sg49
g56
sg46
g60
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p348
I4
sg25
g26
sS'task1.thisRepN'
p349
I0
sS'task1.thisN'
p350
I47
sg50
g58
sa(dp351
g15
F1.8106990340102129
sg32
g11
sg14
S'return'
p352
sg33
g34
sg25
g26
sg35
g36
sg27
g31
sa(dp353
S'task2.thisRepN'
p354
I0
sVdownbox
p355
Vblue
p356
sg35
g36
sS'task2.thisIndex'
p357
I34
sg27
g31
sVrightbox
p358
Vgreen
p359
sg21
F0.59930206953913512
sVleftbox
p360
Vyellow
p361
sS'task2.thisN'
p362
I0
sVtargettest
p363
g356
sg32
g11
sg33
g34
sVcorrAns
p364
Vup
p365
sg19
S'up'
p366
sg25
g26
sVupbox
p367
Vred
p368
sg20
I1
sS'task2.thisTrialN'
p369
I0
sa(dp370
S'task2.thisRepN'
p371
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p372
I5
sg27
g31
sg358
g356
sg21
F2.0493876587311206
sg360
g359
sS'task2.thisN'
p373
I1
sg363
g368
sg32
g11
sg33
g34
sg364
Vdown
p374
sg19
S'down'
p375
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p376
I1
sa(dp377
S'task2.thisRepN'
p378
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p379
I14
sg27
g31
sg358
g359
sg21
F2.00182438432239
sg360
g368
sS'task2.thisN'
p380
I2
sg363
g359
sg32
g11
sg33
g34
sg364
Vleft
p381
sg19
S'down'
p382
sg25
g26
sg367
g356
sg20
I0
sS'task2.thisTrialN'
p383
I2
sa(dp384
S'task2.thisRepN'
p385
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p386
I22
sg27
g31
sg358
g356
sg21
F2.5511289560940895
sg360
g359
sS'task2.thisN'
p387
I3
sg363
g356
sg32
g11
sg33
g34
sg364
g381
sg19
S'down'
p388
sg25
g26
sg367
g368
sg20
I0
sS'task2.thisTrialN'
p389
I3
sa(dp390
S'task2.thisRepN'
p391
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p392
I38
sg27
g31
sg358
g356
sg21
F3.7025076221857489
sg360
g359
sS'task2.thisN'
p393
I4
sg363
g359
sg32
g11
sg33
g34
sg364
Vright
p394
sg19
S'down'
p395
sg25
g26
sg367
g368
sg20
I0
sS'task2.thisTrialN'
p396
I4
sa(dp397
S'task2.thisRepN'
p398
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p399
I17
sg27
g31
sg358
g368
sg21
F1.8718699634546283
sg360
g356
sS'task2.thisN'
p400
I5
sg363
g368
sg32
g11
sg33
g34
sg364
g381
sg19
S'down'
p401
sg25
g26
sg367
g361
sg20
I0
sS'task2.thisTrialN'
p402
I5
sa(dp403
S'task2.thisRepN'
p404
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p405
I23
sg27
g31
sg358
g356
sg21
F3.5247474028105898
sg360
g368
sS'task2.thisN'
p406
I6
sg363
g356
sg32
g11
sg33
g34
sg364
g381
sg19
S'down'
p407
sg25
g26
sg367
g361
sg20
I0
sS'task2.thisTrialN'
p408
I6
sa(dp409
S'task2.thisRepN'
p410
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p411
I7
sg27
g31
sg358
g368
sg21
F0.61030804410120254
sg360
g356
sS'task2.thisN'
p412
I7
sg363
g361
sg32
g11
sg33
g34
sg364
g374
sg19
S'down'
p413
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p414
I7
sa(dp415
S'task2.thisRepN'
p416
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p417
I47
sg27
g31
sg358
g361
sg21
F2.2950411521051137
sg360
g356
sS'task2.thisN'
p418
I8
sg363
g356
sg32
g11
sg33
g34
sg364
g394
sg19
S'down'
p419
sg25
g26
sg367
g368
sg20
I0
sS'task2.thisTrialN'
p420
I8
sa(dp421
S'task2.thisRepN'
p422
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p423
I31
sg27
g31
sg358
g368
sg21
F0.46919623150915868
sg360
g356
sS'task2.thisN'
p424
I9
sg363
g361
sg32
g11
sg33
g34
sg364
g365
sg19
S'down'
p425
sg25
g26
sg367
g359
sg20
I0
sS'task2.thisTrialN'
p426
I9
sa(dp427
S'task2.thisRepN'
p428
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p429
I26
sg27
g31
sg358
g368
sg21
F0.54809419687353511
sg360
g361
sS'task2.thisN'
p430
I10
sg363
g359
sg32
g11
sg33
g34
sg364
g365
sg19
S'down'
p431
sg25
g26
sg367
g356
sg20
I0
sS'task2.thisTrialN'
p432
I10
sa(dp433
S'task2.thisRepN'
p434
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p435
I3
sg27
g31
sg358
g361
sg21
F2.4357484370671045
sg360
g356
sS'task2.thisN'
p436
I11
sg363
g368
sg32
g11
sg33
g34
sg364
g374
sg19
S'down'
p437
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p438
I11
sa(dp439
S'task2.thisRepN'
p440
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p441
I10
sg27
g31
sg358
g359
sg21
F3.0303998824592782
sg360
g361
sS'task2.thisN'
p442
I12
sg363
g356
sg32
g11
sg33
g34
sg364
g374
sg19
S'down'
p443
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p444
I12
sa(dp445
S'task2.thisRepN'
p446
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p447
I28
sg27
g31
sg358
g359
sg21
F0.23815673986018737
sg360
g361
sS'task2.thisN'
p448
I13
sg363
g368
sg32
g11
sg33
g34
sg364
g365
sg19
S'down'
p449
sg25
g26
sg367
g356
sg20
I0
sS'task2.thisTrialN'
p450
I13
sa(dp451
S'task2.thisRepN'
p452
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p453
I20
sg27
g31
sg358
g361
sg21
F0.45064570437216389
sg360
g356
sS'task2.thisN'
p454
I14
sg363
g361
sg32
g11
sg33
g34
sg364
g381
sg19
S'down'
p455
sg25
g26
sg367
g368
sg20
I0
sS'task2.thisTrialN'
p456
I14
sa(dp457
S'task2.thisRepN'
p458
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p459
I29
sg27
g31
sg358
g356
sg21
F1.9755615266958557
sg360
g359
sS'task2.thisN'
p460
I15
sg363
g368
sg32
g11
sg33
g34
sg364
g365
sg19
S'down'
p461
sg25
g26
sg367
g361
sg20
I0
sS'task2.thisTrialN'
p462
I15
sa(dp463
S'task2.thisRepN'
p464
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p465
I1
sg27
g31
sg358
g361
sg21
F1.7000021814337742
sg360
g356
sS'task2.thisN'
p466
I16
sg363
g359
sg32
g11
sg33
g34
sg364
g374
sg19
S'down'
p467
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p468
I16
sa(dp469
S'task2.thisRepN'
p470
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p471
I32
sg27
g31
sg358
g356
sg21
F0.93547832424837907
sg360
g359
sS'task2.thisN'
p472
I17
sg363
g361
sg32
g11
sg33
g34
sg364
g365
sg19
S'down'
p473
sg25
g26
sg367
g368
sg20
I0
sS'task2.thisTrialN'
p474
I17
sa(dp475
S'task2.thisRepN'
p476
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p477
I21
sg27
g31
sg358
g356
sg21
F2.2266673210970112
sg360
g361
sS'task2.thisN'
p478
I18
sg363
g356
sg32
g11
sg33
g34
sg364
g381
sg19
S'down'
p479
sg25
g26
sg367
g359
sg20
I0
sS'task2.thisTrialN'
p480
I18
sa(dp481
S'task2.thisRepN'
p482
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p483
I16
sg27
g31
sg358
g368
sg21
F1.6385694799464545
sg360
g359
sS'task2.thisN'
p484
I19
sg363
g368
sg32
g11
sg33
g34
sg364
g381
sg19
S'down'
p485
sg25
g26
sg367
g356
sg20
I0
sS'task2.thisTrialN'
p486
I19
sa(dp487
S'task2.thisRepN'
p488
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p489
I9
sg27
g31
sg358
g361
sg21
F1.3988844533073461
sg360
g368
sS'task2.thisN'
p490
I20
sg363
g356
sg32
g11
sg33
g34
sg364
g374
sg19
S'down'
p491
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p492
I20
sa(dp493
S'task2.thisRepN'
p494
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p495
I6
sg27
g31
sg358
g359
sg21
F4.0213033039740367
sg360
g368
sS'task2.thisN'
p496
I21
sg363
g361
sg32
g11
sg33
g34
sg364
g374
sg19
S'down'
p497
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p498
I21
sa(dp499
S'task2.thisRepN'
p500
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p501
I12
sg27
g31
sg358
g359
sg21
F3.3332621159393057
sg360
g356
sS'task2.thisN'
p502
I22
sg363
g359
sg32
g11
sg33
g34
sg364
g381
sg19
S'down'
p503
sg25
g26
sg367
g361
sg20
I0
sS'task2.thisTrialN'
p504
I22
sa(dp505
S'task2.thisRepN'
p506
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p507
I41
sg27
g31
sg358
g361
sg21
F0.35803004989065812
sg360
g368
sS'task2.thisN'
p508
I23
sg363
g368
sg32
g11
sg33
g34
sg364
g394
sg19
S'down'
p509
sg25
g26
sg367
g356
sg20
I0
sS'task2.thisTrialN'
p510
I23
sa(dp511
S'task2.thisRepN'
p512
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p513
I43
sg27
g31
sg358
g359
sg21
F0.48443290423256258
sg360
g361
sS'task2.thisN'
p514
I24
sg363
g361
sg32
g11
sg33
g34
sg364
g394
sg19
S'down'
p515
sg25
g26
sg367
g368
sg20
I0
sS'task2.thisTrialN'
p516
I24
sa(dp517
S'task2.thisRepN'
p518
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p519
I0
sg27
g31
sg358
g356
sg21
F4.724019445556678
sg360
g368
sS'task2.thisN'
p520
I25
sg363
g359
sg32
g11
sg33
g34
sg364
g374
sg19
S'down'
p521
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p522
I25
sa(dp523
S'task2.thisRepN'
p524
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p525
I39
sg27
g31
sg358
g359
sg21
F4.9116615595453368
sg360
g368
sS'task2.thisN'
p526
I26
sg363
g368
sg32
g11
sg33
g34
sg364
g394
sg19
S'down'
p527
sg25
g26
sg367
g361
sg20
I0
sS'task2.thisTrialN'
p528
I26
sa(dp529
S'task2.thisRepN'
p530
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p531
I27
sg27
g31
sg358
g361
sg21
F2.9231195399997887
sg360
g356
sS'task2.thisN'
p532
I27
sg363
g368
sg32
g11
sg33
g34
sg364
g365
sg19
S'down'
p533
sg25
g26
sg367
g359
sg20
I0
sS'task2.thisTrialN'
p534
I27
sa(dp535
S'task2.thisRepN'
p536
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p537
I35
sg27
g31
sg358
g368
sg21
F2.0492888526173374
sg360
g359
sS'task2.thisN'
p538
I28
sg363
g356
sg32
g11
sg33
g34
sg364
g365
sg19
S'down'
p539
sg25
g26
sg367
g361
sg20
I0
sS'task2.thisTrialN'
p540
I28
sa(dp541
S'task2.thisRepN'
p542
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p543
I42
sg27
g31
sg358
g356
sg21
F4.6547890810261379
sg360
g361
sS'task2.thisN'
p544
I29
sg363
g361
sg32
g11
sg33
g34
sg364
g394
sg19
S'down'
p545
sg25
g26
sg367
g359
sg20
I0
sS'task2.thisTrialN'
p546
I29
sa(dp547
S'task2.thisRepN'
p548
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p549
I18
sg27
g31
sg358
g361
sg21
F3.4464403493375357
sg360
g359
sS'task2.thisN'
p550
I30
sg363
g361
sg32
g11
sg33
g34
sg364
g381
sg19
S'down'
p551
sg25
g26
sg367
g356
sg20
I0
sS'task2.thisTrialN'
p552
I30
sa(dp553
S'task2.thisRepN'
p554
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p555
I2
sg27
g31
sg358
g368
sg21
F1.969304982394533
sg360
g361
sS'task2.thisN'
p556
I31
sg363
g359
sg32
g11
sg33
g34
sg364
g374
sg19
S'down'
p557
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p558
I31
sa(dp559
S'task2.thisRepN'
p560
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p561
I37
sg27
g31
sg358
g368
sg21
F3.3818837064868603
sg360
g359
sS'task2.thisN'
p562
I32
sg363
g359
sg32
g11
sg33
g34
sg364
g394
sg19
S'down'
p563
sg25
g26
sg367
g361
sg20
I0
sS'task2.thisTrialN'
p564
I32
sa(dp565
S'task2.thisRepN'
p566
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p567
I44
sg27
g31
sg358
g368
sg21
F3.8272567573117158
sg360
g361
sS'task2.thisN'
p568
I33
sg363
g361
sg32
g11
sg33
g34
sg364
g394
sg19
S'down'
p569
sg25
g26
sg367
g356
sg20
I0
sS'task2.thisTrialN'
p570
I33
sa(dp571
S'task2.thisRepN'
p572
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p573
I4
sg27
g31
sg358
g359
sg21
F3.0442240768688862
sg360
g361
sS'task2.thisN'
p574
I34
sg363
g368
sg32
g11
sg33
g34
sg364
g374
sg19
S'down'
p575
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p576
I34
sa(dp577
S'task2.thisRepN'
p578
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p579
I19
sg27
g31
sg358
g361
sg21
F1.046107167421269
sg360
g368
sS'task2.thisN'
p580
I35
sg363
g361
sg32
g11
sg33
g34
sg364
g381
sg19
S'down'
p581
sg25
g26
sg367
g359
sg20
I0
sS'task2.thisTrialN'
p582
I35
sa(dp583
S'task2.thisRepN'
p584
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p585
I46
sg27
g31
sg358
g368
sg21
F0.81963104257101804
sg360
g356
sS'task2.thisN'
p586
I36
sg363
g356
sg32
g11
sg33
g34
sg364
g394
sg19
S'down'
p587
sg25
g26
sg367
g359
sg20
I0
sS'task2.thisTrialN'
p588
I36
sa(dp589
S'task2.thisRepN'
p590
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p591
I25
sg27
g31
sg358
g361
sg21
F0.81871965240770805
sg360
g356
sS'task2.thisN'
p592
I37
sg363
g359
sg32
g11
sg33
g34
sg364
g365
sg19
S'down'
p593
sg25
g26
sg367
g368
sg20
I0
sS'task2.thisTrialN'
p594
I37
sa(dp595
S'task2.thisRepN'
p596
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p597
I45
sg27
g31
sg358
g359
sg21
F0.48292161980452875
sg360
g356
sS'task2.thisN'
p598
I38
sg363
g356
sg32
g11
sg33
g34
sg364
g394
sg19
S'down'
p599
sg25
g26
sg367
g361
sg20
I0
sS'task2.thisTrialN'
p600
I38
sa(dp601
S'task2.thisRepN'
p602
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p603
I11
sg27
g31
sg358
g368
sg21
F1.0454588324969336
sg360
g359
sS'task2.thisN'
p604
I39
sg363
g356
sg32
g11
sg33
g34
sg364
g374
sg19
S'down'
p605
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p606
I39
sa(dp607
S'task2.thisRepN'
p608
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p609
I36
sg27
g31
sg358
g361
sg21
F0.48286965035458707
sg360
g359
sS'task2.thisN'
p610
I40
sg363
g359
sg32
g11
sg33
g34
sg364
g394
sg19
S'down'
p611
sg25
g26
sg367
g356
sg20
I0
sS'task2.thisTrialN'
p612
I40
sa(dp613
S'task2.thisRepN'
p614
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p615
I8
sg27
g31
sg358
g356
sg21
F0.50553699198235336
sg360
g359
sS'task2.thisN'
p616
I41
sg363
g361
sg32
g11
sg33
g34
sg364
g374
sg19
S'down'
p617
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p618
I41
sa(dp619
S'task2.thisRepN'
p620
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p621
I15
sg27
g31
sg358
g368
sg21
F2.7700342228449699
sg360
g361
sS'task2.thisN'
p622
I42
sg363
g368
sg32
g11
sg33
g34
sg364
g381
sg19
S'down'
p623
sg25
g26
sg367
g359
sg20
I0
sS'task2.thisTrialN'
p624
I42
sa(dp625
S'task2.thisRepN'
p626
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p627
I30
sg27
g31
sg358
g359
sg21
F1.7788674252924466
sg360
g368
sS'task2.thisN'
p628
I43
sg363
g361
sg32
g11
sg33
g34
sg364
g365
sg19
S'down'
p629
sg25
g26
sg367
g356
sg20
I0
sS'task2.thisTrialN'
p630
I43
sa(dp631
S'task2.thisRepN'
p632
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p633
I33
sg27
g31
sg358
g361
sg21
F2.0206447034788653
sg360
g368
sS'task2.thisN'
p634
I44
sg363
g356
sg32
g11
sg33
g34
sg364
g365
sg19
S'down'
p635
sg25
g26
sg367
g359
sg20
I0
sS'task2.thisTrialN'
p636
I44
sa(dp637
S'task2.thisRepN'
p638
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p639
I40
sg27
g31
sg358
g356
sg21
F2.1172953686882465
sg360
g368
sS'task2.thisN'
p640
I45
sg363
g368
sg32
g11
sg33
g34
sg364
g394
sg19
S'down'
p641
sg25
g26
sg367
g359
sg20
I0
sS'task2.thisTrialN'
p642
I45
sa(dp643
S'task2.thisRepN'
p644
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p645
I24
sg27
g31
sg358
g356
sg21
F1.873958044614028
sg360
g368
sS'task2.thisN'
p646
I46
sg363
g359
sg32
g11
sg33
g34
sg364
g365
sg19
S'down'
p647
sg25
g26
sg367
g361
sg20
I0
sS'task2.thisTrialN'
p648
I46
sa(dp649
S'task2.thisRepN'
p650
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p651
I13
sg27
g31
sg358
g359
sg21
F3.1286080271629544
sg360
g361
sS'task2.thisN'
p652
I47
sg363
g359
sg32
g11
sg33
g34
sg364
g381
sg19
S'down'
p653
sg25
g26
sg367
g368
sg20
I0
sS'task2.thisTrialN'
p654
I47
sasS'loops'
p655
(lp656
g1
(cpsychopy.data
TrialHandler
p657
g3
NtRp658
(dp659
S'origin'
p660
V\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a larger size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a#########start of task1########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'task1'\u000a\u000a # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()\u000a
p661
sS'thisTrial'
p662
(lp663
sS'_exp'
p664
L541579472L
sg10
S'task1'
p665
sg6
S'C:/Users/Eyetracking/Documents/adamant-squeegee/Brook/VWM_task/VWMtask_a.py'
p666
sS'thisRepN'
p667
I1
sg22
I01
sg23
g24
sS'data'
p668
g1
(cpsychopy.data
DataHandler
p669
c__builtin__
dict
p670
(dp671
S'ran'
p672
cnumpy.ma.core
_mareconstruct
p673
(cnumpy.ma.core
MaskedArray
p674
cnumpy
ndarray
p675
(I0
tp676
S'b'
tRp677
(I1
(L48L
L1L
tg29
(S'f4'
I0
I1
tRp678
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
g673
(g674
g675
g676
S'b'
tRp679
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg16
cnumpy.core.multiarray
_reconstruct
p680
(g675
(I0
tS'b'
tRp681
(I1
(L48L
L1L
tg29
(S'O8'
I0
I1
tRp682
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp683
g191
ag119
ag167
ag275
ag347
ag245
ag269
ag59
ag341
ag323
ag68
ag329
ag203
ag81
ag263
ag88
ag215
ag94
ag305
ag131
ag335
ag221
ag287
ag239
ag233
ag227
ag74
ag155
ag299
ag251
ag100
ag317
ag209
ag161
ag113
ag197
ag173
ag125
ag179
ag281
ag257
ag149
ag143
ag137
ag311
ag185
ag293
ag106
atbsg18
g673
(g674
g675
g676
S'b'
tRp684
(I1
(L48L
L1L
tg678
I00
S'\x9f\x90\x81?\xd9T\xda>q\xae\x19?\xa0\xd4\x0c?P\xb82?s\x8ae@u\xc3=?O\xca"@\x14\xcf\'?\xce\xa8>?\x1e/s?N\x86\xa6>\x7f\xca\xc7>\x95\x02\xb1?.\x1b\xcd?\xd1\xa6/?\xecR)@\x12Io?t\x98\x19?f\x00\x00?X>\x11?\x85c\xbb?\xbd\x96\xd5?\x9avZ@M\xc5\x7f?\xc0\xd0\xbe<\x04\x99\x08@\x07\xbd\xa0?=o\x08>\x16A\xa2?\t\x03\xf9>\t\'\xf2?\xc8\xe4\x89?[_\x0c?x#\xe8>\x9e@d=[B\x93?oH1?\xee\x10F?k\xc5\xbf?\xf0\xa6\x19?\x1aw\x18;b\x8f\x00?\x15\x7f\xa8@\x81\x16\xb1?\xc9\xa7R?\xf7\x18+@+\xa4\xdf>'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p685
g673
(g674
g675
g676
S'b'
tRp686
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\xa8A\x00\x00\x10A\x00\x00\x88A\x00\x00\x0cB\x00\x00<B\x00\x00\xf0A\x00\x00\x08B\x00\x00\x00\x00\x00\x008B\x00\x00,B\x00\x00\x80?\x00\x000B\x00\x00\xb8A\x00\x00@@\x00\x00\x04B\x00\x00\x80@\x00\x00\xc8A\x00\x00\xa0@\x00\x00 B\x00\x000A\x00\x004B\x00\x00\xd0A\x00\x00\x14B\x00\x00\xe8A\x00\x00\xe0A\x00\x00\xd8A\x00\x00\x00@\x00\x00pA\x00\x00\x1cB\x00\x00\xf8A\x00\x00\xc0@\x00\x00(B\x00\x00\xc0A\x00\x00\x80A\x00\x00\x00A\x00\x00\xb0A\x00\x00\x90A\x00\x00 A\x00\x00\x98A\x00\x00\x10B\x00\x00\x00B\x00\x00`A\x00\x00PA\x00\x00@A\x00\x00$B\x00\x00\xa0A\x00\x00\x18B\x00\x00\xe0@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp687
(dp688
S'isNumeric'
p689
(dp690
g672
I01
sg17
I01
sg16
I00
sg18
I01
sg685
I01
ssS'trials'
p691
g658
sS'dataTypes'
p692
(lp693
g672
ag685
ag16
ag17
ag18
asS'dataShape'
p694
(lp695
L48L
aI1
asbsS'method'
p696
S'fullRandom'
p697
sS'sequenceIndices'
p698
g680
(g675
(I0
tS'b'
tRp699
(I1
(L48L
L1L
tg682
I00
(lp700
I7
aI10
aI26
aI13
aI15
aI17
aI30
aI47
aI34
aI1
aI37
aI19
aI43
aI42
aI41
aI27
aI33
aI2
aI36
aI38
aI45
aI0
aI35
aI12
aI32
aI16
aI21
aI25
aI24
aI23
aI5
aI29
aI40
aI14
aI6
aI3
aI39
aI22
aI46
aI28
aI18
aI44
aI31
aI9
aI11
aI20
aI8
aI4
atbsS'finished'
p701
I01
sS'nReps'
p702
I1
sS'nRemaining'
p703
I-1
sS'trialList'
p704
(lp705
g1
(cpsychopy.data
TrialType
p706
g670
(dp707
g45
g58
sg46
g56
sg47
g61
sg48
g56
sg49
g65
sg50
g60
stRp708
ag1
(g706
g670
(dp709
g45
g60
sg46
g56
sg47
g61
sg48
g56
sg49
g58
sg50
g65
stRp710
ag1
(g706
g670
(dp711
g45
g65
sg46
g56
sg47
g61
sg48
g56
sg49
g60
sg50
g58
stRp712
ag1
(g706
g670
(dp713
g45
g56
sg46
g60
sg47
g61
sg48
g60
sg49
g58
sg50
g65
stRp714
ag1
(g706
g670
(dp715
g45
g65
sg46
g60
sg47
g61
sg48
g60
sg49
g56
sg50
g58
stRp716
ag1
(g706
g670
(dp717
g45
g58
sg46
g60
sg47
g61
sg48
g60
sg49
g65
sg50
g56
stRp718
ag1
(g706
g670
(dp719
g45
g65
sg46
g58
sg47
g61
sg48
g58
sg49
g56
sg50
g60
stRp720
ag1
(g706
g670
(dp721
g45
g56
sg46
g58
sg47
g61
sg48
g58
sg49
g60
sg50
g65
stRp722
ag1
(g706
g670
(dp723
g45
g60
sg46
g58
sg47
g61
sg48
g58
sg49
g65
sg50
g56
stRp724
ag1
(g706
g670
(dp725
g45
g56
sg46
g65
sg47
g61
sg48
g65
sg49
g58
sg50
g60
stRp726
ag1
(g706
g670
(dp727
g45
g60
sg46
g65
sg47
g61
sg48
g65
sg49
g56
sg50
g58
stRp728
ag1
(g706
g670
(dp729
g45
g58
sg46
g65
sg47
g61
sg48
g65
sg49
g60
sg50
g56
stRp730
ag1
(g706
g670
(dp731
g45
g60
sg46
g56
sg47
g82
sg48
g58
sg49
g56
sg50
g65
stRp732
ag1
(g706
g670
(dp733
g45
g65
sg46
g56
sg47
g82
sg48
g60
sg49
g56
sg50
g58
stRp734
ag1
(g706
g670
(dp735
g45
g58
sg46
g56
sg47
g82
sg48
g65
sg49
g56
sg50
g60
stRp736
ag1
(g706
g670
(dp737
g45
g65
sg46
g60
sg47
g82
sg48
g56
sg49
g60
sg50
g58
stRp738
ag1
(g706
g670
(dp739
g45
g58
sg46
g60
sg47
g82
sg48
g65
sg49
g60
sg50
g56
stRp740
ag1
(g706
g670
(dp741
g45
g56
sg46
g60
sg47
g82
sg48
g58
sg49
g60
sg50
g65
stRp742
ag1
(g706
g670
(dp743
g45
g60
sg46
g58
sg47
g82
sg48
g65
sg49
g58
sg50
g56
stRp744
ag1
(g706
g670
(dp745
g45
g65
sg46
g58
sg47
g82
sg48
g56
sg49
g58
sg50
g60
stRp746
ag1
(g706
g670
(dp747
g45
g56
sg46
g58
sg47
g82
sg48
g60
sg49
g58
sg50
g65
stRp748
ag1
(g706
g670
(dp749
g45
g60
sg46
g65
sg47
g82
sg48
g56
sg49
g65
sg50
g58
stRp750
ag1
(g706
g670
(dp751
g45
g58
sg46
g65
sg47
g82
sg48
g60
sg49
g65
sg50
g56
stRp752
ag1
(g706
g670
(dp753
g45
g56
sg46
g65
sg47
g82
sg48
g58
sg49
g65
sg50
g60
stRp754
ag1
(g706
g670
(dp755
g45
g56
sg46
g56
sg47
g75
sg48
g58
sg49
g65
sg50
g60
stRp756
ag1
(g706
g670
(dp757
g45
g56
sg46
g56
sg47
g75
sg48
g60
sg49
g58
sg50
g65
stRp758
ag1
(g706
g670
(dp759
g45
g56
sg46
g56
sg47
g75
sg48
g65
sg49
g60
sg50
g58
stRp760
ag1
(g706
g670
(dp761
g45
g60
sg46
g60
sg47
g75
sg48
g56
sg49
g58
sg50
g65
stRp762
ag1
(g706
g670
(dp763
g45
g60
sg46
g60
sg47
g75
sg48
g65
sg49
g56
sg50
g58
stRp764
ag1
(g706
g670
(dp765
g45
g60
sg46
g60
sg47
g75
sg48
g58
sg49
g65
sg50
g56
stRp766
ag1
(g706
g670
(dp767
g45
g58
sg46
g58
sg47
g75
sg48
g65
sg49
g56
sg50
g60
stRp768
ag1
(g706
g670
(dp769
g45
g58
sg46
g58
sg47
g75
sg48
g56
sg49
g60
sg50
g65
stRp770
ag1
(g706
g670
(dp771
g45
g58
sg46
g58
sg47
g75
sg48
g60
sg49
g65
sg50
g56
stRp772
ag1
(g706
g670
(dp773
g45
g65
sg46
g65
sg47
g75
sg48
g56
sg49
g58
sg50
g60
stRp774
ag1
(g706
g670
(dp775
g45
g65
sg46
g65
sg47
g75
sg48
g60
sg49
g56
sg50
g58
stRp776
ag1
(g706
g670
(dp777
g45
g65
sg46
g65
sg47
g75
sg48
g58
sg49
g60
sg50
g56
stRp778
ag1
(g706
g670
(dp779
g45
g60
sg46
g56
sg47
g107
sg48
g65
sg49
g58
sg50
g56
stRp780
ag1
(g706
g670
(dp781
g45
g65
sg46
g56
sg47
g107
sg48
g58
sg49
g60
sg50
g56
stRp782
ag1
(g706
g670
(dp783
g45
g58
sg46
g56
sg47
g107
sg48
g60
sg49
g65
sg50
g56
stRp784
ag1
(g706
g670
(dp785
g45
g65
sg46
g60
sg47
g107
sg48
g58
sg49
g56
sg50
g60
stRp786
ag1
(g706
g670
(dp787
g45
g58
sg46
g60
sg47
g107
sg48
g56
sg49
g65
sg50
g60
stRp788
ag1
(g706
g670
(dp789
g45
g56
sg46
g60
sg47
g107
sg48
g65
sg49
g58
sg50
g60
stRp790
ag1
(g706
g670
(dp791
g45
g60
sg46
g58
sg47
g107
sg48
g56
sg49
g65
sg50
g58
stRp792
ag1
(g706
g670
(dp793
g45
g65
sg46
g58
sg47
g107
sg48
g60
sg49
g56
sg50
g58
stRp794
ag1
(g706
g670
(dp795
g45
g56
sg46
g58
sg47
g107
sg48
g65
sg49
g60
sg50
g58
stRp796
ag1
(g706
g670
(dp797
g45
g60
sg46
g65
sg47
g107
sg48
g58
sg49
g56
sg50
g65
stRp798
ag1
(g706
g670
(dp799
g45
g58
sg46
g65
sg47
g107
sg48
g56
sg49
g60
sg50
g65
stRp800
ag1
(g706
g670
(dp801
g45
g56
sg46
g65
sg47
g107
sg48
g60
sg49
g58
sg50
g65
stRp802
asS'seed'
p803
NsS'thisIndex'
p804
I4
sS'thisN'
p805
I48
sS'thisTrialN'
p806
I0
sS'nTotal'
p807
I48
sS'_warnUseOfNext'
p808
I01
sbag1
(g657
g3
NtRp809
(dp810
g660
V\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a larger size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a#########start of task1########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'task1'\u000a\u000a # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()\u000a
p811
sg662
(lp812
sg664
L541579472L
sg10
S'task2'
p813
sg6
g666
sg667
I1
sg22
I01
sg23
g24
sg668
g1
(g669
g670
(dp814
g672
g673
(g674
g675
g676
S'b'
tRp815
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g673
(g674
g675
g676
S'b'
tRp816
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg685
g673
(g674
g675
g676
S'b'
tRp817
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\xc8A\x00\x00\x80A\x00\x00\xf8A\x00\x000A\x00\x00\x08B\x00\x00\x80?\x00\x00\xa8A\x00\x00\xe0@\x00\x00$B\x00\x00\xa0A\x00\x00@A\x00\x00\x1cB\x00\x00\xb0A\x00\x00<B\x00\x00\x00@\x00\x00(B\x00\x00\x98A\x00\x00\xa0@\x00\x00\xf0A\x00\x00\x0cB\x00\x00`A\x00\x00\x90A\x00\x00@@\x00\x00\xc0@\x00\x008B\x00\x00\x14B\x00\x00 A\x00\x00\xd8A\x00\x00PA\x00\x00pA\x00\x00,B\x00\x00\x10A\x00\x00\x88A\x00\x000B\x00\x00\x00\x00\x00\x00\xe0A\x00\x00 B\x00\x00\x00B\x00\x00\x80@\x00\x00\xd0A\x00\x004B\x00\x00\xb8A\x00\x00\xe8A\x00\x00\xc0A\x00\x00\x04B\x00\x00\x18B\x00\x00\x10B\x00\x00\x00A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g673
(g674
g675
g676
S'b'
tRp818
(I1
(L48L
L1L
tg678
I00
S"++\x97@\xac\x99\xd9?0\x12\xfc?M\xe3\x1b@\x91\xd4B@+)\x03@\x84\xae\x80@&=\x1c?\xdfj\x01?\xa5\x0e\xb3?\x12\xf2A@\x98\xd1\x85?+TU@\x1d;H@\xe4\x1d\x00@>H1@\xa5\xbc\xd1?o\x99\xef?{\x92\\@\xd7\xe6\x85?\t\xbb\xe6>\xb8\x81\x0e@\xb2E#@v\x95a@\xdb\xdd\xef?\x9c\x97Q?\xe7O\x0c?d\x14;@\\\xdfs>3\xdf\xfc?\xee\xb1\xe3?}:\xf0>\x82{o?>R\x01@\xdck\x19?\x8c'\x03@\xb1:\xf7>\xc8pX@\xe3\xf5l@U,\x9d@\xc4\x81\x07@\xb7O\xb7>\x08\xf4\x94@\x97\x07\xf8>\xc6\xf1t@\x81A\xf7>W\xd3Q?\xf4\xe1\x12@"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g680
(g675
(I0
tS'b'
tRp819
(I1
(L48L
L1L
tg682
I00
(lp820
g521
ag467
ag557
ag437
ag575
ag375
ag497
ag413
ag617
ag491
ag443
ag605
ag503
ag653
ag382
ag623
ag485
ag401
ag551
ag581
ag455
ag479
ag388
ag407
ag647
ag593
ag431
ag533
ag449
ag461
ag629
ag425
ag473
ag635
ag366
ag539
ag611
ag563
ag395
ag527
ag641
ag509
ag545
ag515
ag569
ag599
ag587
ag419
atbstRp821
(dp822
g689
(dp823
g672
I01
sg21
I01
sg20
I01
sg685
I01
sg19
I00
ssg691
g809
sg692
(lp824
g672
ag685
ag19
ag20
ag21
asg694
(lp825
L48L
aI1
asbsg696
g697
sg698
g680
(g675
(I0
tS'b'
tRp826
(I1
(L48L
L1L
tg682
I00
(lp827
I34
aI5
aI14
aI22
aI38
aI17
aI23
aI7
aI47
aI31
aI26
aI3
aI10
aI28
aI20
aI29
aI1
aI32
aI21
aI16
aI9
aI6
aI12
aI41
aI43
aI0
aI39
aI27
aI35
aI42
aI18
aI2
aI37
aI44
aI4
aI19
aI46
aI25
aI45
aI11
aI36
aI8
aI15
aI30
aI33
aI40
aI24
aI13
atbsg701
I01
sg702
I1
sg703
I-1
sg704
(lp828
g1
(g706
g670
(dp829
g355
g361
sg363
g359
sg364
g374
sg367
g359
sg358
g356
sg360
g368
stRp830
ag1
(g706
g670
(dp831
g355
g368
sg363
g359
sg364
g374
sg367
g359
sg358
g361
sg360
g356
stRp832
ag1
(g706
g670
(dp833
g355
g356
sg363
g359
sg364
g374
sg367
g359
sg358
g368
sg360
g361
stRp834
ag1
(g706
g670
(dp835
g355
g359
sg363
g368
sg364
g374
sg367
g368
sg358
g361
sg360
g356
stRp836
ag1
(g706
g670
(dp837
g355
g356
sg363
g368
sg364
g374
sg367
g368
sg358
g359
sg360
g361
stRp838
ag1
(g706
g670
(dp839
g355
g361
sg363
g368
sg364
g374
sg367
g368
sg358
g356
sg360
g359
stRp840
ag1
(g706
g670
(dp841
g355
g356
sg363
g361
sg364
g374
sg367
g361
sg358
g359
sg360
g368
stRp842
ag1
(g706
g670
(dp843
g355
g359
sg363
g361
sg364
g374
sg367
g361
sg358
g368
sg360
g356
stRp844
ag1
(g706
g670
(dp845
g355
g368
sg363
g361
sg364
g374
sg367
g361
sg358
g356
sg360
g359
stRp846
ag1
(g706
g670
(dp847
g355
g359
sg363
g356
sg364
g374
sg367
g356
sg358
g361
sg360
g368
stRp848
ag1
(g706
g670
(dp849
g355
g368
sg363
g356
sg364
g374
sg367
g356
sg358
g359
sg360
g361
stRp850
ag1
(g706
g670
(dp851
g355
g361
sg363
g356
sg364
g374
sg367
g356
sg358
g368
sg360
g359
stRp852
ag1
(g706
g670
(dp853
g355
g368
sg363
g359
sg364
g381
sg367
g361
sg358
g359
sg360
g356
stRp854
ag1
(g706
g670
(dp855
g355
g356
sg363
g359
sg364
g381
sg367
g368
sg358
g359
sg360
g361
stRp856
ag1
(g706
g670
(dp857
g355
g361
sg363
g359
sg364
g381
sg367
g356
sg358
g359
sg360
g368
stRp858
ag1
(g706
g670
(dp859
g355
g356
sg363
g368
sg364
g381
sg367
g359
sg358
g368
sg360
g361
stRp860
ag1
(g706
g670
(dp861
g355
g361
sg363
g368
sg364
g381
sg367
g356
sg358
g368
sg360
g359
stRp862
ag1
(g706
g670
(dp863
g355
g359
sg363
g368
sg364
g381
sg367
g361
sg358
g368
sg360
g356
stRp864
ag1
(g706
g670
(dp865
g355
g368
sg363
g361
sg364
g381
sg367
g356
sg358
g361
sg360
g359
stRp866
ag1
(g706
g670
(dp867
g355
g356
sg363
g361
sg364
g381
sg367
g359
sg358
g361
sg360
g368
stRp868
ag1
(g706
g670
(dp869
g355
g359
sg363
g361
sg364
g381
sg367
g368
sg358
g361
sg360
g356
stRp870
ag1
(g706
g670
(dp871
g355
g368
sg363
g356
sg364
g381
sg367
g359
sg358
g356
sg360
g361
stRp872
ag1
(g706
g670
(dp873
g355
g361
sg363
g356
sg364
g381
sg367
g368
sg358
g356
sg360
g359
stRp874
ag1
(g706
g670
(dp875
g355
g359
sg363
g356
sg364
g381
sg367
g361
sg358
g356
sg360
g368
stRp876
ag1
(g706
g670
(dp877
g355
g359
sg363
g359
sg364
g365
sg367
g361
sg358
g356
sg360
g368
stRp878
ag1
(g706
g670
(dp879
g355
g359
sg363
g359
sg364
g365
sg367
g368
sg358
g361
sg360
g356
stRp880
ag1
(g706
g670
(dp881
g355
g359
sg363
g359
sg364
g365
sg367
g356
sg358
g368
sg360
g361
stRp882
ag1
(g706
g670
(dp883
g355
g368
sg363
g368
sg364
g365
sg367
g359
sg358
g361
sg360
g356
stRp884
ag1
(g706
g670
(dp885
g355
g368
sg363
g368
sg364
g365
sg367
g356
sg358
g359
sg360
g361
stRp886
ag1
(g706
g670
(dp887
g355
g368
sg363
g368
sg364
g365
sg367
g361
sg358
g356
sg360
g359
stRp888
ag1
(g706
g670
(dp889
g355
g361
sg363
g361
sg364
g365
sg367
g356
sg358
g359
sg360
g368
stRp890
ag1
(g706
g670
(dp891
g355
g361
sg363
g361
sg364
g365
sg367
g359
sg358
g368
sg360
g356
stRp892
ag1
(g706
g670
(dp893
g355
g361
sg363
g361
sg364
g365
sg367
g368
sg358
g356
sg360
g359
stRp894
ag1
(g706
g670
(dp895
g355
g356
sg363
g356
sg364
g365
sg367
g359
sg358
g361
sg360
g368
stRp896
ag1
(g706
g670
(dp897
g355
g356
sg363
g356
sg364
g365
sg367
g368
sg358
g359
sg360
g361
stRp898
ag1
(g706
g670
(dp899
g355
g356
sg363
g356
sg364
g365
sg367
g361
sg358
g368
sg360
g359
stRp900
ag1
(g706
g670
(dp901
g355
g368
sg363
g359
sg364
g394
sg367
g356
sg358
g361
sg360
g359
stRp902
ag1
(g706
g670
(dp903
g355
g356
sg363
g359
sg364
g394
sg367
g361
sg358
g368
sg360
g359
stRp904
ag1
(g706
g670
(dp905
g355
g361
sg363
g359
sg364
g394
sg367
g368
sg358
g356
sg360
g359
stRp906
ag1
(g706
g670
(dp907
g355
g356
sg363
g368
sg364
g394
sg367
g361
sg358
g359
sg360
g368
stRp908
ag1
(g706
g670
(dp909
g355
g361
sg363
g368
sg364
g394
sg367
g359
sg358
g356
sg360
g368
stRp910
ag1
(g706
g670
(dp911
g355
g359
sg363
g368
sg364
g394
sg367
g356
sg358
g361
sg360
g368
stRp912
ag1
(g706
g670
(dp913
g355
g368
sg363
g361
sg364
g394
sg367
g359
sg358
g356
sg360
g361
stRp914
ag1
(g706
g670
(dp915
g355
g356
sg363
g361
sg364
g394
sg367
g368
sg358
g359
sg360
g361
stRp916
ag1
(g706
g670
(dp917
g355
g359
sg363
g361
sg364
g394
sg367
g356
sg358
g368
sg360
g361
stRp918
ag1
(g706
g670
(dp919
g355
g368
sg363
g356
sg364
g394
sg367
g361
sg358
g359
sg360
g356
stRp920
ag1
(g706
g670
(dp921
g355
g361
sg363
g356
sg364
g394
sg367
g359
sg358
g368
sg360
g356
stRp922
ag1
(g706
g670
(dp923
g355
g359
sg363
g356
sg364
g394
sg367
g368
sg358
g361
sg360
g356
stRp924
asg803
Nsg804
I13
sg805
I48
sg806
I0
sg807
I48
sg808
I01
sbasS'savePickle'
p925
I00
sb.