ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cEyetracking\u005cDocuments\u005cadamant-squeegee\u005cBrook\u005cVWM_task\u005cdata/04a_test1_2015_Dec_18_1605
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'test1'
p11
sS'dataNames'
p12
(lp13
S'start.keys'
p14
aS'start.rt'
p15
aS'answer1.keys'
p16
aS'answer1.corr'
p17
aS'answer1.rt'
p18
aS'answer2.keys'
p19
aS'answer2.corr'
p20
aS'answer2.rt'
p21
asS'autoLog'
p22
I01
sS'extraInfo'
p23
(dp24
S'date'
p25
V2015_Dec_18_1605
p26
sS'frameRate'
p27
cnumpy.core.multiarray
scalar
p28
(cnumpy
dtype
p29
(S'f8'
I0
I1
tRp30
(I3
S'<'
NNNI-1
I-1
I0
tbS'%x\x1e\x97\x95\xb9q@'
tRp31
sS'expName'
p32
g11
sS'session'
p33
V001
p34
sS'participant'
p35
V04a
p36
ssS'loopsUnfinished'
p37
(lp38
sS'saveWideText'
p39
I01
sS'thisEntry'
p40
(dp41
sS'version'
p42
S''
sS'_paramNamesSoFar'
p43
(lp44
Vdownbox
p45
aVtargettest
p46
aVcorrAns
p47
aVupbox
p48
aVrightbox
p49
aVleftbox
p50
asS'entries'
p51
(lp52
(dp53
g15
F16.199611382882267
sg32
g11
sg14
S'return'
p54
sg33
g34
sg25
g26
sg35
g36
sg27
g31
sa(dp55
g45
Vyellow
p56
sg35
g36
sg18
F0.99491147042863304
sS'task1.thisTrialN'
p57
I0
sg48
Vgreen
p58
sg17
I1
sg16
S'down'
p59
sg27
g31
sg49
Vblue
p60
sg46
g58
sg32
g11
sg33
g34
sg47
Vdown
p61
sS'task1.thisIndex'
p62
I0
sg25
g26
sS'task1.thisRepN'
p63
I0
sS'task1.thisN'
p64
I0
sg50
Vred
p65
sa(dp66
g45
g60
sg35
g36
sg18
F1.0893360626998856
sS'task1.thisTrialN'
p67
I1
sg48
g65
sg17
I1
sg16
S'down'
p68
sg27
g31
sg49
g58
sg46
g65
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p69
I4
sg25
g26
sS'task1.thisRepN'
p70
I0
sS'task1.thisN'
p71
I1
sg50
g56
sa(dp72
g45
g65
sg35
g36
sg18
F1.1122883401710624
sS'task1.thisTrialN'
p73
I2
sg48
g58
sg17
I1
sg16
S'up'
p74
sg27
g31
sg49
g56
sg46
g65
sg32
g11
sg33
g34
sg47
Vup
p75
sS'task1.thisIndex'
p76
I27
sg25
g26
sS'task1.thisRepN'
p77
I0
sS'task1.thisN'
p78
I2
sg50
g60
sa(dp79
g45
g60
sg35
g36
sg18
F1.0924346698823229
sS'task1.thisTrialN'
p80
I3
sg48
g58
sg17
I1
sg16
S'up'
p81
sg27
g31
sg49
g56
sg46
g60
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p82
I33
sg25
g26
sS'task1.thisRepN'
p83
I0
sS'task1.thisN'
p84
I3
sg50
g65
sa(dp85
g45
g65
sg35
g36
sg18
F3.1403567360139277
sS'task1.thisTrialN'
p86
I4
sg48
g60
sg17
I0
sg16
S'up'
p87
sg27
g31
sg49
g58
sg46
g60
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p88
I10
sg25
g26
sS'task1.thisRepN'
p89
I0
sS'task1.thisN'
p90
I4
sg50
g56
sa(dp91
g45
g56
sg35
g36
sg18
F2.3111769606573489
sS'task1.thisTrialN'
p92
I5
sg48
g65
sg17
I1
sg16
S'right'
p93
sg27
g31
sg49
g60
sg46
g58
sg32
g11
sg33
g34
sg47
Vright
p94
sS'task1.thisIndex'
p95
I38
sg25
g26
sS'task1.thisRepN'
p96
I0
sS'task1.thisN'
p97
I5
sg50
g58
sa(dp98
g45
g58
sg35
g36
sg18
F1.2343520978874949
sS'task1.thisTrialN'
p99
I6
sg48
g56
sg17
I1
sg16
S'left'
p100
sg27
g31
sg49
g65
sg46
g65
sg32
g11
sg33
g34
sg47
Vleft
p101
sS'task1.thisIndex'
p102
I17
sg25
g26
sS'task1.thisRepN'
p103
I0
sS'task1.thisN'
p104
I6
sg50
g60
sa(dp105
g45
g65
sg35
g36
sg18
F1.7343666942874734
sS'task1.thisTrialN'
p106
I7
sg48
g56
sg17
I1
sg16
S'up'
p107
sg27
g31
sg49
g60
sg46
g65
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p108
I29
sg25
g26
sS'task1.thisRepN'
p109
I0
sS'task1.thisN'
p110
I7
sg50
g58
sa(dp111
g45
g56
sg35
g36
sg18
F1.2365454074752051
sS'task1.thisTrialN'
p112
I8
sg48
g60
sg17
I1
sg16
S'left'
p113
sg27
g31
sg49
g58
sg46
g58
sg32
g11
sg33
g34
sg47
g101
sS'task1.thisIndex'
p114
I14
sg25
g26
sS'task1.thisRepN'
p115
I0
sS'task1.thisN'
p116
I8
sg50
g65
sa(dp117
g45
g58
sg35
g36
sg18
F1.1122941145711138
sS'task1.thisTrialN'
p118
I9
sg48
g60
sg17
I1
sg16
S'down'
p119
sg27
g31
sg49
g56
sg46
g60
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p120
I9
sg25
g26
sS'task1.thisRepN'
p121
I0
sS'task1.thisN'
p122
I9
sg50
g65
sa(dp123
g45
g56
sg35
g36
sg18
F2.8560647400061043
sS'task1.thisTrialN'
p124
I10
sg48
g58
sg17
I1
sg16
S'right'
p125
sg27
g31
sg49
g65
sg46
g60
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p126
I46
sg25
g26
sS'task1.thisRepN'
p127
I0
sS'task1.thisN'
p128
I10
sg50
g60
sa(dp129
g45
g65
sg35
g36
sg18
F1.1251495328990586
sS'task1.thisTrialN'
p130
I11
sg48
g58
sg17
I1
sg16
S'down'
p131
sg27
g31
sg49
g56
sg46
g58
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p132
I1
sg25
g26
sS'task1.thisRepN'
p133
I0
sS'task1.thisN'
p134
I11
sg50
g60
sa(dp135
g45
g60
sg35
g36
sg18
F1.5729593831915736
sS'task1.thisTrialN'
p136
I12
sg48
g65
sg17
I1
sg16
S'right'
p137
sg27
g31
sg49
g58
sg46
g56
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p138
I43
sg25
g26
sS'task1.thisRepN'
p139
I0
sS'task1.thisN'
p140
I12
sg50
g56
sa(dp141
g45
g58
sg35
g36
sg18
F1.5891354023008262
sS'task1.thisTrialN'
p142
I13
sg48
g56
sg17
I0
sg16
S'up'
p143
sg27
g31
sg49
g60
sg46
g60
sg32
g11
sg33
g34
sg47
g101
sS'task1.thisIndex'
p144
I23
sg25
g26
sS'task1.thisRepN'
p145
I0
sS'task1.thisN'
p146
I13
sg50
g65
sa(dp147
g45
g60
sg35
g36
sg18
F0.84256708008160786
sS'task1.thisTrialN'
p148
I14
sg48
g65
sg17
I1
sg16
S'up'
p149
sg27
g31
sg49
g58
sg46
g60
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p150
I34
sg25
g26
sS'task1.thisRepN'
p151
I0
sS'task1.thisN'
p152
I14
sg50
g56
sa(dp153
g45
g60
sg35
g36
sg18
F0.77215051807593227
sS'task1.thisTrialN'
p154
I15
sg48
g56
sg17
I1
sg16
S'down'
p155
sg27
g31
sg49
g58
sg46
g56
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p156
I6
sg25
g26
sS'task1.thisRepN'
p157
I0
sS'task1.thisN'
p158
I15
sg50
g65
sa(dp159
g45
g56
sg35
g36
sg18
F1.7144847935990128
sS'task1.thisTrialN'
p160
I16
sg48
g65
sg17
I1
sg16
S'down'
p161
sg27
g31
sg49
g60
sg46
g65
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p162
I5
sg25
g26
sS'task1.thisRepN'
p163
I0
sS'task1.thisN'
p164
I16
sg50
g58
sa(dp165
g45
g56
sg35
g36
sg18
F1.1399287888164054
sS'task1.thisTrialN'
p166
I17
sg48
g58
sg17
I1
sg16
S'up'
p167
sg27
g31
sg49
g65
sg46
g56
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p168
I31
sg25
g26
sS'task1.thisRepN'
p169
I0
sS'task1.thisN'
p170
I17
sg50
g60
sa(dp171
g45
g65
sg35
g36
sg18
F0.95121562347321742
sS'task1.thisTrialN'
p172
I18
sg48
g60
sg17
I1
sg16
S'up'
p173
sg27
g31
sg49
g58
sg46
g65
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p174
I28
sg25
g26
sS'task1.thisRepN'
p175
I0
sS'task1.thisN'
p176
I18
sg50
g56
sa(dp177
g45
g58
sg35
g36
sg18
F1.4910594644500179
sS'task1.thisTrialN'
p178
I19
sg48
g60
sg17
I1
sg16
S'up'
p179
sg27
g31
sg49
g65
sg46
g58
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p180
I26
sg25
g26
sS'task1.thisRepN'
p181
I0
sS'task1.thisN'
p182
I19
sg50
g56
sa(dp183
g45
g60
sg35
g36
sg18
F1.0289531622377126
sS'task1.thisTrialN'
p184
I20
sg48
g58
sg17
I1
sg16
S'down'
p185
sg27
g31
sg49
g65
sg46
g58
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p186
I2
sg25
g26
sS'task1.thisRepN'
p187
I0
sS'task1.thisN'
p188
I20
sg50
g56
sa(dp189
g45
g56
sg35
g36
sg18
F1.4006605913561998
sS'task1.thisTrialN'
p190
I21
sg48
g58
sg17
I1
sg16
S'right'
p191
sg27
g31
sg49
g60
sg46
g65
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p192
I40
sg25
g26
sS'task1.thisRepN'
p193
I0
sS'task1.thisN'
p194
I21
sg50
g65
sa(dp195
g45
g65
sg35
g36
sg18
F0.86907253833328468
sS'task1.thisTrialN'
p196
I22
sg48
g60
sg17
I1
sg16
S'left'
p197
sg27
g31
sg49
g56
sg46
g56
sg32
g11
sg33
g34
sg47
g101
sS'task1.thisIndex'
p198
I18
sg25
g26
sS'task1.thisRepN'
p199
I0
sS'task1.thisN'
p200
I22
sg50
g58
sa(dp201
g45
g58
sg35
g36
sg18
F0.90117178615332705
sS'task1.thisTrialN'
p202
I23
sg48
g60
sg17
I1
sg16
S'right'
p203
sg27
g31
sg49
g65
sg46
g56
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p204
I44
sg25
g26
sS'task1.thisRepN'
p205
I0
sS'task1.thisN'
p206
I23
sg50
g56
sa(dp207
g45
g60
sg35
g36
sg18
F2.4371923327516924
sS'task1.thisTrialN'
p208
I24
sg48
g58
sg17
I0
sg16
S'up'
p209
sg27
g31
sg49
g65
sg46
g65
sg32
g11
sg33
g34
sg47
g101
sS'task1.thisIndex'
p210
I15
sg25
g26
sS'task1.thisRepN'
p211
I0
sS'task1.thisN'
p212
I24
sg50
g56
sa(dp213
g45
g56
sg35
g36
sg18
F1.2874043975905352
sS'task1.thisTrialN'
p214
I25
sg48
g65
sg17
I0
sg16
S'right'
p215
sg27
g31
sg49
g60
sg46
g60
sg32
g11
sg33
g34
sg47
g101
sS'task1.thisIndex'
p216
I22
sg25
g26
sS'task1.thisRepN'
p217
I0
sS'task1.thisN'
p218
I25
sg50
g58
sa(dp219
g45
g58
sg35
g36
sg18
F1.2690392392935337
sS'task1.thisTrialN'
p220
I26
sg48
g56
sg17
I1
sg16
S'up'
p221
sg27
g31
sg49
g60
sg46
g58
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p222
I24
sg25
g26
sS'task1.thisRepN'
p223
I0
sS'task1.thisN'
p224
I26
sg50
g65
sa(dp225
g45
g65
sg35
g36
sg18
F1.8011748979135973
sS'task1.thisTrialN'
p226
I27
sg48
g58
sg17
I1
sg16
S'left'
p227
sg27
g31
sg49
g60
sg46
g60
sg32
g11
sg33
g34
sg47
g101
sS'task1.thisIndex'
p228
I21
sg25
g26
sS'task1.thisRepN'
p229
I0
sS'task1.thisN'
p230
I27
sg50
g56
sa(dp231
g45
g58
sg35
g36
sg18
F1.0101167487432576
sS'task1.thisTrialN'
p232
I28
sg48
g65
sg17
I1
sg16
S'up'
p233
sg27
g31
sg49
g56
sg46
g58
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p234
I25
sg25
g26
sS'task1.thisRepN'
p235
I0
sS'task1.thisN'
p236
I28
sg50
g60
sa(dp237
g45
g56
sg35
g36
sg18
F1.127002794488817
sS'task1.thisTrialN'
p238
I29
sg48
g60
sg17
I1
sg16
S'up'
p239
sg27
g31
sg49
g58
sg46
g56
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p240
I30
sg25
g26
sS'task1.thisRepN'
p241
I0
sS'task1.thisN'
p242
I29
sg50
g65
sa(dp243
g45
g56
sg35
g36
sg18
F2.6921709081238987
sS'task1.thisTrialN'
p244
I30
sg48
g60
sg17
I0
sg16
S'right'
p245
sg27
g31
sg49
g65
sg46
g60
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p246
I11
sg25
g26
sS'task1.thisRepN'
p247
I0
sS'task1.thisN'
p248
I30
sg50
g58
sa(dp249
g45
g60
sg35
g36
sg18
F2.0383493941851611
sS'task1.thisTrialN'
p250
I31
sg48
g65
sg17
I0
sg16
S'down'
p251
sg27
g31
sg49
g58
sg46
g58
sg32
g11
sg33
g34
sg47
g101
sS'task1.thisIndex'
p252
I13
sg25
g26
sS'task1.thisRepN'
p253
I0
sS'task1.thisN'
p254
I31
sg50
g56
sa(dp255
g45
g60
sg35
g36
sg18
F1.1753893790178154
sS'task1.thisTrialN'
p256
I32
sg48
g56
sg17
I1
sg16
S'right'
p257
sg27
g31
sg49
g65
sg46
g58
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p258
I37
sg25
g26
sS'task1.thisRepN'
p259
I0
sS'task1.thisN'
p260
I32
sg50
g58
sa(dp261
g45
g60
sg35
g36
sg18
F1.2178203115802262
sS'task1.thisTrialN'
p262
I33
sg48
g56
sg17
I1
sg16
S'right'
p263
sg27
g31
sg49
g58
sg46
g65
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p264
I39
sg25
g26
sS'task1.thisRepN'
p265
I0
sS'task1.thisN'
p266
I33
sg50
g65
sa(dp267
g45
g65
sg35
g36
sg18
F1.844562776870589
sS'task1.thisTrialN'
p268
I34
sg48
g58
sg17
I1
sg16
S'right'
p269
sg27
g31
sg49
g60
sg46
g56
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p270
I42
sg25
g26
sS'task1.thisRepN'
p271
I0
sS'task1.thisN'
p272
I34
sg50
g56
sa(dp273
g45
g58
sg35
g36
sg18
F1.2256228091366665
sS'task1.thisTrialN'
p274
I35
sg48
g65
sg17
I1
sg16
S'left'
p275
sg27
g31
sg49
g56
sg46
g56
sg32
g11
sg33
g34
sg47
g101
sS'task1.thisIndex'
p276
I20
sg25
g26
sS'task1.thisRepN'
p277
I0
sS'task1.thisN'
p278
I35
sg50
g60
sa(dp279
g45
g60
sg35
g36
sg18
F1.1699729918479989
sS'task1.thisTrialN'
p280
I36
sg48
g56
sg17
I1
sg16
S'up'
p281
sg27
g31
sg49
g65
sg46
g60
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p282
I35
sg25
g26
sS'task1.thisRepN'
p283
I0
sS'task1.thisN'
p284
I36
sg50
g58
sa(dp285
g45
g58
sg35
g36
sg18
F1.0671055852242262
sS'task1.thisTrialN'
p286
I37
sg48
g56
sg17
I1
sg16
S'down'
p287
sg27
g31
sg49
g65
sg46
g56
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p288
I7
sg25
g26
sS'task1.thisRepN'
p289
I0
sS'task1.thisN'
p290
I37
sg50
g60
sa(dp291
g45
g65
sg35
g36
sg18
F0.81676128662616065
sS'task1.thisTrialN'
p292
I38
sg48
g56
sg17
I1
sg16
S'down'
p293
sg27
g31
sg49
g60
sg46
g56
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p294
I8
sg25
g26
sS'task1.thisRepN'
p295
I0
sS'task1.thisN'
p296
I38
sg50
g58
sa(dp297
g45
g65
sg35
g36
sg18
F1.0305632574288666
sS'task1.thisTrialN'
p298
I39
sg48
g56
sg17
I1
sg16
S'left'
p299
sg27
g31
sg49
g58
sg46
g58
sg32
g11
sg33
g34
sg47
g101
sS'task1.thisIndex'
p300
I12
sg25
g26
sS'task1.thisRepN'
p301
I0
sS'task1.thisN'
p302
I39
sg50
g60
sa(dp303
g45
g58
sg35
g36
sg18
F0.94783792029215874
sS'task1.thisTrialN'
p304
I40
sg48
g65
sg17
I1
sg16
S'down'
p305
sg27
g31
sg49
g56
sg46
g65
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p306
I3
sg25
g26
sS'task1.thisRepN'
p307
I0
sS'task1.thisN'
p308
I40
sg50
g60
sa(dp309
g45
g65
sg35
g36
sg18
F0.98169258570260354
sS'task1.thisTrialN'
p310
I41
sg48
g56
sg17
I1
sg16
S'right'
p311
sg27
g31
sg49
g58
sg46
g60
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p312
I45
sg25
g26
sS'task1.thisRepN'
p313
I0
sS'task1.thisN'
p314
I41
sg50
g60
sa(dp315
g45
g60
sg35
g36
sg18
F1.0604544388613704
sS'task1.thisTrialN'
p316
I42
sg48
g58
sg17
I1
sg16
S'left'
p317
sg27
g31
sg49
g56
sg46
g56
sg32
g11
sg33
g34
sg47
g101
sS'task1.thisIndex'
p318
I19
sg25
g26
sS'task1.thisRepN'
p319
I0
sS'task1.thisN'
p320
I42
sg50
g65
sa(dp321
g45
g65
sg35
g36
sg18
F0.88470480144565045
sS'task1.thisTrialN'
p322
I43
sg48
g60
sg17
I1
sg16
S'right'
p323
sg27
g31
sg49
g56
sg46
g58
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p324
I36
sg25
g26
sS'task1.thisRepN'
p325
I0
sS'task1.thisN'
p326
I43
sg50
g58
sa(dp327
g45
g58
sg35
g36
sg18
F0.99712595281607719
sS'task1.thisTrialN'
p328
I44
sg48
g60
sg17
I1
sg16
S'right'
p329
sg27
g31
sg49
g56
sg46
g65
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p330
I41
sg25
g26
sS'task1.thisRepN'
p331
I0
sS'task1.thisN'
p332
I44
sg50
g65
sa(dp333
g45
g58
sg35
g36
sg18
F1.0649677740361767
sS'task1.thisTrialN'
p334
I45
sg48
g65
sg17
I1
sg16
S'right'
p335
sg27
g31
sg49
g56
sg46
g60
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p336
I47
sg25
g26
sS'task1.thisRepN'
p337
I0
sS'task1.thisN'
p338
I45
sg50
g60
sa(dp339
g45
g56
sg35
g36
sg18
F3.0601131076632555
sS'task1.thisTrialN'
p340
I46
sg48
g65
sg17
I1
sg16
S'up'
p341
sg27
g31
sg49
g60
sg46
g56
sg32
g11
sg33
g34
sg47
g75
sS'task1.thisIndex'
p342
I32
sg25
g26
sS'task1.thisRepN'
p343
I0
sS'task1.thisN'
p344
I46
sg50
g58
sa(dp345
g45
g56
sg35
g36
sg18
F1.1060866346056173
sS'task1.thisTrialN'
p346
I47
sg48
g60
sg17
I1
sg16
S'left'
p347
sg27
g31
sg49
g65
sg46
g65
sg32
g11
sg33
g34
sg47
g101
sS'task1.thisIndex'
p348
I16
sg25
g26
sS'task1.thisRepN'
p349
I0
sS'task1.thisN'
p350
I47
sg50
g58
sa(dp351
g15
F14.790466273173479
sg32
g11
sg14
S'return'
p352
sg33
g34
sg25
g26
sg35
g36
sg27
g31
sa(dp353
S'task2.thisRepN'
p354
I0
sVdownbox
p355
Vred
p356
sg35
g36
sS'task2.thisIndex'
p357
I36
sg27
g31
sVrightbox
p358
Vyellow
p359
sg21
F0.98908317606128549
sVleftbox
p360
Vgreen
p361
sS'task2.thisN'
p362
I0
sVtargettest
p363
g361
sg32
g11
sg33
g34
sVcorrAns
p364
Vright
p365
sg19
S'right'
p366
sg25
g26
sVupbox
p367
Vblue
p368
sg20
I1
sS'task2.thisTrialN'
p369
I0
sa(dp370
S'task2.thisRepN'
p371
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p372
I20
sg27
g31
sg358
g359
sg21
F0.88680668303413768
sg360
g368
sS'task2.thisN'
p373
I1
sg363
g359
sg32
g11
sg33
g34
sg364
Vleft
p374
sg19
S'left'
p375
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p376
I1
sa(dp377
S'task2.thisRepN'
p378
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p379
I44
sg27
g31
sg358
g356
sg21
F1.0083792959530911
sg360
g359
sS'task2.thisN'
p380
I2
sg363
g359
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p381
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p382
I2
sa(dp383
S'task2.thisRepN'
p384
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p385
I41
sg27
g31
sg358
g359
sg21
F1.0459189909429369
sg360
g356
sS'task2.thisN'
p386
I3
sg363
g356
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p387
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p388
I3
sa(dp389
S'task2.thisRepN'
p390
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p391
I40
sg27
g31
sg358
g368
sg21
F1.1083521241930612
sg360
g356
sS'task2.thisN'
p392
I4
sg363
g356
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p393
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p394
I4
sa(dp395
S'task2.thisRepN'
p396
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p397
I8
sg27
g31
sg358
g368
sg21
F0.96119635301738526
sg360
g361
sS'task2.thisN'
p398
I5
sg363
g359
sg32
g11
sg33
g34
sg364
Vdown
p399
sg19
S'down'
p400
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p401
I5
sa(dp402
S'task2.thisRepN'
p403
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p404
I23
sg27
g31
sg358
g368
sg21
F2.838979252901936
sg360
g356
sS'task2.thisN'
p405
I6
sg363
g368
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p406
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p407
I6
sa(dp408
S'task2.thisRepN'
p409
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p410
I5
sg27
g31
sg358
g368
sg21
F0.94839258348929434
sg360
g361
sS'task2.thisN'
p411
I7
sg363
g356
sg32
g11
sg33
g34
sg364
g399
sg19
S'down'
p412
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p413
I7
sa(dp414
S'task2.thisRepN'
p415
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p416
I30
sg27
g31
sg358
g361
sg21
F1.2346562162861119
sg360
g356
sS'task2.thisN'
p417
I8
sg363
g359
sg32
g11
sg33
g34
sg364
Vup
p418
sg19
S'up'
p419
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p420
I8
sa(dp421
S'task2.thisRepN'
p422
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p423
I34
sg27
g31
sg358
g361
sg21
F0.82329213298999093
sg360
g359
sS'task2.thisN'
p424
I9
sg363
g368
sg32
g11
sg33
g34
sg364
g418
sg19
S'up'
p425
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p426
I9
sa(dp427
S'task2.thisRepN'
p428
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p429
I15
sg27
g31
sg358
g356
sg21
F1.0260143134541977
sg360
g359
sS'task2.thisN'
p430
I10
sg363
g356
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p431
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p432
I10
sa(dp433
S'task2.thisRepN'
p434
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p435
I39
sg27
g31
sg358
g361
sg21
F1.0319359606214675
sg360
g356
sS'task2.thisN'
p436
I11
sg363
g356
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p437
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p438
I11
sa(dp439
S'task2.thisRepN'
p440
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p441
I19
sg27
g31
sg358
g359
sg21
F0.81598110103050203
sg360
g356
sS'task2.thisN'
p442
I12
sg363
g359
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p443
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p444
I12
sa(dp445
S'task2.thisRepN'
p446
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p447
I24
sg27
g31
sg358
g368
sg21
F1.1924132725225718
sg360
g356
sS'task2.thisN'
p448
I13
sg363
g361
sg32
g11
sg33
g34
sg364
g418
sg19
S'up'
p449
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p450
I13
sa(dp451
S'task2.thisRepN'
p452
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p453
I46
sg27
g31
sg358
g356
sg21
F0.9284991340000488
sg360
g368
sS'task2.thisN'
p454
I14
sg363
g368
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p455
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p456
I14
sa(dp457
S'task2.thisRepN'
p458
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p459
I3
sg27
g31
sg358
g359
sg21
F1.4111145008978383
sg360
g368
sS'task2.thisN'
p460
I15
sg363
g356
sg32
g11
sg33
g34
sg364
g399
sg19
S'down'
p461
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p462
I15
sa(dp463
S'task2.thisRepN'
p464
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p465
I33
sg27
g31
sg358
g359
sg21
F0.97906266731706637
sg360
g356
sS'task2.thisN'
p466
I16
sg363
g368
sg32
g11
sg33
g34
sg364
g418
sg19
S'up'
p467
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p468
I16
sa(dp469
S'task2.thisRepN'
p470
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p471
I25
sg27
g31
sg358
g359
sg21
F1.1441453839929636
sg360
g368
sS'task2.thisN'
p472
I17
sg363
g361
sg32
g11
sg33
g34
sg364
g418
sg19
S'up'
p473
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p474
I17
sa(dp475
S'task2.thisRepN'
p476
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p477
I12
sg27
g31
sg358
g361
sg21
F0.81611455382972053
sg360
g368
sS'task2.thisN'
p478
I18
sg363
g361
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p479
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p480
I18
sa(dp481
S'task2.thisRepN'
p482
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p483
I18
sg27
g31
sg358
g359
sg21
F0.77292075887180545
sg360
g361
sS'task2.thisN'
p484
I19
sg363
g359
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p485
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p486
I19
sa(dp487
S'task2.thisRepN'
p488
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p489
I28
sg27
g31
sg358
g361
sg21
F0.89842285096892738
sg360
g359
sS'task2.thisN'
p490
I20
sg363
g356
sg32
g11
sg33
g34
sg364
g418
sg19
S'up'
p491
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p492
I20
sa(dp493
S'task2.thisRepN'
p494
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p495
I45
sg27
g31
sg358
g361
sg21
F0.9026631853453182
sg360
g368
sS'task2.thisN'
p496
I21
sg363
g368
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p497
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p498
I21
sa(dp499
S'task2.thisRepN'
p500
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p501
I11
sg27
g31
sg358
g356
sg21
F1.5307048906279306
sg360
g361
sS'task2.thisN'
p502
I22
sg363
g368
sg32
g11
sg33
g34
sg364
g399
sg19
S'down'
p503
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p504
I22
sa(dp505
S'task2.thisRepN'
p506
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p507
I27
sg27
g31
sg358
g359
sg21
F0.91009227170343365
sg360
g368
sS'task2.thisN'
p508
I23
sg363
g356
sg32
g11
sg33
g34
sg364
g418
sg19
S'up'
p509
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p510
I23
sa(dp511
S'task2.thisRepN'
p512
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p513
I31
sg27
g31
sg358
g356
sg21
F0.94987211308080077
sg360
g368
sS'task2.thisN'
p514
I24
sg363
g359
sg32
g11
sg33
g34
sg364
g418
sg19
S'up'
p515
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p516
I24
sa(dp517
S'task2.thisRepN'
p518
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p519
I37
sg27
g31
sg358
g356
sg21
F2.0516738221108426
sg360
g361
sS'task2.thisN'
p520
I25
sg363
g361
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p521
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p522
I25
sa(dp523
S'task2.thisRepN'
p524
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p525
I43
sg27
g31
sg358
g361
sg21
F2.056872706881677
sg360
g359
sS'task2.thisN'
p526
I26
sg363
g359
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p527
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p528
I26
sa(dp529
S'task2.thisRepN'
p530
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p531
I26
sg27
g31
sg358
g356
sg21
F1.047564374133799
sg360
g359
sS'task2.thisN'
p532
I27
sg363
g361
sg32
g11
sg33
g34
sg364
g418
sg19
S'up'
p533
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p534
I27
sa(dp535
S'task2.thisRepN'
p536
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p537
I7
sg27
g31
sg358
g356
sg21
F0.90213290294832404
sg360
g368
sS'task2.thisN'
p538
I28
sg363
g359
sg32
g11
sg33
g34
sg364
g399
sg19
S'down'
p539
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p540
I28
sa(dp541
S'task2.thisRepN'
p542
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p543
I13
sg27
g31
sg358
g361
sg21
F2.1631880718859975
sg360
g359
sS'task2.thisN'
p544
I29
sg363
g361
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p545
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p546
I29
sa(dp547
S'task2.thisRepN'
p548
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p549
I21
sg27
g31
sg358
g368
sg21
F2.1997243044816059
sg360
g359
sS'task2.thisN'
p550
I30
sg363
g368
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p551
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p552
I30
sa(dp553
S'task2.thisRepN'
p554
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p555
I4
sg27
g31
sg358
g361
sg21
F1.3327497981367742
sg360
g359
sS'task2.thisN'
p556
I31
sg363
g356
sg32
g11
sg33
g34
sg364
g399
sg19
S'up'
p557
sg25
g26
sg367
g356
sg20
I0
sS'task2.thisTrialN'
p558
I31
sa(dp559
S'task2.thisRepN'
p560
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p561
I47
sg27
g31
sg358
g359
sg21
F2.5202926850861331
sg360
g368
sS'task2.thisN'
p562
I32
sg363
g368
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p563
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p564
I32
sa(dp565
S'task2.thisRepN'
p566
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p567
I6
sg27
g31
sg358
g361
sg21
F0.80566706028866975
sg360
g356
sS'task2.thisN'
p568
I33
sg363
g359
sg32
g11
sg33
g34
sg364
g399
sg19
S'down'
p569
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p570
I33
sa(dp571
S'task2.thisRepN'
p572
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p573
I14
sg27
g31
sg358
g361
sg21
F0.59054499749299794
sg360
g356
sS'task2.thisN'
p574
I34
sg363
g361
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p575
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p576
I34
sa(dp577
S'task2.thisRepN'
p578
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p579
I29
sg27
g31
sg358
g368
sg21
F1.1432269335978162
sg360
g361
sS'task2.thisN'
p580
I35
sg363
g356
sg32
g11
sg33
g34
sg364
g418
sg19
S'up'
p581
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p582
I35
sa(dp583
S'task2.thisRepN'
p584
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p585
I1
sg27
g31
sg358
g359
sg21
F1.1985145676881075
sg360
g368
sS'task2.thisN'
p586
I36
sg363
g361
sg32
g11
sg33
g34
sg364
g399
sg19
S'down'
p587
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p588
I36
sa(dp589
S'task2.thisRepN'
p590
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p591
I35
sg27
g31
sg358
g356
sg21
F0.73682690947407536
sg360
g361
sS'task2.thisN'
p592
I37
sg363
g368
sg32
g11
sg33
g34
sg364
g418
sg19
S'up'
p593
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p594
I37
sa(dp595
S'task2.thisRepN'
p596
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p597
I0
sg27
g31
sg358
g368
sg21
F2.1502033711590229
sg360
g356
sS'task2.thisN'
p598
I38
sg363
g361
sg32
g11
sg33
g34
sg364
g399
sg19
S'right'
p599
sg25
g26
sg367
g361
sg20
I0
sS'task2.thisTrialN'
p600
I38
sa(dp601
S'task2.thisRepN'
p602
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p603
I42
sg27
g31
sg358
g368
sg21
F1.1867620597540736
sg360
g359
sS'task2.thisN'
p604
I39
sg363
g359
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p605
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p606
I39
sa(dp607
S'task2.thisRepN'
p608
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p609
I17
sg27
g31
sg358
g356
sg21
F1.3366609917143251
sg360
g368
sS'task2.thisN'
p610
I40
sg363
g356
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p611
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p612
I40
sa(dp613
S'task2.thisRepN'
p614
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p615
I38
sg27
g31
sg358
g368
sg21
F3.9700363177680629
sg360
g361
sS'task2.thisN'
p616
I41
sg363
g361
sg32
g11
sg33
g34
sg364
g365
sg19
S'left'
p617
sg25
g26
sg367
g356
sg20
I0
sS'task2.thisTrialN'
p618
I41
sa(dp619
S'task2.thisRepN'
p620
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p621
I16
sg27
g31
sg358
g356
sg21
F1.3178197662200546
sg360
g361
sS'task2.thisN'
p622
I42
sg363
g356
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p623
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p624
I42
sa(dp625
S'task2.thisRepN'
p626
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p627
I9
sg27
g31
sg358
g359
sg21
F0.94676933549817477
sg360
g356
sS'task2.thisN'
p628
I43
sg363
g368
sg32
g11
sg33
g34
sg364
g399
sg19
S'down'
p629
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p630
I43
sa(dp631
S'task2.thisRepN'
p632
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p633
I2
sg27
g31
sg358
g356
sg21
F1.2530656449830531
sg360
g359
sS'task2.thisN'
p634
I44
sg363
g361
sg32
g11
sg33
g34
sg364
g399
sg19
S'down'
p635
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p636
I44
sa(dp637
S'task2.thisRepN'
p638
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p639
I22
sg27
g31
sg358
g368
sg21
F1.7505709437969017
sg360
g361
sS'task2.thisN'
p640
I45
sg363
g368
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p641
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p642
I45
sa(dp643
S'task2.thisRepN'
p644
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p645
I10
sg27
g31
sg358
g361
sg21
F4.3412894940888691
sg360
g359
sS'task2.thisN'
p646
I46
sg363
g368
sg32
g11
sg33
g34
sg364
g399
sg19
S'down'
p647
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p648
I46
sa(dp649
S'task2.thisRepN'
p650
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p651
I32
sg27
g31
sg358
g368
sg21
F1.3022834223074824
sg360
g361
sS'task2.thisN'
p652
I47
sg363
g359
sg32
g11
sg33
g34
sg364
g418
sg19
S'up'
p653
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p654
I47
sasS'loops'
p655
(lp656
g1
(cpsychopy.data
TrialHandler
p657
g3
NtRp658
(dp659
S'origin'
p660
V\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a larger size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a#########start of task1########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'task1'\u000a\u000a # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()\u000a
p661
sS'thisTrial'
p662
(lp663
sS'_exp'
p664
L545746448L
sg10
S'task1'
p665
sg6
S'C:/Users/Eyetracking/Documents/adamant-squeegee/Brook/VWM_task/VWMtask_a.py'
p666
sS'thisRepN'
p667
I1
sg22
I01
sg23
g24
sS'data'
p668
g1
(cpsychopy.data
DataHandler
p669
c__builtin__
dict
p670
(dp671
S'ran'
p672
cnumpy.ma.core
_mareconstruct
p673
(cnumpy.ma.core
MaskedArray
p674
cnumpy
ndarray
p675
(I0
tp676
S'b'
tRp677
(I1
(L48L
L1L
tg29
(S'f4'
I0
I1
tRp678
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
g673
(g674
g675
g676
S'b'
tRp679
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg16
cnumpy.core.multiarray
_reconstruct
p680
(g675
(I0
tS'b'
tRp681
(I1
(L48L
L1L
tg29
(S'O8'
I0
I1
tRp682
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp683
g59
ag131
ag185
ag305
ag68
ag161
ag155
ag287
ag293
ag119
ag87
ag245
ag299
ag251
ag113
ag209
ag347
ag100
ag197
ag317
ag275
ag227
ag215
ag143
ag221
ag233
ag179
ag74
ag173
ag107
ag239
ag167
ag341
ag81
ag149
ag281
ag323
ag257
ag93
ag263
ag191
ag329
ag269
ag137
ag203
ag311
ag125
ag335
atbsg18
g673
(g674
g675
g676
S'b'
tRp684
(I1
(L48L
L1L
tg678
I00
S'\x85\xb2~?\xe6\x04\x90?\xbd\xb4\x83?\x82\xa5r?]o\x8b?=t\xdb?\xa8\xabE?\xea\x96\x88?E\x17Q?\xa7_\x8e?\x9b\xfbH@\x87L,@\x7f\xe9\x83?Qt\x02@\x1fG\x9e?\xf6\xfa\x1b@?\x94\x8d?@\xff\x9d?\x8a{^?\xf9\xbc\x87?5\xe1\x9c?\xe6\x8c\xe6?\xab\xc9\xa4?\xcah\xcb?\xe1o\xa2?\x81K\x81?\t\xdb\xbe?w_\x8e?\xde\x82s?\xba\xff\xdd?\xa1A\x90?0\xe9\x91?\xe5\xd8C@\xe6\xd4\x8b?z\xb2W?\xad\xc1\x95?\x04|b?)s\x96?S\xea\x13@\x89\xe1\x9b?\xd9H\xb3?\xa5C\x7f?\xa2\x1a\xec?\xbcV\xc9?2\xb3f?5P{?\xc4\xc96@\xddP\x88?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p685
g673
(g674
g675
g676
S'b'
tRp686
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x00\x00\x00\x000A\x00\x00\xa0A\x00\x00 B\x00\x00\x80?\x00\x00\x80A\x00\x00pA\x00\x00\x14B\x00\x00\x18B\x00\x00\x10A\x00\x00\x80@\x00\x00\xf0A\x00\x00\x1cB\x00\x00\xf8A\x00\x00\x00A\x00\x00\xc0A\x00\x00<B\x00\x00\xc0@\x00\x00\xb0A\x00\x00(B\x00\x00\x0cB\x00\x00\xd8A\x00\x00\xc8A\x00\x00PA\x00\x00\xd0A\x00\x00\xe0A\x00\x00\x98A\x00\x00\x00@\x00\x00\x90A\x00\x00\xe0@\x00\x00\xe8A\x00\x00\x88A\x00\x008B\x00\x00@@\x00\x00`A\x00\x00\x10B\x00\x00,B\x00\x00\x00B\x00\x00\xa0@\x00\x00\x04B\x00\x00\xa8A\x00\x000B\x00\x00\x08B\x00\x00@A\x00\x00\xb8A\x00\x00$B\x00\x00 A\x00\x004B'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp687
(dp688
S'isNumeric'
p689
(dp690
g672
I01
sg17
I01
sg16
I00
sg18
I01
sg685
I01
ssS'trials'
p691
g658
sS'dataTypes'
p692
(lp693
g672
ag685
ag16
ag17
ag18
asS'dataShape'
p694
(lp695
L48L
aI1
asbsS'method'
p696
S'fullRandom'
p697
sS'sequenceIndices'
p698
g680
(g675
(I0
tS'b'
tRp699
(I1
(L48L
L1L
tg682
I00
(lp700
I0
aI4
aI27
aI33
aI10
aI38
aI17
aI29
aI14
aI9
aI46
aI1
aI43
aI23
aI34
aI6
aI5
aI31
aI28
aI26
aI2
aI40
aI18
aI44
aI15
aI22
aI24
aI21
aI25
aI30
aI11
aI13
aI37
aI39
aI42
aI20
aI35
aI7
aI8
aI12
aI3
aI45
aI19
aI36
aI41
aI47
aI32
aI16
atbsS'finished'
p701
I01
sS'nReps'
p702
I1
sS'nRemaining'
p703
I-1
sS'trialList'
p704
(lp705
g1
(cpsychopy.data
TrialType
p706
g670
(dp707
g45
g56
sg46
g58
sg47
g61
sg48
g58
sg49
g60
sg50
g65
stRp708
ag1
(g706
g670
(dp709
g45
g65
sg46
g58
sg47
g61
sg48
g58
sg49
g56
sg50
g60
stRp710
ag1
(g706
g670
(dp711
g45
g60
sg46
g58
sg47
g61
sg48
g58
sg49
g65
sg50
g56
stRp712
ag1
(g706
g670
(dp713
g45
g58
sg46
g65
sg47
g61
sg48
g65
sg49
g56
sg50
g60
stRp714
ag1
(g706
g670
(dp715
g45
g60
sg46
g65
sg47
g61
sg48
g65
sg49
g58
sg50
g56
stRp716
ag1
(g706
g670
(dp717
g45
g56
sg46
g65
sg47
g61
sg48
g65
sg49
g60
sg50
g58
stRp718
ag1
(g706
g670
(dp719
g45
g60
sg46
g56
sg47
g61
sg48
g56
sg49
g58
sg50
g65
stRp720
ag1
(g706
g670
(dp721
g45
g58
sg46
g56
sg47
g61
sg48
g56
sg49
g65
sg50
g60
stRp722
ag1
(g706
g670
(dp723
g45
g65
sg46
g56
sg47
g61
sg48
g56
sg49
g60
sg50
g58
stRp724
ag1
(g706
g670
(dp725
g45
g58
sg46
g60
sg47
g61
sg48
g60
sg49
g56
sg50
g65
stRp726
ag1
(g706
g670
(dp727
g45
g65
sg46
g60
sg47
g61
sg48
g60
sg49
g58
sg50
g56
stRp728
ag1
(g706
g670
(dp729
g45
g56
sg46
g60
sg47
g61
sg48
g60
sg49
g65
sg50
g58
stRp730
ag1
(g706
g670
(dp731
g45
g65
sg46
g58
sg47
g101
sg48
g56
sg49
g58
sg50
g60
stRp732
ag1
(g706
g670
(dp733
g45
g60
sg46
g58
sg47
g101
sg48
g65
sg49
g58
sg50
g56
stRp734
ag1
(g706
g670
(dp735
g45
g56
sg46
g58
sg47
g101
sg48
g60
sg49
g58
sg50
g65
stRp736
ag1
(g706
g670
(dp737
g45
g60
sg46
g65
sg47
g101
sg48
g58
sg49
g65
sg50
g56
stRp738
ag1
(g706
g670
(dp739
g45
g56
sg46
g65
sg47
g101
sg48
g60
sg49
g65
sg50
g58
stRp740
ag1
(g706
g670
(dp741
g45
g58
sg46
g65
sg47
g101
sg48
g56
sg49
g65
sg50
g60
stRp742
ag1
(g706
g670
(dp743
g45
g65
sg46
g56
sg47
g101
sg48
g60
sg49
g56
sg50
g58
stRp744
ag1
(g706
g670
(dp745
g45
g60
sg46
g56
sg47
g101
sg48
g58
sg49
g56
sg50
g65
stRp746
ag1
(g706
g670
(dp747
g45
g58
sg46
g56
sg47
g101
sg48
g65
sg49
g56
sg50
g60
stRp748
ag1
(g706
g670
(dp749
g45
g65
sg46
g60
sg47
g101
sg48
g58
sg49
g60
sg50
g56
stRp750
ag1
(g706
g670
(dp751
g45
g56
sg46
g60
sg47
g101
sg48
g65
sg49
g60
sg50
g58
stRp752
ag1
(g706
g670
(dp753
g45
g58
sg46
g60
sg47
g101
sg48
g56
sg49
g60
sg50
g65
stRp754
ag1
(g706
g670
(dp755
g45
g58
sg46
g58
sg47
g75
sg48
g56
sg49
g60
sg50
g65
stRp756
ag1
(g706
g670
(dp757
g45
g58
sg46
g58
sg47
g75
sg48
g65
sg49
g56
sg50
g60
stRp758
ag1
(g706
g670
(dp759
g45
g58
sg46
g58
sg47
g75
sg48
g60
sg49
g65
sg50
g56
stRp760
ag1
(g706
g670
(dp761
g45
g65
sg46
g65
sg47
g75
sg48
g58
sg49
g56
sg50
g60
stRp762
ag1
(g706
g670
(dp763
g45
g65
sg46
g65
sg47
g75
sg48
g60
sg49
g58
sg50
g56
stRp764
ag1
(g706
g670
(dp765
g45
g65
sg46
g65
sg47
g75
sg48
g56
sg49
g60
sg50
g58
stRp766
ag1
(g706
g670
(dp767
g45
g56
sg46
g56
sg47
g75
sg48
g60
sg49
g58
sg50
g65
stRp768
ag1
(g706
g670
(dp769
g45
g56
sg46
g56
sg47
g75
sg48
g58
sg49
g65
sg50
g60
stRp770
ag1
(g706
g670
(dp771
g45
g56
sg46
g56
sg47
g75
sg48
g65
sg49
g60
sg50
g58
stRp772
ag1
(g706
g670
(dp773
g45
g60
sg46
g60
sg47
g75
sg48
g58
sg49
g56
sg50
g65
stRp774
ag1
(g706
g670
(dp775
g45
g60
sg46
g60
sg47
g75
sg48
g65
sg49
g58
sg50
g56
stRp776
ag1
(g706
g670
(dp777
g45
g60
sg46
g60
sg47
g75
sg48
g56
sg49
g65
sg50
g58
stRp778
ag1
(g706
g670
(dp779
g45
g65
sg46
g58
sg47
g94
sg48
g60
sg49
g56
sg50
g58
stRp780
ag1
(g706
g670
(dp781
g45
g60
sg46
g58
sg47
g94
sg48
g56
sg49
g65
sg50
g58
stRp782
ag1
(g706
g670
(dp783
g45
g56
sg46
g58
sg47
g94
sg48
g65
sg49
g60
sg50
g58
stRp784
ag1
(g706
g670
(dp785
g45
g60
sg46
g65
sg47
g94
sg48
g56
sg49
g58
sg50
g65
stRp786
ag1
(g706
g670
(dp787
g45
g56
sg46
g65
sg47
g94
sg48
g58
sg49
g60
sg50
g65
stRp788
ag1
(g706
g670
(dp789
g45
g58
sg46
g65
sg47
g94
sg48
g60
sg49
g56
sg50
g65
stRp790
ag1
(g706
g670
(dp791
g45
g65
sg46
g56
sg47
g94
sg48
g58
sg49
g60
sg50
g56
stRp792
ag1
(g706
g670
(dp793
g45
g60
sg46
g56
sg47
g94
sg48
g65
sg49
g58
sg50
g56
stRp794
ag1
(g706
g670
(dp795
g45
g58
sg46
g56
sg47
g94
sg48
g60
sg49
g65
sg50
g56
stRp796
ag1
(g706
g670
(dp797
g45
g65
sg46
g60
sg47
g94
sg48
g56
sg49
g58
sg50
g60
stRp798
ag1
(g706
g670
(dp799
g45
g56
sg46
g60
sg47
g94
sg48
g58
sg49
g65
sg50
g60
stRp800
ag1
(g706
g670
(dp801
g45
g58
sg46
g60
sg47
g94
sg48
g65
sg49
g56
sg50
g60
stRp802
asS'seed'
p803
NsS'thisIndex'
p804
I16
sS'thisN'
p805
I48
sS'thisTrialN'
p806
I0
sS'nTotal'
p807
I48
sS'_warnUseOfNext'
p808
I01
sbag1
(g657
g3
NtRp809
(dp810
g660
V\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a larger size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a#########start of task1########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'task1'\u000a\u000a # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()\u000a
p811
sg662
(lp812
sg664
L545746448L
sg10
S'task2'
p813
sg6
g666
sg667
I1
sg22
I01
sg23
g24
sg668
g1
(g669
g670
(dp814
g672
g673
(g674
g675
g676
S'b'
tRp815
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g673
(g674
g675
g676
S'b'
tRp816
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg685
g673
(g674
g675
g676
S'b'
tRp817
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x18B\x00\x00\x10B\x00\x000B\x00\x00pA\x00\x00\xf8A\x00\x00\xe0@\x00\x00\x04B\x00\x00\xe0A\x00\x00\xa0@\x00\x00,B\x00\x008B\x00\x00\xb0A\x00\x00\x90A\x00\x00\xe8A\x00\x00\x08B\x00\x00 A\x00\x00(B\x00\x00 B\x00\x00\x98A\x00\x00@A\x00\x00\x80?\x00\x00\xf0A\x00\x004B\x00\x00\xc0@\x00\x00PA\x00\x00\x88A\x00\x00\xd8A\x00\x00\xb8A\x00\x00\xa0A\x00\x00\x0cB\x00\x00\x00A\x00\x00\xc0A\x00\x00<B\x00\x00\x80A\x00\x00\x10A\x00\x00\x14B\x00\x00\x00\x00\x00\x00\xc8A\x00\x00$B\x00\x000A\x00\x00\x80@\x00\x00@@\x00\x00\x1cB\x00\x00\xd0A\x00\x00\x00@\x00\x00\xa8A\x00\x00`A\x00\x00\x00B'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g673
(g674
g675
g676
S'b'
tRp818
(I1
(L48L
L1L
tg678
I00
S'\xef\x9c\t@\xedh\x99?td\xa0?f\x9f\xb4?\x8c\x97\xaa?\xdb\xc9r?2@N?/\xf2f?\xf7\x10v?z_r?\xd8\xeb\x8a@#\xee\xc3?\xe2\xecP?\xacq\n@\xf5-\x17?pT\x83?Q\xae\xa8?\xb5\x17\xab?#\xdeE?#\xe4P?\xc3\x05c?H\xc8\x0c@\xb5\x12\xe0?\xd6\xb15@\x00\xa1\x98?[s\x92?\x97\x16\x86?\xcf\xfbh?\n\xffe?CU\x92?7\t\x9e?\xd2*s?9\xb1\xa6?\xda\xa3z?F\xc3R?\xb0\xa0<?\x8e4}?\xa0N\x03@\x13\x15~@z\x16\x84?{\xde\x8d?\xac\xe0\x85?\xd2\xe7\x97?\xcd\xa3\x03@\x93\x12\x81?\xef\x14g?\x1f\xb2m?zL!@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g680
(g675
(I0
tS'b'
tRp819
(I1
(L48L
L1L
tg682
I00
(lp820
g599
ag587
ag635
ag461
ag557
ag412
ag569
ag539
ag400
ag629
ag647
ag503
ag479
ag545
ag575
ag431
ag623
ag611
ag485
ag443
ag375
ag551
ag641
ag406
ag449
ag473
ag533
ag509
ag491
ag581
ag419
ag515
ag653
ag467
ag425
ag593
ag366
ag521
ag617
ag437
ag393
ag387
ag605
ag527
ag381
ag497
ag455
ag563
atbstRp821
(dp822
g689
(dp823
g672
I01
sg21
I01
sg20
I01
sg685
I01
sg19
I00
ssg691
g809
sg692
(lp824
g672
ag685
ag19
ag20
ag21
asg694
(lp825
L48L
aI1
asbsg696
g697
sg698
g680
(g675
(I0
tS'b'
tRp826
(I1
(L48L
L1L
tg682
I00
(lp827
I36
aI20
aI44
aI41
aI40
aI8
aI23
aI5
aI30
aI34
aI15
aI39
aI19
aI24
aI46
aI3
aI33
aI25
aI12
aI18
aI28
aI45
aI11
aI27
aI31
aI37
aI43
aI26
aI7
aI13
aI21
aI4
aI47
aI6
aI14
aI29
aI1
aI35
aI0
aI42
aI17
aI38
aI16
aI9
aI2
aI22
aI10
aI32
atbsg701
I01
sg702
I1
sg703
I-1
sg704
(lp828
g1
(g706
g670
(dp829
g355
g359
sg363
g361
sg364
g399
sg367
g361
sg358
g368
sg360
g356
stRp830
ag1
(g706
g670
(dp831
g355
g356
sg363
g361
sg364
g399
sg367
g361
sg358
g359
sg360
g368
stRp832
ag1
(g706
g670
(dp833
g355
g368
sg363
g361
sg364
g399
sg367
g361
sg358
g356
sg360
g359
stRp834
ag1
(g706
g670
(dp835
g355
g361
sg363
g356
sg364
g399
sg367
g356
sg358
g359
sg360
g368
stRp836
ag1
(g706
g670
(dp837
g355
g368
sg363
g356
sg364
g399
sg367
g356
sg358
g361
sg360
g359
stRp838
ag1
(g706
g670
(dp839
g355
g359
sg363
g356
sg364
g399
sg367
g356
sg358
g368
sg360
g361
stRp840
ag1
(g706
g670
(dp841
g355
g368
sg363
g359
sg364
g399
sg367
g359
sg358
g361
sg360
g356
stRp842
ag1
(g706
g670
(dp843
g355
g361
sg363
g359
sg364
g399
sg367
g359
sg358
g356
sg360
g368
stRp844
ag1
(g706
g670
(dp845
g355
g356
sg363
g359
sg364
g399
sg367
g359
sg358
g368
sg360
g361
stRp846
ag1
(g706
g670
(dp847
g355
g361
sg363
g368
sg364
g399
sg367
g368
sg358
g359
sg360
g356
stRp848
ag1
(g706
g670
(dp849
g355
g356
sg363
g368
sg364
g399
sg367
g368
sg358
g361
sg360
g359
stRp850
ag1
(g706
g670
(dp851
g355
g359
sg363
g368
sg364
g399
sg367
g368
sg358
g356
sg360
g361
stRp852
ag1
(g706
g670
(dp853
g355
g356
sg363
g361
sg364
g374
sg367
g359
sg358
g361
sg360
g368
stRp854
ag1
(g706
g670
(dp855
g355
g368
sg363
g361
sg364
g374
sg367
g356
sg358
g361
sg360
g359
stRp856
ag1
(g706
g670
(dp857
g355
g359
sg363
g361
sg364
g374
sg367
g368
sg358
g361
sg360
g356
stRp858
ag1
(g706
g670
(dp859
g355
g368
sg363
g356
sg364
g374
sg367
g361
sg358
g356
sg360
g359
stRp860
ag1
(g706
g670
(dp861
g355
g359
sg363
g356
sg364
g374
sg367
g368
sg358
g356
sg360
g361
stRp862
ag1
(g706
g670
(dp863
g355
g361
sg363
g356
sg364
g374
sg367
g359
sg358
g356
sg360
g368
stRp864
ag1
(g706
g670
(dp865
g355
g356
sg363
g359
sg364
g374
sg367
g368
sg358
g359
sg360
g361
stRp866
ag1
(g706
g670
(dp867
g355
g368
sg363
g359
sg364
g374
sg367
g361
sg358
g359
sg360
g356
stRp868
ag1
(g706
g670
(dp869
g355
g361
sg363
g359
sg364
g374
sg367
g356
sg358
g359
sg360
g368
stRp870
ag1
(g706
g670
(dp871
g355
g356
sg363
g368
sg364
g374
sg367
g361
sg358
g368
sg360
g359
stRp872
ag1
(g706
g670
(dp873
g355
g359
sg363
g368
sg364
g374
sg367
g356
sg358
g368
sg360
g361
stRp874
ag1
(g706
g670
(dp875
g355
g361
sg363
g368
sg364
g374
sg367
g359
sg358
g368
sg360
g356
stRp876
ag1
(g706
g670
(dp877
g355
g361
sg363
g361
sg364
g418
sg367
g359
sg358
g368
sg360
g356
stRp878
ag1
(g706
g670
(dp879
g355
g361
sg363
g361
sg364
g418
sg367
g356
sg358
g359
sg360
g368
stRp880
ag1
(g706
g670
(dp881
g355
g361
sg363
g361
sg364
g418
sg367
g368
sg358
g356
sg360
g359
stRp882
ag1
(g706
g670
(dp883
g355
g356
sg363
g356
sg364
g418
sg367
g361
sg358
g359
sg360
g368
stRp884
ag1
(g706
g670
(dp885
g355
g356
sg363
g356
sg364
g418
sg367
g368
sg358
g361
sg360
g359
stRp886
ag1
(g706
g670
(dp887
g355
g356
sg363
g356
sg364
g418
sg367
g359
sg358
g368
sg360
g361
stRp888
ag1
(g706
g670
(dp889
g355
g359
sg363
g359
sg364
g418
sg367
g368
sg358
g361
sg360
g356
stRp890
ag1
(g706
g670
(dp891
g355
g359
sg363
g359
sg364
g418
sg367
g361
sg358
g356
sg360
g368
stRp892
ag1
(g706
g670
(dp893
g355
g359
sg363
g359
sg364
g418
sg367
g356
sg358
g368
sg360
g361
stRp894
ag1
(g706
g670
(dp895
g355
g368
sg363
g368
sg364
g418
sg367
g361
sg358
g359
sg360
g356
stRp896
ag1
(g706
g670
(dp897
g355
g368
sg363
g368
sg364
g418
sg367
g356
sg358
g361
sg360
g359
stRp898
ag1
(g706
g670
(dp899
g355
g368
sg363
g368
sg364
g418
sg367
g359
sg358
g356
sg360
g361
stRp900
ag1
(g706
g670
(dp901
g355
g356
sg363
g361
sg364
g365
sg367
g368
sg358
g359
sg360
g361
stRp902
ag1
(g706
g670
(dp903
g355
g368
sg363
g361
sg364
g365
sg367
g359
sg358
g356
sg360
g361
stRp904
ag1
(g706
g670
(dp905
g355
g359
sg363
g361
sg364
g365
sg367
g356
sg358
g368
sg360
g361
stRp906
ag1
(g706
g670
(dp907
g355
g368
sg363
g356
sg364
g365
sg367
g359
sg358
g361
sg360
g356
stRp908
ag1
(g706
g670
(dp909
g355
g359
sg363
g356
sg364
g365
sg367
g361
sg358
g368
sg360
g356
stRp910
ag1
(g706
g670
(dp911
g355
g361
sg363
g356
sg364
g365
sg367
g368
sg358
g359
sg360
g356
stRp912
ag1
(g706
g670
(dp913
g355
g356
sg363
g359
sg364
g365
sg367
g361
sg358
g368
sg360
g359
stRp914
ag1
(g706
g670
(dp915
g355
g368
sg363
g359
sg364
g365
sg367
g356
sg358
g361
sg360
g359
stRp916
ag1
(g706
g670
(dp917
g355
g361
sg363
g359
sg364
g365
sg367
g368
sg358
g356
sg360
g359
stRp918
ag1
(g706
g670
(dp919
g355
g356
sg363
g368
sg364
g365
sg367
g359
sg358
g361
sg360
g368
stRp920
ag1
(g706
g670
(dp921
g355
g359
sg363
g368
sg364
g365
sg367
g361
sg358
g356
sg360
g368
stRp922
ag1
(g706
g670
(dp923
g355
g361
sg363
g368
sg364
g365
sg367
g356
sg358
g359
sg360
g368
stRp924
asg803
Nsg804
I32
sg805
I48
sg806
I0
sg807
I48
sg808
I01
sbasS'savePickle'
p925
I00
sb.