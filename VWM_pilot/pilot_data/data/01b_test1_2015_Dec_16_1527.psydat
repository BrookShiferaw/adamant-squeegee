ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cEyetracking\u005cDocuments\u005cadamant-squeegee\u005cBrook\u005cVWM_task\u005cdata/01b_test1_2015_Dec_16_1527
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'test1'
p11
sS'dataNames'
p12
(lp13
S'start.keys'
p14
aS'start.rt'
p15
aS'answer2.keys'
p16
aS'answer2.corr'
p17
aS'answer2.rt'
p18
aS'answer1.keys'
p19
aS'answer1.corr'
p20
aS'answer1.rt'
p21
asS'autoLog'
p22
I01
sS'extraInfo'
p23
(dp24
S'date'
p25
V2015_Dec_16_1527
p26
sS'frameRate'
p27
cnumpy.core.multiarray
scalar
p28
(cnumpy
dtype
p29
(S'f8'
I0
I1
tRp30
(I3
S'<'
NNNI-1
I-1
I0
tbS'+E~\x93r\xc0q@'
tRp31
sS'expName'
p32
g11
sS'session'
p33
V001
p34
sS'participant'
p35
V01b
p36
ssS'loopsUnfinished'
p37
(lp38
sS'saveWideText'
p39
I01
sS'thisEntry'
p40
(dp41
sS'version'
p42
S''
sS'_paramNamesSoFar'
p43
(lp44
Vdownbox
p45
aVtargettest
p46
aVcorrAns
p47
aVupbox
p48
aVrightbox
p49
aVleftbox
p50
asS'entries'
p51
(lp52
(dp53
g15
F6.0286365326392115
sg32
g11
sg14
S'return'
p54
sg33
g34
sg25
g26
sg35
g36
sg27
g31
sa(dp55
g33
g34
sg35
g36
sg27
g31
sg18
F0.81652838582886034
sg15
F5.1924386157224944
sg32
g11
sg14
S'return'
p56
sg16
S'left'
p57
sg25
g26
sg17
I1
sa(dp58
g45
Vgreen
p59
sg35
g36
sg21
F0.94132696352971834
sS'task1.thisTrialN'
p60
I0
sg48
Vyellow
p61
sg20
I1
sg19
S'left'
p62
sg27
g31
sg49
Vred
p63
sg46
g63
sg32
g11
sg33
g34
sg47
Vleft
p64
sS'task1.thisIndex'
p65
I17
sg25
g26
sS'task1.thisRepN'
p66
I0
sS'task1.thisN'
p67
I0
sg50
Vblue
p68
sa(dp69
g45
g63
sg35
g36
sg21
F1.0963593370615854
sS'task1.thisTrialN'
p70
I1
sg48
g61
sg20
I1
sg19
S'down'
p71
sg27
g31
sg49
g68
sg46
g61
sg32
g11
sg33
g34
sg47
Vdown
p72
sS'task1.thisIndex'
p73
I8
sg25
g26
sS'task1.thisRepN'
p74
I0
sS'task1.thisN'
p75
I1
sg50
g59
sa(dp76
g45
g61
sg35
g36
sg21
F1.0436737117561279
sS'task1.thisTrialN'
p77
I2
sg48
g59
sg20
I1
sg19
S'up'
p78
sg27
g31
sg49
g63
sg46
g61
sg32
g11
sg33
g34
sg47
Vup
p79
sS'task1.thisIndex'
p80
I31
sg25
g26
sS'task1.thisRepN'
p81
I0
sS'task1.thisN'
p82
I2
sg50
g68
sa(dp83
g45
g68
sg35
g36
sg21
F0.92029403244669084
sS'task1.thisTrialN'
p84
I3
sg48
g61
sg20
I1
sg19
S'down'
p85
sg27
g31
sg49
g59
sg46
g61
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p86
I6
sg25
g26
sS'task1.thisRepN'
p87
I0
sS'task1.thisN'
p88
I3
sg50
g63
sa(dp89
g45
g61
sg35
g36
sg21
F0.67690307381053572
sS'task1.thisTrialN'
p90
I4
sg48
g63
sg20
I1
sg19
S'down'
p91
sg27
g31
sg49
g68
sg46
g63
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p92
I5
sg25
g26
sS'task1.thisRepN'
p93
I0
sS'task1.thisN'
p94
I4
sg50
g59
sa(dp95
g45
g59
sg35
g36
sg21
F1.1423312600018107
sS'task1.thisTrialN'
p96
I5
sg48
g61
sg20
I0
sg19
S'up'
p97
sg27
g31
sg49
g68
sg46
g68
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p98
I23
sg25
g26
sS'task1.thisRepN'
p99
I0
sS'task1.thisN'
p100
I5
sg50
g63
sa(dp101
g45
g59
sg35
g36
sg21
F1.2700026016900665
sS'task1.thisTrialN'
p102
I6
sg48
g61
sg20
I1
sg19
S'up'
p103
sg27
g31
sg49
g68
sg46
g59
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p104
I24
sg25
g26
sS'task1.thisRepN'
p105
I0
sS'task1.thisN'
p106
I6
sg50
g63
sa(dp107
g45
g68
sg35
g36
sg21
F0.76165297973784618
sS'task1.thisTrialN'
p108
I7
sg48
g63
sg20
I1
sg19
S'right'
p109
sg27
g31
sg49
g59
sg46
g61
sg32
g11
sg33
g34
sg47
Vright
p110
sS'task1.thisIndex'
p111
I43
sg25
g26
sS'task1.thisRepN'
p112
I0
sS'task1.thisN'
p113
I7
sg50
g61
sa(dp114
g45
g68
sg35
g36
sg21
F1.1339644752479217
sS'task1.thisTrialN'
p115
I8
sg48
g63
sg20
I0
sg19
S'up'
p116
sg27
g31
sg49
g59
sg46
g59
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p117
I13
sg25
g26
sS'task1.thisRepN'
p118
I0
sS'task1.thisN'
p119
I8
sg50
g61
sa(dp120
g45
g63
sg35
g36
sg21
F0.72679709752992494
sS'task1.thisTrialN'
p121
I9
sg48
g59
sg20
I1
sg19
S'left'
p122
sg27
g31
sg49
g68
sg46
g68
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p123
I21
sg25
g26
sS'task1.thisRepN'
p124
I0
sS'task1.thisN'
p125
I9
sg50
g61
sa(dp126
g45
g68
sg35
g36
sg21
F1.2832035216124495
sS'task1.thisTrialN'
p127
I10
sg48
g63
sg20
I0
sg19
S'left'
p128
sg27
g31
sg49
g59
sg46
g68
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p129
I34
sg25
g26
sS'task1.thisRepN'
p130
I0
sS'task1.thisN'
p131
I10
sg50
g61
sa(dp132
g45
g59
sg35
g36
sg21
F0.61304398456923082
sS'task1.thisTrialN'
p133
I11
sg48
g63
sg20
I1
sg19
S'left'
p134
sg27
g31
sg49
g61
sg46
g61
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p135
I20
sg25
g26
sS'task1.thisRepN'
p136
I0
sS'task1.thisN'
p137
I11
sg50
g68
sa(dp138
g45
g63
sg35
g36
sg21
F0.85359618402071646
sS'task1.thisTrialN'
p139
I12
sg48
g68
sg20
I1
sg19
S'up'
p140
sg27
g31
sg49
g59
sg46
g63
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p141
I28
sg25
g26
sS'task1.thisRepN'
p142
I0
sS'task1.thisN'
p143
I12
sg50
g61
sa(dp144
g45
g63
sg35
g36
sg21
F0.91809430685680127
sS'task1.thisTrialN'
p145
I13
sg48
g68
sg20
I1
sg19
S'down'
p146
sg27
g31
sg49
g59
sg46
g68
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p147
I10
sg25
g26
sS'task1.thisRepN'
p148
I0
sS'task1.thisN'
p149
I13
sg50
g61
sa(dp150
g45
g61
sg35
g36
sg21
F0.8722670647148334
sS'task1.thisTrialN'
p151
I14
sg48
g68
sg20
I1
sg19
S'down'
p152
sg27
g31
sg49
g63
sg46
g68
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p153
I11
sg25
g26
sS'task1.thisRepN'
p154
I0
sS'task1.thisN'
p155
I14
sg50
g59
sa(dp156
g45
g68
sg35
g36
sg21
F0.86852140393602895
sS'task1.thisTrialN'
p157
I15
sg48
g63
sg20
I1
sg19
S'down'
p158
sg27
g31
sg49
g59
sg46
g63
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p159
I4
sg25
g26
sS'task1.thisRepN'
p160
I0
sS'task1.thisN'
p161
I15
sg50
g61
sa(dp162
g45
g61
sg35
g36
sg21
F1.0785036091583606
sS'task1.thisTrialN'
p163
I16
sg48
g63
sg20
I0
sg19
S'left'
p164
sg27
g31
sg49
g68
sg46
g61
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p165
I32
sg25
g26
sS'task1.thisRepN'
p166
I0
sS'task1.thisN'
p167
I16
sg50
g59
sa(dp168
g45
g68
sg35
g36
sg21
F0.7739986468659481
sS'task1.thisTrialN'
p169
I17
sg48
g59
sg20
I1
sg19
S'left'
p170
sg27
g31
sg49
g61
sg46
g61
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p171
I19
sg25
g26
sS'task1.thisRepN'
p172
I0
sS'task1.thisN'
p173
I17
sg50
g63
sa(dp174
g45
g68
sg35
g36
sg21
F0.62743956368649378
sS'task1.thisTrialN'
p175
I18
sg48
g61
sg20
I1
sg19
S'right'
p176
sg27
g31
sg49
g59
sg46
g63
sg32
g11
sg33
g34
sg47
g110
sS'task1.thisIndex'
p177
I39
sg25
g26
sS'task1.thisRepN'
p178
I0
sS'task1.thisN'
p179
I18
sg50
g63
sa(dp180
g45
g63
sg35
g36
sg21
F0.70906872722844128
sS'task1.thisTrialN'
p181
I19
sg48
g68
sg20
I1
sg19
S'left'
p182
sg27
g31
sg49
g61
sg46
g61
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p183
I18
sg25
g26
sS'task1.thisRepN'
p184
I0
sS'task1.thisN'
p185
I19
sg50
g59
sa(dp186
g45
g61
sg35
g36
sg21
F0.83626143531364505
sS'task1.thisTrialN'
p187
I20
sg48
g59
sg20
I1
sg19
S'down'
p188
sg27
g31
sg49
g68
sg46
g59
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p189
I0
sg25
g26
sS'task1.thisRepN'
p190
I0
sS'task1.thisN'
p191
I20
sg50
g63
sa(dp192
g45
g61
sg35
g36
sg21
F1.1923879293244681
sS'task1.thisTrialN'
p193
I21
sg48
g63
sg20
I1
sg19
S'left'
p194
sg27
g31
sg49
g68
sg46
g68
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p195
I22
sg25
g26
sS'task1.thisRepN'
p196
I0
sS'task1.thisN'
p197
I21
sg50
g59
sa(dp198
g45
g63
sg35
g36
sg21
F0.66058237390097929
sS'task1.thisTrialN'
p199
I22
sg48
g61
sg20
I1
sg19
S'up'
p200
sg27
g31
sg49
g68
sg46
g63
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p201
I29
sg25
g26
sS'task1.thisRepN'
p202
I0
sS'task1.thisN'
p203
I22
sg50
g59
sa(dp204
g45
g68
sg35
g36
sg21
F1.0316815662226873
sS'task1.thisTrialN'
p205
I23
sg48
g59
sg20
I1
sg19
S'down'
p206
sg27
g31
sg49
g63
sg46
g59
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p207
I2
sg25
g26
sS'task1.thisRepN'
p208
I0
sS'task1.thisN'
p209
I23
sg50
g61
sa(dp210
g45
g59
sg35
g36
sg21
F0.76992320368663059
sS'task1.thisTrialN'
p211
I24
sg48
g68
sg20
I1
sg19
S'right'
p212
sg27
g31
sg49
g63
sg46
g61
sg32
g11
sg33
g34
sg47
g110
sS'task1.thisIndex'
p213
I44
sg25
g26
sS'task1.thisRepN'
p214
I0
sS'task1.thisN'
p215
I24
sg50
g61
sa(dp216
g45
g68
sg35
g36
sg21
F0.5162631163111655
sS'task1.thisTrialN'
p217
I25
sg48
g59
sg20
I1
sg19
S'left'
p218
sg27
g31
sg49
g63
sg46
g63
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p219
I15
sg25
g26
sS'task1.thisRepN'
p220
I0
sS'task1.thisN'
p221
I25
sg50
g61
sa(dp222
g45
g59
sg35
g36
sg21
F1.0288466566380521
sS'task1.thisTrialN'
p223
I26
sg48
g61
sg20
I1
sg19
S'down'
p224
sg27
g31
sg49
g63
sg46
g61
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p225
I7
sg25
g26
sS'task1.thisRepN'
p226
I0
sS'task1.thisN'
p227
I26
sg50
g68
sa(dp228
g45
g63
sg35
g36
sg21
F0.4693496453728585
sS'task1.thisTrialN'
p229
I27
sg48
g68
sg20
I1
sg19
S'right'
p230
sg27
g31
sg49
g61
sg46
g59
sg32
g11
sg33
g34
sg47
g110
sS'task1.thisIndex'
p231
I36
sg25
g26
sS'task1.thisRepN'
p232
I0
sS'task1.thisN'
p233
I27
sg50
g59
sa(dp234
g45
g68
sg35
g36
sg21
F0.93279657077800948
sS'task1.thisTrialN'
p235
I28
sg48
g61
sg20
I1
sg19
S'up'
p236
sg27
g31
sg49
g63
sg46
g68
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p237
I35
sg25
g26
sS'task1.thisRepN'
p238
I0
sS'task1.thisN'
p239
I28
sg50
g59
sa(dp240
g45
g61
sg35
g36
sg21
F1.3681417371371936
sS'task1.thisTrialN'
p241
I29
sg48
g68
sg20
I1
sg19
S'left'
p242
sg27
g31
sg49
g59
sg46
g59
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p243
I14
sg25
g26
sS'task1.thisRepN'
p244
I0
sS'task1.thisN'
p245
I29
sg50
g63
sa(dp246
g45
g63
sg35
g36
sg21
F1.0464085317398713
sS'task1.thisTrialN'
p247
I30
sg48
g61
sg20
I1
sg19
S'left'
p248
sg27
g31
sg49
g59
sg46
g59
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p249
I12
sg25
g26
sS'task1.thisRepN'
p250
I0
sS'task1.thisN'
p251
I30
sg50
g68
sa(dp252
g45
g59
sg35
g36
sg21
F0.55176990171094076
sS'task1.thisTrialN'
p253
I31
sg48
g68
sg20
I1
sg19
S'right'
p254
sg27
g31
sg49
g61
sg46
g63
sg32
g11
sg33
g34
sg47
g110
sS'task1.thisIndex'
p255
I41
sg25
g26
sS'task1.thisRepN'
p256
I0
sS'task1.thisN'
p257
I31
sg50
g63
sa(dp258
g45
g63
sg35
g36
sg21
F0.65855555951202405
sS'task1.thisTrialN'
p259
I32
sg48
g59
sg20
I1
sg19
S'right'
p260
sg27
g31
sg49
g68
sg46
g61
sg32
g11
sg33
g34
sg47
g110
sS'task1.thisIndex'
p261
I42
sg25
g26
sS'task1.thisRepN'
p262
I0
sS'task1.thisN'
p263
I32
sg50
g61
sa(dp264
g45
g61
sg35
g36
sg21
F1.2386238706640142
sS'task1.thisTrialN'
p265
I33
sg48
g63
sg20
I1
sg19
S'right'
p266
sg27
g31
sg49
g68
sg46
g59
sg32
g11
sg33
g34
sg47
g110
sS'task1.thisIndex'
p267
I38
sg25
g26
sS'task1.thisRepN'
p268
I0
sS'task1.thisN'
p269
I33
sg50
g59
sa(dp270
g45
g68
sg35
g36
sg21
F0.79174851076822961
sS'task1.thisTrialN'
p271
I34
sg48
g59
sg20
I1
sg19
S'up'
p272
sg27
g31
sg49
g61
sg46
g68
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p273
I33
sg25
g26
sS'task1.thisRepN'
p274
I0
sS'task1.thisN'
p275
I34
sg50
g63
sa(dp276
g45
g59
sg35
g36
sg21
F0.59204762468289118
sS'task1.thisTrialN'
p277
I35
sg48
g63
sg20
I1
sg19
S'right'
p278
sg27
g31
sg49
g61
sg46
g68
sg32
g11
sg33
g34
sg47
g110
sS'task1.thisIndex'
p279
I47
sg25
g26
sS'task1.thisRepN'
p280
I0
sS'task1.thisN'
p281
I35
sg50
g68
sa(dp282
g45
g61
sg35
g36
sg21
F1.0973955210574786
sS'task1.thisTrialN'
p283
I36
sg48
g68
sg20
I0
sg19
S'right'
p284
sg27
g31
sg49
g63
sg46
g63
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p285
I16
sg25
g26
sS'task1.thisRepN'
p286
I0
sS'task1.thisN'
p287
I36
sg50
g59
sa(dp288
g45
g61
sg35
g36
sg21
F0.43476034796549357
sS'task1.thisTrialN'
p289
I37
sg48
g68
sg20
I1
sg19
S'up'
p290
sg27
g31
sg49
g59
sg46
g61
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p291
I30
sg25
g26
sS'task1.thisRepN'
p292
I0
sS'task1.thisN'
p293
I37
sg50
g63
sa(dp294
g45
g61
sg35
g36
sg21
F0.6633149482877343
sS'task1.thisTrialN'
p295
I38
sg48
g59
sg20
I0
sg19
S'left'
p296
sg27
g31
sg49
g68
sg46
g63
sg32
g11
sg33
g34
sg47
g110
sS'task1.thisIndex'
p297
I40
sg25
g26
sS'task1.thisRepN'
p298
I0
sS'task1.thisN'
p299
I38
sg50
g63
sa(dp300
g45
g63
sg35
g36
sg21
F0.48438714529038407
sS'task1.thisTrialN'
p301
I39
sg48
g61
sg20
I1
sg19
S'right'
p302
sg27
g31
sg49
g59
sg46
g68
sg32
g11
sg33
g34
sg47
g110
sS'task1.thisIndex'
p303
I45
sg25
g26
sS'task1.thisRepN'
p304
I0
sS'task1.thisN'
p305
I39
sg50
g68
sa(dp306
g45
g63
sg35
g36
sg21
F1.1108277377788909
sS'task1.thisTrialN'
p307
I40
sg48
g59
sg20
I0
sg19
S'left'
p308
sg27
g31
sg49
g61
sg46
g59
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p309
I1
sg25
g26
sS'task1.thisRepN'
p310
I0
sS'task1.thisN'
p311
I40
sg50
g68
sa(dp312
g45
g59
sg35
g36
sg21
F0.91704144126561005
sS'task1.thisTrialN'
p313
I41
sg48
g68
sg20
I1
sg19
S'down'
p314
sg27
g31
sg49
g61
sg46
g68
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p315
I9
sg25
g26
sS'task1.thisRepN'
p316
I0
sS'task1.thisN'
p317
I41
sg50
g63
sa(dp318
g45
g59
sg35
g36
sg21
F1.0740518675847852
sS'task1.thisTrialN'
p319
I42
sg48
g68
sg20
I1
sg19
S'up'
p320
sg27
g31
sg49
g63
sg46
g59
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p321
I26
sg25
g26
sS'task1.thisRepN'
p322
I0
sS'task1.thisN'
p323
I42
sg50
g61
sa(dp324
g45
g59
sg35
g36
sg21
F1.335047367723746
sS'task1.thisTrialN'
p325
I43
sg48
g63
sg20
I0
sg19
S'left'
p326
sg27
g31
sg49
g61
sg46
g59
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p327
I25
sg25
g26
sS'task1.thisRepN'
p328
I0
sS'task1.thisN'
p329
I43
sg50
g68
sa(dp330
g45
g59
sg35
g36
sg21
F1.2866675199948077
sS'task1.thisTrialN'
p331
I44
sg48
g63
sg20
I1
sg19
S'down'
p332
sg27
g31
sg49
g61
sg46
g63
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p333
I3
sg25
g26
sS'task1.thisRepN'
p334
I0
sS'task1.thisN'
p335
I44
sg50
g68
sa(dp336
g45
g63
sg35
g36
sg21
F1.1273543912866444
sS'task1.thisTrialN'
p337
I45
sg48
g59
sg20
I0
sg19
S'down'
p338
sg27
g31
sg49
g61
sg46
g63
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p339
I27
sg25
g26
sS'task1.thisRepN'
p340
I0
sS'task1.thisN'
p341
I45
sg50
g68
sa(dp342
g45
g68
sg35
g36
sg21
F0.7854271468022489
sS'task1.thisTrialN'
p343
I46
sg48
g61
sg20
I1
sg19
S'right'
p344
sg27
g31
sg49
g63
sg46
g59
sg32
g11
sg33
g34
sg47
g110
sS'task1.thisIndex'
p345
I37
sg25
g26
sS'task1.thisRepN'
p346
I0
sS'task1.thisN'
p347
I46
sg50
g59
sa(dp348
g45
g61
sg35
g36
sg21
F1.0164275263086893
sS'task1.thisTrialN'
p349
I47
sg48
g59
sg20
I1
sg19
S'right'
p350
sg27
g31
sg49
g63
sg46
g68
sg32
g11
sg33
g34
sg47
g110
sS'task1.thisIndex'
p351
I46
sg25
g26
sS'task1.thisRepN'
p352
I0
sS'task1.thisN'
p353
I47
sg50
g68
sasS'loops'
p354
(lp355
g1
(cpsychopy.data
TrialHandler
p356
g3
NtRp357
(dp358
S'origin'
p359
Vfrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a smaller size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()
p360
sS'thisTrial'
p361
(lp362
sS'_exp'
p363
L471034960L
sg10
S'task2'
p364
sg6
S'C:/Users/Eyetracking/Documents/adamant-squeegee/Brook/VWM_task/VWMtask_b.py'
p365
sS'thisRepN'
p366
I1
sg22
I01
sg23
g24
sS'data'
p367
g1
(cpsychopy.data
DataHandler
p368
c__builtin__
dict
p369
(dp370
S'ran'
p371
cnumpy.ma.core
_mareconstruct
p372
(cnumpy.ma.core
MaskedArray
p373
cnumpy
ndarray
p374
(I0
tp375
S'b'
tRp376
(I1
(L48L
L1L
tg29
(S'f4'
I0
I1
tRp377
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
g372
(g373
g374
g375
S'b'
tRp378
(I1
(L48L
L1L
tg377
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p379
g372
(g373
g374
g375
S'b'
tRp380
(I1
(L48L
L1L
tg377
I00
S'\x00\x00\x08B\x00\x00\xb8A\x00\x00\xf0A\x00\x00\x98A\x00\x00,B\x00\x00\xa0@\x00\x00\x80A\x00\x00\xd8A\x00\x00\x80@\x00\x00\x80?\x00\x00@A\x00\x000A\x00\x00\xe0@\x00\x00\x10B\x00\x00<B\x00\x00\xd0A\x00\x00\xe0A\x00\x00\xf8A\x00\x00\x10A\x00\x00\xc8A\x00\x00\x88A\x00\x00\xa8A\x00\x00pA\x00\x00PA\x00\x008B\x00\x00\x1cB\x00\x00\xe8A\x00\x00\x04B\x00\x00`A\x00\x00\x00@\x00\x00 B\x00\x00\x0cB\x00\x00\xb0A\x00\x00\x00A\x00\x00$B\x00\x00\xc0A\x00\x00@@\x00\x004B\x00\x00\xa0A\x00\x00\x18B\x00\x00\x14B\x00\x00\xc0@\x00\x00\x90A\x00\x00\x00\x00\x00\x00 A\x00\x00(B\x00\x00\x00B\x00\x000B'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg18
g372
(g373
g374
g375
S'b'
tRp381
(I1
(L48L
L1L
tg377
I00
S'\x00\xbc\xd7?\xc8\xde ?\x07\xbf0?\xc7x\xa4? \x08\xa2?\xc9tJ?\xd68\xb9?\x1a\x80\x15?,\xcc\xbe?%# ?Mf\x98?y2V?\xaa\xb59?\xff\xa5\xbd?\x01\x08Q?7\x92\xc7>\x02|\xdf>q\xc6E?Q\x1a@?B\xdaf?\x8b\xa3\x17?\xd3>A?^\xa0V?\x95`-?c\x03R?\xe3\xd2\x8d?\xde\x8e\x96?\xa8\xb1\xa0?\xc7p\xb6?H\x9d\x9c?\xda/c?\x8c\x80w?\xae\xf9\x91?C0\xa6?nqw?\xf3\xc5Z?\xe8\xdb@?\xd5\xe4\xdb?0<J?y\xcc\xa0?\xb9@\x1b?GX\x81?u\xb2\x89?\xd5\xf3[?\xd5\x1fo?}((?\xe0+\xa8?\x7f\xddZ?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg16
cnumpy.core.multiarray
_reconstruct
p382
(g374
(I0
tS'b'
tRp383
(I1
(L48L
L1L
tg29
(S'O8'
I0
I1
tRp384
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp385
S'down'
p386
aS'down'
p387
aS'down'
p388
aS'down'
p389
aS'up'
p390
aS'down'
p391
aS'down'
p392
aS'down'
p393
aS'down'
p394
aS'down'
p395
aS'down'
p396
aS'down'
p397
aS'left'
p398
aS'down'
p399
ag57
aS'left'
p400
aS'left'
p401
aS'left'
p402
aS'left'
p403
aS'left'
p404
aS'left'
p405
aS'left'
p406
aS'left'
p407
aS'left'
p408
aS'left'
p409
aS'up'
p410
aS'up'
p411
aS'up'
p412
aS'up'
p413
aS'up'
p414
aS'up'
p415
aS'up'
p416
aS'up'
p417
aS'right'
p418
aS'up'
p419
aS'up'
p420
aS'right'
p421
aS'right'
p422
aS'right'
p423
aS'right'
p424
aS'right'
p425
aS'right'
p426
aS'right'
p427
aS'right'
p428
aS'right'
p429
aS'right'
p430
aS'right'
p431
aS'right'
p432
atbstRp433
(dp434
S'isNumeric'
p435
(dp436
g371
I01
sg18
I01
sg17
I01
sg379
I01
sg16
I00
ssS'trials'
p437
g357
sS'dataTypes'
p438
(lp439
g371
ag379
ag16
ag17
ag18
asS'dataShape'
p440
(lp441
L48L
aI1
asbsS'method'
p442
S'fullRandom'
p443
sS'sequenceIndices'
p444
g382
(g374
(I0
tS'b'
tRp445
(I1
(L48L
L1L
tg384
I00
(lp446
I43
aI9
aI29
aI36
aI8
aI5
aI41
aI12
aI33
aI18
aI44
aI11
aI10
aI23
aI28
aI22
aI6
aI20
aI42
aI3
aI38
aI21
aI32
aI1
aI35
aI19
aI15
aI7
aI16
aI26
aI2
aI17
aI46
aI27
aI0
aI31
aI13
aI40
aI39
aI25
aI30
aI34
aI45
aI4
aI47
aI37
aI24
aI14
atbsS'finished'
p447
I01
sS'nReps'
p448
I1
sS'nRemaining'
p449
I-1
sS'trialList'
p450
(lp451
g1
(cpsychopy.data
TrialType
p452
g369
(dp453
Vdownbox
p454
Vyellow
p455
sVtargettest
p456
Vgreen
p457
sVcorrAns
p458
Vdown
p459
sVupbox
p460
g457
sVrightbox
p461
Vblue
p462
sVleftbox
p463
Vred
p464
stRp465
ag1
(g452
g369
(dp466
g454
g464
sg456
g457
sg458
g459
sg460
g457
sg461
g455
sg463
g462
stRp467
ag1
(g452
g369
(dp468
g454
g462
sg456
g457
sg458
g459
sg460
g457
sg461
g464
sg463
g455
stRp469
ag1
(g452
g369
(dp470
g454
g457
sg456
g464
sg458
g459
sg460
g464
sg461
g455
sg463
g462
stRp471
ag1
(g452
g369
(dp472
g454
g462
sg456
g464
sg458
g459
sg460
g464
sg461
g457
sg463
g455
stRp473
ag1
(g452
g369
(dp474
g454
g455
sg456
g464
sg458
g459
sg460
g464
sg461
g462
sg463
g457
stRp475
ag1
(g452
g369
(dp476
g454
g462
sg456
g455
sg458
g459
sg460
g455
sg461
g457
sg463
g464
stRp477
ag1
(g452
g369
(dp478
g454
g457
sg456
g455
sg458
g459
sg460
g455
sg461
g464
sg463
g462
stRp479
ag1
(g452
g369
(dp480
g454
g464
sg456
g455
sg458
g459
sg460
g455
sg461
g462
sg463
g457
stRp481
ag1
(g452
g369
(dp482
g454
g457
sg456
g462
sg458
g459
sg460
g462
sg461
g455
sg463
g464
stRp483
ag1
(g452
g369
(dp484
g454
g464
sg456
g462
sg458
g459
sg460
g462
sg461
g457
sg463
g455
stRp485
ag1
(g452
g369
(dp486
g454
g455
sg456
g462
sg458
g459
sg460
g462
sg461
g464
sg463
g457
stRp487
ag1
(g452
g369
(dp488
g454
g464
sg456
g457
sg458
Vleft
p489
sg460
g455
sg461
g457
sg463
g462
stRp490
ag1
(g452
g369
(dp491
g454
g462
sg456
g457
sg458
g489
sg460
g464
sg461
g457
sg463
g455
stRp492
ag1
(g452
g369
(dp493
g454
g455
sg456
g457
sg458
g489
sg460
g462
sg461
g457
sg463
g464
stRp494
ag1
(g452
g369
(dp495
g454
g462
sg456
g464
sg458
g489
sg460
g457
sg461
g464
sg463
g455
stRp496
ag1
(g452
g369
(dp497
g454
g455
sg456
g464
sg458
g489
sg460
g462
sg461
g464
sg463
g457
stRp498
ag1
(g452
g369
(dp499
g454
g457
sg456
g464
sg458
g489
sg460
g455
sg461
g464
sg463
g462
stRp500
ag1
(g452
g369
(dp501
g454
g464
sg456
g455
sg458
g489
sg460
g462
sg461
g455
sg463
g457
stRp502
ag1
(g452
g369
(dp503
g454
g462
sg456
g455
sg458
g489
sg460
g457
sg461
g455
sg463
g464
stRp504
ag1
(g452
g369
(dp505
g454
g457
sg456
g455
sg458
g489
sg460
g464
sg461
g455
sg463
g462
stRp506
ag1
(g452
g369
(dp507
g454
g464
sg456
g462
sg458
g489
sg460
g457
sg461
g462
sg463
g455
stRp508
ag1
(g452
g369
(dp509
g454
g455
sg456
g462
sg458
g489
sg460
g464
sg461
g462
sg463
g457
stRp510
ag1
(g452
g369
(dp511
g454
g457
sg456
g462
sg458
g489
sg460
g455
sg461
g462
sg463
g464
stRp512
ag1
(g452
g369
(dp513
g454
g457
sg456
g457
sg458
Vup
p514
sg460
g455
sg461
g462
sg463
g464
stRp515
ag1
(g452
g369
(dp516
g454
g457
sg456
g457
sg458
g514
sg460
g464
sg461
g455
sg463
g462
stRp517
ag1
(g452
g369
(dp518
g454
g457
sg456
g457
sg458
g514
sg460
g462
sg461
g464
sg463
g455
stRp519
ag1
(g452
g369
(dp520
g454
g464
sg456
g464
sg458
g514
sg460
g457
sg461
g455
sg463
g462
stRp521
ag1
(g452
g369
(dp522
g454
g464
sg456
g464
sg458
g514
sg460
g462
sg461
g457
sg463
g455
stRp523
ag1
(g452
g369
(dp524
g454
g464
sg456
g464
sg458
g514
sg460
g455
sg461
g462
sg463
g457
stRp525
ag1
(g452
g369
(dp526
g454
g455
sg456
g455
sg458
g514
sg460
g462
sg461
g457
sg463
g464
stRp527
ag1
(g452
g369
(dp528
g454
g455
sg456
g455
sg458
g514
sg460
g457
sg461
g464
sg463
g462
stRp529
ag1
(g452
g369
(dp530
g454
g455
sg456
g455
sg458
g514
sg460
g464
sg461
g462
sg463
g457
stRp531
ag1
(g452
g369
(dp532
g454
g462
sg456
g462
sg458
g514
sg460
g457
sg461
g455
sg463
g464
stRp533
ag1
(g452
g369
(dp534
g454
g462
sg456
g462
sg458
g514
sg460
g464
sg461
g457
sg463
g455
stRp535
ag1
(g452
g369
(dp536
g454
g462
sg456
g462
sg458
g514
sg460
g455
sg461
g464
sg463
g457
stRp537
ag1
(g452
g369
(dp538
g454
g464
sg456
g457
sg458
Vright
p539
sg460
g462
sg461
g455
sg463
g457
stRp540
ag1
(g452
g369
(dp541
g454
g462
sg456
g457
sg458
g539
sg460
g455
sg461
g464
sg463
g457
stRp542
ag1
(g452
g369
(dp543
g454
g455
sg456
g457
sg458
g539
sg460
g464
sg461
g462
sg463
g457
stRp544
ag1
(g452
g369
(dp545
g454
g462
sg456
g464
sg458
g539
sg460
g455
sg461
g457
sg463
g464
stRp546
ag1
(g452
g369
(dp547
g454
g455
sg456
g464
sg458
g539
sg460
g457
sg461
g462
sg463
g464
stRp548
ag1
(g452
g369
(dp549
g454
g457
sg456
g464
sg458
g539
sg460
g462
sg461
g455
sg463
g464
stRp550
ag1
(g452
g369
(dp551
g454
g464
sg456
g455
sg458
g539
sg460
g457
sg461
g462
sg463
g455
stRp552
ag1
(g452
g369
(dp553
g454
g462
sg456
g455
sg458
g539
sg460
g464
sg461
g457
sg463
g455
stRp554
ag1
(g452
g369
(dp555
g454
g457
sg456
g455
sg458
g539
sg460
g462
sg461
g464
sg463
g455
stRp556
ag1
(g452
g369
(dp557
g454
g464
sg456
g462
sg458
g539
sg460
g455
sg461
g457
sg463
g462
stRp558
ag1
(g452
g369
(dp559
g454
g455
sg456
g462
sg458
g539
sg460
g457
sg461
g464
sg463
g462
stRp560
ag1
(g452
g369
(dp561
g454
g457
sg456
g462
sg458
g539
sg460
g464
sg461
g455
sg463
g462
stRp562
asS'seed'
p563
NsS'thisIndex'
p564
I14
sS'thisN'
p565
I48
sS'thisTrialN'
p566
I0
sS'nTotal'
p567
I48
sS'_warnUseOfNext'
p568
I01
sbag1
(g356
g3
NtRp569
(dp570
g359
Vfrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a smaller size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()
p571
sg361
(lp572
sg363
L471034960L
sg10
S'task1'
p573
sg6
g365
sg366
I1
sg22
I01
sg23
g24
sg367
g1
(g368
g369
(dp574
g371
g372
(g373
g374
g375
S'b'
tRp575
(I1
(L48L
L1L
tg377
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g372
(g373
g374
g375
S'b'
tRp576
(I1
(L48L
L1L
tg377
I00
S'\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g382
(g374
(I0
tS'b'
tRp577
(I1
(L48L
L1L
tg384
I00
(lp578
g188
ag308
ag206
ag332
ag158
ag91
ag85
ag224
ag71
ag314
ag146
ag152
ag248
ag116
ag242
ag218
ag284
ag62
ag182
ag170
ag134
ag122
ag194
ag97
ag103
ag326
ag320
ag338
ag140
ag200
ag290
ag78
ag164
ag272
ag128
ag236
ag230
ag344
ag266
ag176
ag296
ag254
ag260
ag109
ag212
ag302
ag350
ag278
atbsg21
g372
(g373
g374
g375
S'b'
tRp579
(I1
(L48L
L1L
tg377
I00
S';\x15V?\x9a/\x8e?$\x0e\x84?\x85\xb1\xa4?kW^?\x85I-?d\x98k??\xb1\x83?\x81U\x8c?:\xc3j?:\x08k?\xe5L_?\xb7\xf0\x85?\xbf%\x91?E\x1f\xaf?\xd2)\x04?uw\x8c?\xce\xfap?\x87\x855?\xc6$F?s\xf0\x1c?`\x0f:?+\xa0\x98?\xe97\x92?r\x8f\xa2?\xd5\xe2\xaa?\x88z\x89?&M\x90?H\x85Z?\xed\x1b)?\xe9\x98\xde>\x1a\x97\x85?h\x0c\x8a?\x08\xb0J?\x03@\xa4?\xc2\xcbn?\x99N\xf0>\xc1\x11I?:\x8b\x9e?\xe1\x9f ?\x02\xcf)?\xcb@\r?\x19\x97(?\xb1\xfbB?\xb0\x19E?\x98\x01\xf8>L\x1a\x82?o\x90\x17?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg379
g372
(g373
g374
g375
S'b'
tRp580
(I1
(L48L
L1L
tg377
I00
S'\x00\x00\xa0A\x00\x00 B\x00\x00\xb8A\x00\x000B\x00\x00pA\x00\x00\x80@\x00\x00@@\x00\x00\xd0A\x00\x00\x80?\x00\x00$B\x00\x00PA\x00\x00`A\x00\x00\xf0A\x00\x00\x00A\x00\x00\xe8A\x00\x00\xc8A\x00\x00\x10B\x00\x00\x00\x00\x00\x00\x98A\x00\x00\x88A\x00\x000A\x00\x00\x10A\x00\x00\xa8A\x00\x00\xa0@\x00\x00\xc0@\x00\x00,B\x00\x00(B\x00\x004B\x00\x00@A\x00\x00\xb0A\x00\x00\x14B\x00\x00\x00@\x00\x00\x80A\x00\x00\x08B\x00\x00 A\x00\x00\xe0A\x00\x00\xd8A\x00\x008B\x00\x00\x04B\x00\x00\x90A\x00\x00\x18B\x00\x00\xf8A\x00\x00\x00B\x00\x00\xe0@\x00\x00\xc0A\x00\x00\x1cB\x00\x00<B\x00\x00\x0cB'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp581
(dp582
g435
(dp583
g371
I01
sg20
I01
sg19
I00
sg21
I01
sg379
I01
ssg437
g569
sg438
(lp584
g371
ag379
ag19
ag20
ag21
asg440
(lp585
L48L
aI1
asbsg442
g443
sg444
g382
(g374
(I0
tS'b'
tRp586
(I1
(L48L
L1L
tg384
I00
(lp587
I17
aI8
aI31
aI6
aI5
aI23
aI24
aI43
aI13
aI21
aI34
aI20
aI28
aI10
aI11
aI4
aI32
aI19
aI39
aI18
aI0
aI22
aI29
aI2
aI44
aI15
aI7
aI36
aI35
aI14
aI12
aI41
aI42
aI38
aI33
aI47
aI16
aI30
aI40
aI45
aI1
aI9
aI26
aI25
aI3
aI27
aI37
aI46
atbsg447
I01
sg448
I1
sg449
I-1
sg450
(lp588
g1
(g452
g369
(dp589
g45
g61
sg46
g59
sg47
g72
sg48
g59
sg49
g68
sg50
g63
stRp590
ag1
(g452
g369
(dp591
g45
g63
sg46
g59
sg47
g72
sg48
g59
sg49
g61
sg50
g68
stRp592
ag1
(g452
g369
(dp593
g45
g68
sg46
g59
sg47
g72
sg48
g59
sg49
g63
sg50
g61
stRp594
ag1
(g452
g369
(dp595
g45
g59
sg46
g63
sg47
g72
sg48
g63
sg49
g61
sg50
g68
stRp596
ag1
(g452
g369
(dp597
g45
g68
sg46
g63
sg47
g72
sg48
g63
sg49
g59
sg50
g61
stRp598
ag1
(g452
g369
(dp599
g45
g61
sg46
g63
sg47
g72
sg48
g63
sg49
g68
sg50
g59
stRp600
ag1
(g452
g369
(dp601
g45
g68
sg46
g61
sg47
g72
sg48
g61
sg49
g59
sg50
g63
stRp602
ag1
(g452
g369
(dp603
g45
g59
sg46
g61
sg47
g72
sg48
g61
sg49
g63
sg50
g68
stRp604
ag1
(g452
g369
(dp605
g45
g63
sg46
g61
sg47
g72
sg48
g61
sg49
g68
sg50
g59
stRp606
ag1
(g452
g369
(dp607
g45
g59
sg46
g68
sg47
g72
sg48
g68
sg49
g61
sg50
g63
stRp608
ag1
(g452
g369
(dp609
g45
g63
sg46
g68
sg47
g72
sg48
g68
sg49
g59
sg50
g61
stRp610
ag1
(g452
g369
(dp611
g45
g61
sg46
g68
sg47
g72
sg48
g68
sg49
g63
sg50
g59
stRp612
ag1
(g452
g369
(dp613
g45
g63
sg46
g59
sg47
g64
sg48
g61
sg49
g59
sg50
g68
stRp614
ag1
(g452
g369
(dp615
g45
g68
sg46
g59
sg47
g64
sg48
g63
sg49
g59
sg50
g61
stRp616
ag1
(g452
g369
(dp617
g45
g61
sg46
g59
sg47
g64
sg48
g68
sg49
g59
sg50
g63
stRp618
ag1
(g452
g369
(dp619
g45
g68
sg46
g63
sg47
g64
sg48
g59
sg49
g63
sg50
g61
stRp620
ag1
(g452
g369
(dp621
g45
g61
sg46
g63
sg47
g64
sg48
g68
sg49
g63
sg50
g59
stRp622
ag1
(g452
g369
(dp623
g45
g59
sg46
g63
sg47
g64
sg48
g61
sg49
g63
sg50
g68
stRp624
ag1
(g452
g369
(dp625
g45
g63
sg46
g61
sg47
g64
sg48
g68
sg49
g61
sg50
g59
stRp626
ag1
(g452
g369
(dp627
g45
g68
sg46
g61
sg47
g64
sg48
g59
sg49
g61
sg50
g63
stRp628
ag1
(g452
g369
(dp629
g45
g59
sg46
g61
sg47
g64
sg48
g63
sg49
g61
sg50
g68
stRp630
ag1
(g452
g369
(dp631
g45
g63
sg46
g68
sg47
g64
sg48
g59
sg49
g68
sg50
g61
stRp632
ag1
(g452
g369
(dp633
g45
g61
sg46
g68
sg47
g64
sg48
g63
sg49
g68
sg50
g59
stRp634
ag1
(g452
g369
(dp635
g45
g59
sg46
g68
sg47
g64
sg48
g61
sg49
g68
sg50
g63
stRp636
ag1
(g452
g369
(dp637
g45
g59
sg46
g59
sg47
g79
sg48
g61
sg49
g68
sg50
g63
stRp638
ag1
(g452
g369
(dp639
g45
g59
sg46
g59
sg47
g79
sg48
g63
sg49
g61
sg50
g68
stRp640
ag1
(g452
g369
(dp641
g45
g59
sg46
g59
sg47
g79
sg48
g68
sg49
g63
sg50
g61
stRp642
ag1
(g452
g369
(dp643
g45
g63
sg46
g63
sg47
g79
sg48
g59
sg49
g61
sg50
g68
stRp644
ag1
(g452
g369
(dp645
g45
g63
sg46
g63
sg47
g79
sg48
g68
sg49
g59
sg50
g61
stRp646
ag1
(g452
g369
(dp647
g45
g63
sg46
g63
sg47
g79
sg48
g61
sg49
g68
sg50
g59
stRp648
ag1
(g452
g369
(dp649
g45
g61
sg46
g61
sg47
g79
sg48
g68
sg49
g59
sg50
g63
stRp650
ag1
(g452
g369
(dp651
g45
g61
sg46
g61
sg47
g79
sg48
g59
sg49
g63
sg50
g68
stRp652
ag1
(g452
g369
(dp653
g45
g61
sg46
g61
sg47
g79
sg48
g63
sg49
g68
sg50
g59
stRp654
ag1
(g452
g369
(dp655
g45
g68
sg46
g68
sg47
g79
sg48
g59
sg49
g61
sg50
g63
stRp656
ag1
(g452
g369
(dp657
g45
g68
sg46
g68
sg47
g79
sg48
g63
sg49
g59
sg50
g61
stRp658
ag1
(g452
g369
(dp659
g45
g68
sg46
g68
sg47
g79
sg48
g61
sg49
g63
sg50
g59
stRp660
ag1
(g452
g369
(dp661
g45
g63
sg46
g59
sg47
g110
sg48
g68
sg49
g61
sg50
g59
stRp662
ag1
(g452
g369
(dp663
g45
g68
sg46
g59
sg47
g110
sg48
g61
sg49
g63
sg50
g59
stRp664
ag1
(g452
g369
(dp665
g45
g61
sg46
g59
sg47
g110
sg48
g63
sg49
g68
sg50
g59
stRp666
ag1
(g452
g369
(dp667
g45
g68
sg46
g63
sg47
g110
sg48
g61
sg49
g59
sg50
g63
stRp668
ag1
(g452
g369
(dp669
g45
g61
sg46
g63
sg47
g110
sg48
g59
sg49
g68
sg50
g63
stRp670
ag1
(g452
g369
(dp671
g45
g59
sg46
g63
sg47
g110
sg48
g68
sg49
g61
sg50
g63
stRp672
ag1
(g452
g369
(dp673
g45
g63
sg46
g61
sg47
g110
sg48
g59
sg49
g68
sg50
g61
stRp674
ag1
(g452
g369
(dp675
g45
g68
sg46
g61
sg47
g110
sg48
g63
sg49
g59
sg50
g61
stRp676
ag1
(g452
g369
(dp677
g45
g59
sg46
g61
sg47
g110
sg48
g68
sg49
g63
sg50
g61
stRp678
ag1
(g452
g369
(dp679
g45
g63
sg46
g68
sg47
g110
sg48
g61
sg49
g59
sg50
g68
stRp680
ag1
(g452
g369
(dp681
g45
g61
sg46
g68
sg47
g110
sg48
g59
sg49
g63
sg50
g68
stRp682
ag1
(g452
g369
(dp683
g45
g59
sg46
g68
sg47
g110
sg48
g63
sg49
g61
sg50
g68
stRp684
asg563
Nsg564
I46
sg565
I48
sg566
I0
sg567
I48
sg568
I01
sbasS'savePickle'
p685
I00
sb.