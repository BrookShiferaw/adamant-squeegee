ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cEyetracking\u005cDocuments\u005cadamant-squeegee\u005cBrook\u005cVWM_task\u005cdata/03_test1_2015_Dec_17_1413
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'test1'
p11
sS'dataNames'
p12
(lp13
S'start.keys'
p14
aS'start.rt'
p15
aS'answer1.keys'
p16
aS'answer1.corr'
p17
aS'answer1.rt'
p18
aS'answer2.keys'
p19
aS'answer2.corr'
p20
aS'answer2.rt'
p21
asS'autoLog'
p22
I01
sS'extraInfo'
p23
(dp24
S'date'
p25
V2015_Dec_17_1413
p26
sS'frameRate'
p27
cnumpy.core.multiarray
scalar
p28
(cnumpy
dtype
p29
(S'f8'
I0
I1
tRp30
(I3
S'<'
NNNI-1
I-1
I0
tbS'Ij\xc4S\xf5\xcfq@'
tRp31
sS'expName'
p32
g11
sS'session'
p33
V01
p34
sS'participant'
p35
V03
p36
ssS'loopsUnfinished'
p37
(lp38
sS'saveWideText'
p39
I01
sS'thisEntry'
p40
(dp41
sS'version'
p42
S''
sS'_paramNamesSoFar'
p43
(lp44
Vdownbox
p45
aVtargettest
p46
aVcorrAns
p47
aVupbox
p48
aVrightbox
p49
aVleftbox
p50
asS'entries'
p51
(lp52
(dp53
g15
F9.5258515932173395
sg32
g11
sg14
S'return'
p54
sg33
g34
sg25
g26
sg35
g36
sg27
g31
sa(dp55
g45
Vred
p56
sg35
g36
sg18
F0.78527346196096914
sS'task1.thisTrialN'
p57
I0
sg48
Vblue
p58
sg17
I1
sg16
S'left'
p59
sg27
g31
sg49
Vyellow
p60
sg46
g60
sg32
g11
sg33
g34
sg47
Vleft
p61
sS'task1.thisIndex'
p62
I18
sg25
g26
sS'task1.thisRepN'
p63
I0
sS'task1.thisN'
p64
I0
sg50
Vgreen
p65
sa(dp66
g45
g58
sg35
g36
sg18
F0.48615367045476887
sS'task1.thisTrialN'
p67
I1
sg48
g60
sg17
I1
sg16
S'right'
p68
sg27
g31
sg49
g65
sg46
g56
sg32
g11
sg33
g34
sg47
Vright
p69
sS'task1.thisIndex'
p70
I39
sg25
g26
sS'task1.thisRepN'
p71
I0
sS'task1.thisN'
p72
I1
sg50
g56
sa(dp73
g45
g58
sg35
g36
sg18
F1.0469479817893443
sS'task1.thisTrialN'
p74
I2
sg48
g56
sg17
I0
sg16
S'up'
p75
sg27
g31
sg49
g65
sg46
g65
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p76
I13
sg25
g26
sS'task1.thisRepN'
p77
I0
sS'task1.thisN'
p78
I2
sg50
g60
sa(dp79
g45
g65
sg35
g36
sg18
F0.5772586821067307
sS'task1.thisTrialN'
p80
I3
sg48
g56
sg17
I1
sg16
S'right'
p81
sg27
g31
sg49
g60
sg46
g58
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p82
I47
sg25
g26
sS'task1.thisRepN'
p83
I0
sS'task1.thisN'
p84
I3
sg50
g58
sa(dp85
g45
g65
sg35
g36
sg18
F1.1405038983502891
sS'task1.thisTrialN'
p86
I4
sg48
g60
sg17
I0
sg16
S'up'
p87
sg27
g31
sg49
g56
sg46
g56
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p88
I17
sg25
g26
sS'task1.thisRepN'
p89
I0
sS'task1.thisN'
p90
I4
sg50
g58
sa(dp91
g45
g60
sg35
g36
sg18
F1.22057278032662
sS'task1.thisTrialN'
p92
I5
sg48
g65
sg17
I1
sg16
S'right'
p93
sg27
g31
sg49
g58
sg46
g56
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p94
I40
sg25
g26
sS'task1.thisRepN'
p95
I0
sS'task1.thisN'
p96
I5
sg50
g56
sa(dp97
g45
g65
sg35
g36
sg18
F2.2143582607041026
sS'task1.thisTrialN'
p98
I6
sg48
g56
sg17
I1
sg16
S'up'
p99
sg27
g31
sg49
g60
sg46
g65
sg32
g11
sg33
g34
sg47
Vup
p100
sS'task1.thisIndex'
p101
I25
sg25
g26
sS'task1.thisRepN'
p102
I0
sS'task1.thisN'
p103
I6
sg50
g58
sa(dp104
g45
g60
sg35
g36
sg18
F2.0668256546869088
sS'task1.thisTrialN'
p105
I7
sg48
g65
sg17
I0
sg16
S'left'
p106
sg27
g31
sg49
g56
sg46
g58
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p107
I46
sg25
g26
sS'task1.thisRepN'
p108
I0
sS'task1.thisN'
p109
I7
sg50
g58
sa(dp110
g45
g65
sg35
g36
sg18
F0.69361250551810372
sS'task1.thisTrialN'
p111
I8
sg48
g58
sg17
I0
sg16
S'up'
p112
sg27
g31
sg49
g56
sg46
g60
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p113
I44
sg25
g26
sS'task1.thisRepN'
p114
I0
sS'task1.thisN'
p115
I8
sg50
g60
sa(dp116
g45
g56
sg35
g36
sg18
F2.1971008746268126
sS'task1.thisTrialN'
p117
I9
sg48
g58
sg17
I1
sg16
S'right'
p118
sg27
g31
sg49
g60
sg46
g65
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p119
I36
sg25
g26
sS'task1.thisRepN'
p120
I0
sS'task1.thisN'
p121
I9
sg50
g65
sa(dp122
g45
g56
sg35
g36
sg18
F1.6344481742689823
sS'task1.thisTrialN'
p123
I10
sg48
g60
sg17
I1
sg16
S'right'
p124
sg27
g31
sg49
g65
sg46
g58
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p125
I45
sg25
g26
sS'task1.thisRepN'
p126
I0
sS'task1.thisN'
p127
I10
sg50
g58
sa(dp128
g45
g58
sg35
g36
sg18
F1.2851451423321123
sS'task1.thisTrialN'
p129
I11
sg48
g60
sg17
I1
sg16
S'right'
p130
sg27
g31
sg49
g56
sg46
g65
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p131
I37
sg25
g26
sS'task1.thisRepN'
p132
I0
sS'task1.thisN'
p133
I11
sg50
g65
sa(dp134
g45
g60
sg35
g36
sg18
F1.2854264831175897
sS'task1.thisTrialN'
p135
I12
sg48
g58
sg17
I1
sg16
S'left'
p136
sg27
g31
sg49
g56
sg46
g56
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p137
I16
sg25
g26
sS'task1.thisRepN'
p138
I0
sS'task1.thisN'
p139
I12
sg50
g65
sa(dp140
g45
g60
sg35
g36
sg18
F1.6522659963247861
sS'task1.thisTrialN'
p141
I13
sg48
g58
sg17
I1
sg16
S'down'
p142
sg27
g31
sg49
g56
sg46
g58
sg32
g11
sg33
g34
sg47
Vdown
p143
sS'task1.thisIndex'
p144
I11
sg25
g26
sS'task1.thisRepN'
p145
I0
sS'task1.thisN'
p146
I13
sg50
g65
sa(dp147
g45
g56
sg35
g36
sg18
F0.75613752784556709
sS'task1.thisTrialN'
p148
I14
sg48
g65
sg17
I1
sg16
S'left'
p149
sg27
g31
sg49
g58
sg46
g58
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p150
I21
sg25
g26
sS'task1.thisRepN'
p151
I0
sS'task1.thisN'
p152
I14
sg50
g60
sa(dp153
g45
g58
sg35
g36
sg18
F0.91716679242017563
sS'task1.thisTrialN'
p154
I15
sg48
g65
sg17
I0
sg16
S'right'
p155
sg27
g31
sg49
g60
sg46
g58
sg32
g11
sg33
g34
sg47
g100
sS'task1.thisIndex'
p156
I33
sg25
g26
sS'task1.thisRepN'
p157
I0
sS'task1.thisN'
p158
I15
sg50
g56
sa(dp159
g45
g58
sg35
g36
sg18
F1.2055799148984079
sS'task1.thisTrialN'
p160
I16
sg48
g65
sg17
I1
sg16
S'left'
p161
sg27
g31
sg49
g60
sg46
g60
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p162
I19
sg25
g26
sS'task1.thisRepN'
p163
I0
sS'task1.thisN'
p164
I16
sg50
g56
sa(dp165
g45
g65
sg35
g36
sg18
F1.0492397703583265
sS'task1.thisTrialN'
p166
I17
sg48
g56
sg17
I1
sg16
S'left'
p167
sg27
g31
sg49
g60
sg46
g60
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p168
I20
sg25
g26
sS'task1.thisRepN'
p169
I0
sS'task1.thisN'
p170
I17
sg50
g58
sa(dp171
g45
g58
sg35
g36
sg18
F1.0128945186988858
sS'task1.thisTrialN'
p172
I18
sg48
g56
sg17
I1
sg16
S'up'
p173
sg27
g31
sg49
g65
sg46
g58
sg32
g11
sg33
g34
sg47
g100
sS'task1.thisIndex'
p174
I34
sg25
g26
sS'task1.thisRepN'
p175
I0
sS'task1.thisN'
p176
I18
sg50
g60
sa(dp177
g45
g58
sg35
g36
sg18
F0.88717689117493137
sS'task1.thisTrialN'
p178
I19
sg48
g65
sg17
I1
sg16
S'left'
p179
sg27
g31
sg49
g56
sg46
g56
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p180
I15
sg25
g26
sS'task1.thisRepN'
p181
I0
sS'task1.thisN'
p182
I19
sg50
g60
sa(dp183
g45
g56
sg35
g36
sg18
F1.1579524806747941
sS'task1.thisTrialN'
p184
I20
sg48
g58
sg17
I1
sg16
S'down'
p185
sg27
g31
sg49
g65
sg46
g58
sg32
g11
sg33
g34
sg47
g143
sS'task1.thisIndex'
p186
I10
sg25
g26
sS'task1.thisRepN'
p187
I0
sS'task1.thisN'
p188
I20
sg50
g60
sa(dp189
g45
g65
sg35
g36
sg18
F0.94946805097879405
sS'task1.thisTrialN'
p190
I21
sg48
g60
sg17
I1
sg16
S'left'
p191
sg27
g31
sg49
g58
sg46
g58
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p192
I23
sg25
g26
sS'task1.thisRepN'
p193
I0
sS'task1.thisN'
p194
I21
sg50
g56
sa(dp195
g45
g65
sg35
g36
sg18
F2.0203457187435561
sS'task1.thisTrialN'
p196
I22
sg48
g56
sg17
I1
sg16
S'down'
p197
sg27
g31
sg49
g60
sg46
g56
sg32
g11
sg33
g34
sg47
g143
sS'task1.thisIndex'
p198
I3
sg25
g26
sS'task1.thisRepN'
p199
I0
sS'task1.thisN'
p200
I22
sg50
g58
sa(dp201
g45
g56
sg35
g36
sg18
F1.1411965035467801
sS'task1.thisTrialN'
p202
I23
sg48
g65
sg17
I1
sg16
S'up'
p203
sg27
g31
sg49
g60
sg46
g56
sg32
g11
sg33
g34
sg47
g100
sS'task1.thisIndex'
p204
I27
sg25
g26
sS'task1.thisRepN'
p205
I0
sS'task1.thisN'
p206
I23
sg50
g58
sa(dp207
g45
g56
sg35
g36
sg18
F0.85663104513787403
sS'task1.thisTrialN'
p208
I24
sg48
g65
sg17
I1
sg16
S'down'
p209
sg27
g31
sg49
g60
sg46
g65
sg32
g11
sg33
g34
sg47
g143
sS'task1.thisIndex'
p210
I1
sg25
g26
sS'task1.thisRepN'
p211
I0
sS'task1.thisN'
p212
I24
sg50
g58
sa(dp213
g45
g65
sg35
g36
sg18
F1.6831576637614489
sS'task1.thisTrialN'
p214
I25
sg48
g58
sg17
I1
sg16
S'up'
p215
sg27
g31
sg49
g56
sg46
g65
sg32
g11
sg33
g34
sg47
g100
sS'task1.thisIndex'
p216
I26
sg25
g26
sS'task1.thisRepN'
p217
I0
sS'task1.thisN'
p218
I25
sg50
g60
sa(dp219
g45
g58
sg35
g36
sg18
F1.2632711368087257
sS'task1.thisTrialN'
p220
I26
sg48
g56
sg17
I1
sg16
S'right'
p221
sg27
g31
sg49
g65
sg46
g60
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p222
I43
sg25
g26
sS'task1.thisRepN'
p223
I0
sS'task1.thisN'
p224
I26
sg50
g60
sa(dp225
g45
g56
sg35
g36
sg18
F1.0303325146542193
sS'task1.thisTrialN'
p226
I27
sg48
g58
sg17
I1
sg16
S'up'
p227
sg27
g31
sg49
g65
sg46
g56
sg32
g11
sg33
g34
sg47
g100
sS'task1.thisIndex'
p228
I28
sg25
g26
sS'task1.thisRepN'
p229
I0
sS'task1.thisN'
p230
I27
sg50
g60
sa(dp231
g45
g60
sg35
g36
sg18
F1.9397054936198401
sS'task1.thisTrialN'
p232
I28
sg48
g56
sg17
I1
sg16
S'down'
p233
sg27
g31
sg49
g58
sg46
g56
sg32
g11
sg33
g34
sg47
g143
sS'task1.thisIndex'
p234
I5
sg25
g26
sS'task1.thisRepN'
p235
I0
sS'task1.thisN'
p236
I28
sg50
g65
sa(dp237
g45
g58
sg35
g36
sg18
F1.0939203443067527
sS'task1.thisTrialN'
p238
I29
sg48
g60
sg17
I1
sg16
S'up'
p239
sg27
g31
sg49
g56
sg46
g58
sg32
g11
sg33
g34
sg47
g100
sS'task1.thisIndex'
p240
I35
sg25
g26
sS'task1.thisRepN'
p241
I0
sS'task1.thisN'
p242
I29
sg50
g65
sa(dp243
g45
g56
sg35
g36
sg18
F2.4719705018833338
sS'task1.thisTrialN'
p244
I30
sg48
g60
sg17
I1
sg16
S'left'
p245
sg27
g31
sg49
g65
sg46
g65
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p246
I12
sg25
g26
sS'task1.thisRepN'
p247
I0
sS'task1.thisN'
p248
I30
sg50
g58
sa(dp249
g45
g60
sg35
g36
sg18
F0.71389374364844116
sS'task1.thisTrialN'
p250
I31
sg48
g56
sg17
I1
sg16
S'left'
p251
sg27
g31
sg49
g58
sg46
g58
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p252
I22
sg25
g26
sS'task1.thisRepN'
p253
I0
sS'task1.thisN'
p254
I31
sg50
g65
sa(dp255
g45
g65
sg35
g36
sg18
F0.94342804605093988
sS'task1.thisTrialN'
p256
I32
sg48
g60
sg17
I1
sg16
S'down'
p257
sg27
g31
sg49
g56
sg46
g60
sg32
g11
sg33
g34
sg47
g143
sS'task1.thisIndex'
p258
I7
sg25
g26
sS'task1.thisRepN'
p259
I0
sS'task1.thisN'
p260
I32
sg50
g58
sa(dp261
g45
g60
sg35
g36
sg18
F1.879203109440823
sS'task1.thisTrialN'
p262
I33
sg48
g58
sg17
I1
sg16
S'up'
p263
sg27
g31
sg49
g65
sg46
g60
sg32
g11
sg33
g34
sg47
g100
sS'task1.thisIndex'
p264
I30
sg25
g26
sS'task1.thisRepN'
p265
I0
sS'task1.thisN'
p266
I33
sg50
g56
sa(dp267
g45
g56
sg35
g36
sg18
F0.67556819931633072
sS'task1.thisTrialN'
p268
I34
sg48
g60
sg17
I1
sg16
S'down'
p269
sg27
g31
sg49
g58
sg46
g60
sg32
g11
sg33
g34
sg47
g143
sS'task1.thisIndex'
p270
I8
sg25
g26
sS'task1.thisRepN'
p271
I0
sS'task1.thisN'
p272
I34
sg50
g65
sa(dp273
g45
g58
sg35
g36
sg18
F1.1115626892715227
sS'task1.thisTrialN'
p274
I35
sg48
g65
sg17
I1
sg16
S'down'
p275
sg27
g31
sg49
g56
sg46
g65
sg32
g11
sg33
g34
sg47
g143
sS'task1.thisIndex'
p276
I2
sg25
g26
sS'task1.thisRepN'
p277
I0
sS'task1.thisN'
p278
I35
sg50
g60
sa(dp279
g45
g60
sg35
g36
sg18
F1.3495789191383665
sS'task1.thisTrialN'
p280
I36
sg48
g58
sg17
I1
sg16
S'left'
p281
sg27
g31
sg49
g65
sg46
g65
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p282
I14
sg25
g26
sS'task1.thisRepN'
p283
I0
sS'task1.thisN'
p284
I36
sg50
g56
sa(dp285
g45
g60
sg35
g36
sg18
F1.6660125573589539
sS'task1.thisTrialN'
p286
I37
sg48
g56
sg17
I1
sg16
S'right'
p287
sg27
g31
sg49
g58
sg46
g65
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p288
I38
sg25
g26
sS'task1.thisRepN'
p289
I0
sS'task1.thisN'
p290
I37
sg50
g65
sa(dp291
g45
g65
sg35
g36
sg18
F1.747658808372762
sS'task1.thisTrialN'
p292
I38
sg48
g58
sg17
I1
sg16
S'right'
p293
sg27
g31
sg49
g60
sg46
g56
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p294
I41
sg25
g26
sS'task1.thisRepN'
p295
I0
sS'task1.thisN'
p296
I38
sg50
g56
sa(dp297
g45
g60
sg35
g36
sg18
F1.0741966549639983
sS'task1.thisTrialN'
p298
I39
sg48
g65
sg17
I1
sg16
S'up'
p299
sg27
g31
sg49
g56
sg46
g60
sg32
g11
sg33
g34
sg47
g100
sS'task1.thisIndex'
p300
I31
sg25
g26
sS'task1.thisRepN'
p301
I0
sS'task1.thisN'
p302
I39
sg50
g58
sa(dp303
g45
g58
sg35
g36
sg18
F1.6705002155767943
sS'task1.thisTrialN'
p304
I40
sg48
g56
sg17
I0
sg16
S'right'
p305
sg27
g31
sg49
g65
sg46
g56
sg32
g11
sg33
g34
sg47
g143
sS'task1.thisIndex'
p306
I4
sg25
g26
sS'task1.thisRepN'
p307
I0
sS'task1.thisN'
p308
I40
sg50
g60
sa(dp309
g45
g56
sg35
g36
sg18
F2.388351336577216
sS'task1.thisTrialN'
p310
I41
sg48
g60
sg17
I1
sg16
S'up'
p311
sg27
g31
sg49
g58
sg46
g56
sg32
g11
sg33
g34
sg47
g100
sS'task1.thisIndex'
p312
I29
sg25
g26
sS'task1.thisRepN'
p313
I0
sS'task1.thisN'
p314
I41
sg50
g65
sa(dp315
g45
g60
sg35
g36
sg18
F4.250008982374311
sS'task1.thisTrialN'
p316
I42
sg48
g56
sg17
I1
sg16
S'up'
p317
sg27
g31
sg49
g58
sg46
g60
sg32
g11
sg33
g34
sg47
g100
sS'task1.thisIndex'
p318
I32
sg25
g26
sS'task1.thisRepN'
p319
I0
sS'task1.thisN'
p320
I42
sg50
g65
sa(dp321
g45
g56
sg35
g36
sg18
F1.7647763260547435
sS'task1.thisTrialN'
p322
I43
sg48
g65
sg17
I1
sg16
S'right'
p323
sg27
g31
sg49
g58
sg46
g60
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p324
I42
sg25
g26
sS'task1.thisRepN'
p325
I0
sS'task1.thisN'
p326
I43
sg50
g60
sa(dp327
g45
g65
sg35
g36
sg18
F0.81932981224235846
sS'task1.thisTrialN'
p328
I44
sg48
g60
sg17
I1
sg16
S'up'
p329
sg27
g31
sg49
g58
sg46
g65
sg32
g11
sg33
g34
sg47
g100
sS'task1.thisIndex'
p330
I24
sg25
g26
sS'task1.thisRepN'
p331
I0
sS'task1.thisN'
p332
I44
sg50
g56
sa(dp333
g45
g58
sg35
g36
sg18
F1.1902492480476212
sS'task1.thisTrialN'
p334
I45
sg48
g60
sg17
I1
sg16
S'down'
p335
sg27
g31
sg49
g65
sg46
g60
sg32
g11
sg33
g34
sg47
g143
sS'task1.thisIndex'
p336
I6
sg25
g26
sS'task1.thisRepN'
p337
I0
sS'task1.thisN'
p338
I45
sg50
g56
sa(dp339
g45
g60
sg35
g36
sg18
F1.2209368872736377
sS'task1.thisTrialN'
p340
I46
sg48
g65
sg17
I0
sg16
S'left'
p341
sg27
g31
sg49
g58
sg46
g65
sg32
g11
sg33
g34
sg47
g143
sS'task1.thisIndex'
p342
I0
sg25
g26
sS'task1.thisRepN'
p343
I0
sS'task1.thisN'
p344
I46
sg50
g56
sa(dp345
g45
g65
sg35
g36
sg18
F1.609125257922642
sS'task1.thisTrialN'
p346
I47
sg48
g58
sg17
I1
sg16
S'down'
p347
sg27
g31
sg49
g60
sg46
g58
sg32
g11
sg33
g34
sg47
g143
sS'task1.thisIndex'
p348
I9
sg25
g26
sS'task1.thisRepN'
p349
I0
sS'task1.thisN'
p350
I47
sg50
g56
sa(dp351
g15
F5.0419592354201086
sg32
g11
sg14
S'return'
p352
sg33
g34
sg25
g26
sg35
g36
sg27
g31
sa(dp353
S'task2.thisRepN'
p354
I0
sVdownbox
p355
Vgreen
p356
sg35
g36
sS'task2.thisIndex'
p357
I47
sg27
g31
sVrightbox
p358
Vyellow
p359
sg21
F0.90245751337079128
sVleftbox
p360
Vblue
p361
sS'task2.thisN'
p362
I0
sVtargettest
p363
g361
sg32
g11
sg33
g34
sVcorrAns
p364
Vright
p365
sg19
S'right'
p366
sg25
g26
sVupbox
p367
Vred
p368
sg20
I1
sS'task2.thisTrialN'
p369
I0
sa(dp370
S'task2.thisRepN'
p371
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p372
I13
sg27
g31
sg358
g356
sg21
F0.88367440690672083
sg360
g359
sS'task2.thisN'
p373
I1
sg363
g356
sg32
g11
sg33
g34
sg364
Vleft
p374
sg19
S'left'
p375
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p376
I1
sa(dp377
S'task2.thisRepN'
p378
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p379
I27
sg27
g31
sg358
g359
sg21
F1.3023611453290869
sg360
g361
sS'task2.thisN'
p380
I2
sg363
g368
sg32
g11
sg33
g34
sg364
Vup
p381
sg19
S'up'
p382
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p383
I2
sa(dp384
S'task2.thisRepN'
p385
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p386
I36
sg27
g31
sg358
g359
sg21
F1.4293462499872476
sg360
g356
sS'task2.thisN'
p387
I3
sg363
g356
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p388
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p389
I3
sa(dp390
S'task2.thisRepN'
p391
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p392
I14
sg27
g31
sg358
g356
sg21
F1.3758517215355823
sg360
g368
sS'task2.thisN'
p393
I4
sg363
g356
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p394
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p395
I4
sa(dp396
S'task2.thisRepN'
p397
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p398
I3
sg27
g31
sg358
g359
sg21
F3.5615032772830091
sg360
g361
sS'task2.thisN'
p399
I5
sg363
g368
sg32
g11
sg33
g34
sg364
Vdown
p400
sg19
S'right'
p401
sg25
g26
sg367
g368
sg20
I0
sS'task2.thisTrialN'
p402
I5
sa(dp403
S'task2.thisRepN'
p404
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p405
I21
sg27
g31
sg358
g361
sg21
F1.5847419620586152
sg360
g359
sS'task2.thisN'
p406
I6
sg363
g361
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p407
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p408
I6
sa(dp409
S'task2.thisRepN'
p410
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p411
I2
sg27
g31
sg358
g368
sg21
F1.6062669381908563
sg360
g359
sS'task2.thisN'
p412
I7
sg363
g356
sg32
g11
sg33
g34
sg364
g400
sg19
S'down'
p413
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p414
I7
sa(dp415
S'task2.thisRepN'
p416
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p417
I0
sg27
g31
sg358
g361
sg21
F0.83314374108249467
sg360
g368
sS'task2.thisN'
p418
I8
sg363
g356
sg32
g11
sg33
g34
sg364
g400
sg19
S'down'
p419
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p420
I8
sa(dp421
S'task2.thisRepN'
p422
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p423
I24
sg27
g31
sg358
g361
sg21
F1.432320378183249
sg360
g368
sS'task2.thisN'
p424
I9
sg363
g356
sg32
g11
sg33
g34
sg364
g381
sg19
S'up'
p425
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p426
I9
sa(dp427
S'task2.thisRepN'
p428
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p429
I17
sg27
g31
sg358
g368
sg21
F0.72249340437156206
sg360
g361
sS'task2.thisN'
p430
I10
sg363
g368
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p431
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p432
I10
sa(dp433
S'task2.thisRepN'
p434
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p435
I4
sg27
g31
sg358
g356
sg21
F1.7008192566700018
sg360
g359
sS'task2.thisN'
p436
I11
sg363
g368
sg32
g11
sg33
g34
sg364
g400
sg19
S'down'
p437
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p438
I11
sa(dp439
S'task2.thisRepN'
p440
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p441
I45
sg27
g31
sg358
g356
sg21
F1.173191719791248
sg360
g361
sS'task2.thisN'
p442
I12
sg363
g361
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p443
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p444
I12
sa(dp445
S'task2.thisRepN'
p446
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p447
I5
sg27
g31
sg358
g361
sg21
F1.2557018827055799
sg360
g356
sS'task2.thisN'
p448
I13
sg363
g368
sg32
g11
sg33
g34
sg364
g400
sg19
S'down'
p449
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p450
I13
sa(dp451
S'task2.thisRepN'
p452
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p453
I23
sg27
g31
sg358
g361
sg21
F1.0075147182615183
sg360
g368
sS'task2.thisN'
p454
I14
sg363
g361
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p455
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p456
I14
sa(dp457
S'task2.thisRepN'
p458
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p459
I15
sg27
g31
sg358
g368
sg21
F1.0953225570510767
sg360
g359
sS'task2.thisN'
p460
I15
sg363
g368
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p461
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p462
I15
sa(dp463
S'task2.thisRepN'
p464
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p465
I38
sg27
g31
sg358
g361
sg21
F1.4912546964978901
sg360
g356
sS'task2.thisN'
p466
I16
sg363
g356
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p467
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p468
I16
sa(dp469
S'task2.thisRepN'
p470
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p471
I26
sg27
g31
sg358
g368
sg21
F1.6387744705534715
sg360
g359
sS'task2.thisN'
p472
I17
sg363
g356
sg32
g11
sg33
g34
sg364
g381
sg19
S'up'
p473
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p474
I17
sa(dp475
S'task2.thisRepN'
p476
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p477
I44
sg27
g31
sg358
g368
sg21
F1.3156342069332823
sg360
g359
sS'task2.thisN'
p478
I18
sg363
g359
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p479
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p480
I18
sa(dp481
S'task2.thisRepN'
p482
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p483
I11
sg27
g31
sg358
g368
sg21
F1.1289949108440851
sg360
g356
sS'task2.thisN'
p484
I19
sg363
g361
sg32
g11
sg33
g34
sg364
g400
sg19
S'down'
p485
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p486
I19
sa(dp487
S'task2.thisRepN'
p488
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p489
I31
sg27
g31
sg358
g368
sg21
F1.2154948518164019
sg360
g361
sS'task2.thisN'
p490
I20
sg363
g359
sg32
g11
sg33
g34
sg364
g381
sg19
S'up'
p491
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p492
I20
sa(dp493
S'task2.thisRepN'
p494
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p495
I42
sg27
g31
sg358
g361
sg21
F1.0763742390654443
sg360
g359
sS'task2.thisN'
p496
I21
sg363
g359
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p497
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p498
I21
sa(dp499
S'task2.thisRepN'
p500
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p501
I10
sg27
g31
sg358
g356
sg21
F2.8684082206682433
sg360
g359
sS'task2.thisN'
p502
I22
sg363
g361
sg32
g11
sg33
g34
sg364
g400
sg19
S'down'
p503
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p504
I22
sa(dp505
S'task2.thisRepN'
p506
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p507
I43
sg27
g31
sg358
g356
sg21
F1.0104971872333408
sg360
g359
sS'task2.thisN'
p508
I23
sg363
g359
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p509
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p510
I23
sa(dp511
S'task2.thisRepN'
p512
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p513
I18
sg27
g31
sg358
g359
sg21
F0.98081140350859641
sg360
g356
sS'task2.thisN'
p514
I24
sg363
g359
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p515
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p516
I24
sa(dp517
S'task2.thisRepN'
p518
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p519
I32
sg27
g31
sg358
g361
sg21
F1.2673032603452157
sg360
g356
sS'task2.thisN'
p520
I25
sg363
g359
sg32
g11
sg33
g34
sg364
g381
sg19
S'up'
p521
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p522
I25
sa(dp523
S'task2.thisRepN'
p524
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p525
I22
sg27
g31
sg358
g361
sg21
F1.1278352221988825
sg360
g356
sS'task2.thisN'
p526
I26
sg363
g361
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p527
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p528
I26
sa(dp529
S'task2.thisRepN'
p530
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p531
I40
sg27
g31
sg358
g361
sg21
F0.59838682978625002
sg360
g368
sS'task2.thisN'
p532
I27
sg363
g368
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p533
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p534
I27
sa(dp535
S'task2.thisRepN'
p536
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p537
I30
sg27
g31
sg358
g356
sg21
F1.9088609836471733
sg360
g368
sS'task2.thisN'
p538
I28
sg363
g359
sg32
g11
sg33
g34
sg364
g381
sg19
S'right'
p539
sg25
g26
sg367
g361
sg20
I0
sS'task2.thisTrialN'
p540
I28
sa(dp541
S'task2.thisRepN'
p542
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p543
I33
sg27
g31
sg358
g359
sg21
F1.3190478298583912
sg360
g368
sS'task2.thisN'
p544
I29
sg363
g361
sg32
g11
sg33
g34
sg364
g381
sg19
S'up'
p545
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p546
I29
sa(dp547
S'task2.thisRepN'
p548
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p549
I8
sg27
g31
sg358
g361
sg21
F0.99725780953303911
sg360
g356
sS'task2.thisN'
p550
I30
sg363
g359
sg32
g11
sg33
g34
sg364
g400
sg19
S'down'
p551
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p552
I30
sa(dp553
S'task2.thisRepN'
p554
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p555
I39
sg27
g31
sg358
g356
sg21
F1.6842807813127365
sg360
g368
sS'task2.thisN'
p556
I31
sg363
g368
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p557
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p558
I31
sa(dp559
S'task2.thisRepN'
p560
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p561
I37
sg27
g31
sg358
g368
sg21
F1.3932489760099998
sg360
g356
sS'task2.thisN'
p562
I32
sg363
g356
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p563
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p564
I32
sa(dp565
S'task2.thisRepN'
p566
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p567
I46
sg27
g31
sg358
g368
sg21
F2.5312371680365686
sg360
g361
sS'task2.thisN'
p568
I33
sg363
g361
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p569
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p570
I33
sa(dp571
S'task2.thisRepN'
p572
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p573
I16
sg27
g31
sg358
g368
sg21
F0.98918361769028706
sg360
g356
sS'task2.thisN'
p574
I34
sg363
g368
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p575
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p576
I34
sa(dp577
S'task2.thisRepN'
p578
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p579
I20
sg27
g31
sg358
g359
sg21
F0.7035688255164132
sg360
g361
sS'task2.thisN'
p580
I35
sg363
g359
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p581
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p582
I35
sa(dp583
S'task2.thisRepN'
p584
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p585
I35
sg27
g31
sg358
g368
sg21
F0.92069975259983039
sg360
g356
sS'task2.thisN'
p586
I36
sg363
g361
sg32
g11
sg33
g34
sg364
g381
sg19
S'up'
p587
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p588
I36
sa(dp589
S'task2.thisRepN'
p590
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p591
I7
sg27
g31
sg358
g368
sg21
F0.96767211511723872
sg360
g361
sS'task2.thisN'
p592
I37
sg363
g359
sg32
g11
sg33
g34
sg364
g400
sg19
S'down'
p593
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p594
I37
sa(dp595
S'task2.thisRepN'
p596
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p597
I41
sg27
g31
sg358
g359
sg21
F1.7180990986835241
sg360
g368
sS'task2.thisN'
p598
I38
sg363
g368
sg32
g11
sg33
g34
sg364
g365
sg19
S'right'
p599
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p600
I38
sa(dp601
S'task2.thisRepN'
p602
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p603
I9
sg27
g31
sg358
g359
sg21
F1.2663501663028001
sg360
g368
sS'task2.thisN'
p604
I39
sg363
g361
sg32
g11
sg33
g34
sg364
g400
sg19
S'down'
p605
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p606
I39
sa(dp607
S'task2.thisRepN'
p608
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p609
I25
sg27
g31
sg358
g359
sg21
F1.4080355676342151
sg360
g361
sS'task2.thisN'
p610
I40
sg363
g356
sg32
g11
sg33
g34
sg364
g381
sg19
S'up'
p611
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p612
I40
sa(dp613
S'task2.thisRepN'
p614
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p615
I6
sg27
g31
sg358
g356
sg21
F1.1602330412788433
sg360
g368
sS'task2.thisN'
p616
I41
sg363
g359
sg32
g11
sg33
g34
sg364
g400
sg19
S'down'
p617
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p618
I41
sa(dp619
S'task2.thisRepN'
p620
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p621
I19
sg27
g31
sg358
g359
sg21
F1.0764258877152315
sg360
g368
sS'task2.thisN'
p622
I42
sg363
g359
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p623
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p624
I42
sa(dp625
S'task2.thisRepN'
p626
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p627
I34
sg27
g31
sg358
g356
sg21
F1.5736227454253822
sg360
g359
sS'task2.thisN'
p628
I43
sg363
g361
sg32
g11
sg33
g34
sg364
g381
sg19
S'up'
p629
sg25
g26
sg367
g368
sg20
I1
sS'task2.thisTrialN'
p630
I43
sa(dp631
S'task2.thisRepN'
p632
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p633
I28
sg27
g31
sg358
g356
sg21
F0.97484550316767127
sg360
g359
sS'task2.thisN'
p634
I44
sg363
g368
sg32
g11
sg33
g34
sg364
g381
sg19
S'up'
p635
sg25
g26
sg367
g361
sg20
I1
sS'task2.thisTrialN'
p636
I44
sa(dp637
S'task2.thisRepN'
p638
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p639
I1
sg27
g31
sg358
g359
sg21
F1.7495781492216338
sg360
g361
sS'task2.thisN'
p640
I45
sg363
g356
sg32
g11
sg33
g34
sg364
g400
sg19
S'down'
p641
sg25
g26
sg367
g356
sg20
I1
sS'task2.thisTrialN'
p642
I45
sa(dp643
S'task2.thisRepN'
p644
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p645
I12
sg27
g31
sg358
g356
sg21
F3.0427750274611753
sg360
g361
sS'task2.thisN'
p646
I46
sg363
g356
sg32
g11
sg33
g34
sg364
g374
sg19
S'left'
p647
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p648
I46
sa(dp649
S'task2.thisRepN'
p650
I0
sg355
g368
sg35
g36
sS'task2.thisIndex'
p651
I29
sg27
g31
sg358
g361
sg21
F1.1586418778806546
sg360
g356
sS'task2.thisN'
p652
I47
sg363
g368
sg32
g11
sg33
g34
sg364
g381
sg19
S'up'
p653
sg25
g26
sg367
g359
sg20
I1
sS'task2.thisTrialN'
p654
I47
sasS'loops'
p655
(lp656
g1
(cpsychopy.data
TrialHandler
p657
g3
NtRp658
(dp659
S'origin'
p660
V\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a larger size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a#########start of task1########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'task1'\u000a\u000a # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()\u000a
p661
sS'thisTrial'
p662
(lp663
sS'_exp'
p664
L458316880L
sg10
S'task1'
p665
sg6
S'C:/Users/Eyetracking/Documents/adamant-squeegee/Brook/VWM_task/VWMtask_a.py'
p666
sS'thisRepN'
p667
I1
sg22
I01
sg23
g24
sS'data'
p668
g1
(cpsychopy.data
DataHandler
p669
c__builtin__
dict
p670
(dp671
S'ran'
p672
cnumpy.ma.core
_mareconstruct
p673
(cnumpy.ma.core
MaskedArray
p674
cnumpy
ndarray
p675
(I0
tp676
S'b'
tRp677
(I1
(L48L
L1L
tg29
(S'f4'
I0
I1
tRp678
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
g673
(g674
g675
g676
S'b'
tRp679
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg16
cnumpy.core.multiarray
_reconstruct
p680
(g675
(I0
tS'b'
tRp681
(I1
(L48L
L1L
tg29
(S'O8'
I0
I1
tRp682
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp683
g341
ag209
ag275
ag197
ag305
ag233
ag335
ag257
ag269
ag347
ag185
ag142
ag245
ag75
ag281
ag179
ag136
ag87
ag59
ag161
ag167
ag149
ag251
ag191
ag329
ag99
ag215
ag203
ag227
ag311
ag263
ag299
ag317
ag155
ag173
ag239
ag118
ag130
ag287
ag68
ag93
ag293
ag323
ag221
ag112
ag124
ag106
ag81
atbsg18
g673
(g674
g675
g676
S'b'
tRp684
(I1
(L48L
L1L
tg678
I00
S'\xa9G\x9c?,L[?\xb0G\x8e?XM\x01@\xf3\xd2\xd5?EH\xf8?\x16Z\x98?\x80\x84q?\n\xf2,?\xd1\xf7\xcd?\xc97\x94?t}\xd3?\xc44\x1e@d\x02\x86?\x01\xbf\xac?\x06\x1ec?\xdb\x88\xa4?\x08\xfc\x91?\xae\x07I?qP\x9a?}M\x86?;\x92A?\xbe\xc16?W\x10s?\x99\xbfQ?\x0c\xb8\r@\xb6q\xd7?\xba\x12\x92?\xf0\xe1\x83?\xc0\xda\x18@\xba\x89\xf0?G\x7f\x89?\x13\x00\x88@q\xcbj?\x87\xa6\x81?\x95\x05\x8c?M\x9d\x0c@\xa3\x7f\xa4?\xe6?\xd5?"\xe9\xf8>\xbb;\x9c?I\xb3\xdf?1\xe4\xe1?\xde\xb2\xa1?\x97\x901?\x995\xd1?\xdfF\x04@:\xc7\x13?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p685
g673
(g674
g675
g676
S'b'
tRp686
(I1
(L48L
L1L
tg678
I00
S'\x00\x008B\x00\x00\xc0A\x00\x00\x0cB\x00\x00\xb0A\x00\x00 B\x00\x00\xe0A\x00\x004B\x00\x00\x00B\x00\x00\x08B\x00\x00<B\x00\x00\xa0A\x00\x00PA\x00\x00\xf0A\x00\x00\x00@\x00\x00\x10B\x00\x00\x98A\x00\x00@A\x00\x00\x80@\x00\x00\x00\x00\x00\x00\x80A\x00\x00\x88A\x00\x00`A\x00\x00\xf8A\x00\x00\xa8A\x00\x000B\x00\x00\xc0@\x00\x00\xc8A\x00\x00\xb8A\x00\x00\xd8A\x00\x00$B\x00\x00\x04B\x00\x00\x1cB\x00\x00(B\x00\x00pA\x00\x00\x90A\x00\x00\xe8A\x00\x00\x10A\x00\x000A\x00\x00\x14B\x00\x00\x80?\x00\x00\xa0@\x00\x00\x18B\x00\x00,B\x00\x00\xd0A\x00\x00\x00A\x00\x00 A\x00\x00\xe0@\x00\x00@@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp687
(dp688
S'isNumeric'
p689
(dp690
g672
I01
sg17
I01
sg16
I00
sg18
I01
sg685
I01
ssS'trials'
p691
g658
sS'dataTypes'
p692
(lp693
g672
ag685
ag16
ag17
ag18
asS'dataShape'
p694
(lp695
L48L
aI1
asbsS'method'
p696
S'fullRandom'
p697
sS'sequenceIndices'
p698
g680
(g675
(I0
tS'b'
tRp699
(I1
(L48L
L1L
tg682
I00
(lp700
I18
aI39
aI13
aI47
aI17
aI40
aI25
aI46
aI44
aI36
aI45
aI37
aI16
aI11
aI21
aI33
aI19
aI20
aI34
aI15
aI10
aI23
aI3
aI27
aI1
aI26
aI43
aI28
aI5
aI35
aI12
aI22
aI7
aI30
aI8
aI2
aI14
aI38
aI41
aI31
aI4
aI29
aI32
aI42
aI24
aI6
aI0
aI9
atbsS'finished'
p701
I01
sS'nReps'
p702
I1
sS'nRemaining'
p703
I-1
sS'trialList'
p704
(lp705
g1
(cpsychopy.data
TrialType
p706
g670
(dp707
g45
g60
sg46
g65
sg47
g143
sg48
g65
sg49
g58
sg50
g56
stRp708
ag1
(g706
g670
(dp709
g45
g56
sg46
g65
sg47
g143
sg48
g65
sg49
g60
sg50
g58
stRp710
ag1
(g706
g670
(dp711
g45
g58
sg46
g65
sg47
g143
sg48
g65
sg49
g56
sg50
g60
stRp712
ag1
(g706
g670
(dp713
g45
g65
sg46
g56
sg47
g143
sg48
g56
sg49
g60
sg50
g58
stRp714
ag1
(g706
g670
(dp715
g45
g58
sg46
g56
sg47
g143
sg48
g56
sg49
g65
sg50
g60
stRp716
ag1
(g706
g670
(dp717
g45
g60
sg46
g56
sg47
g143
sg48
g56
sg49
g58
sg50
g65
stRp718
ag1
(g706
g670
(dp719
g45
g58
sg46
g60
sg47
g143
sg48
g60
sg49
g65
sg50
g56
stRp720
ag1
(g706
g670
(dp721
g45
g65
sg46
g60
sg47
g143
sg48
g60
sg49
g56
sg50
g58
stRp722
ag1
(g706
g670
(dp723
g45
g56
sg46
g60
sg47
g143
sg48
g60
sg49
g58
sg50
g65
stRp724
ag1
(g706
g670
(dp725
g45
g65
sg46
g58
sg47
g143
sg48
g58
sg49
g60
sg50
g56
stRp726
ag1
(g706
g670
(dp727
g45
g56
sg46
g58
sg47
g143
sg48
g58
sg49
g65
sg50
g60
stRp728
ag1
(g706
g670
(dp729
g45
g60
sg46
g58
sg47
g143
sg48
g58
sg49
g56
sg50
g65
stRp730
ag1
(g706
g670
(dp731
g45
g56
sg46
g65
sg47
g61
sg48
g60
sg49
g65
sg50
g58
stRp732
ag1
(g706
g670
(dp733
g45
g58
sg46
g65
sg47
g61
sg48
g56
sg49
g65
sg50
g60
stRp734
ag1
(g706
g670
(dp735
g45
g60
sg46
g65
sg47
g61
sg48
g58
sg49
g65
sg50
g56
stRp736
ag1
(g706
g670
(dp737
g45
g58
sg46
g56
sg47
g61
sg48
g65
sg49
g56
sg50
g60
stRp738
ag1
(g706
g670
(dp739
g45
g60
sg46
g56
sg47
g61
sg48
g58
sg49
g56
sg50
g65
stRp740
ag1
(g706
g670
(dp741
g45
g65
sg46
g56
sg47
g61
sg48
g60
sg49
g56
sg50
g58
stRp742
ag1
(g706
g670
(dp743
g45
g56
sg46
g60
sg47
g61
sg48
g58
sg49
g60
sg50
g65
stRp744
ag1
(g706
g670
(dp745
g45
g58
sg46
g60
sg47
g61
sg48
g65
sg49
g60
sg50
g56
stRp746
ag1
(g706
g670
(dp747
g45
g65
sg46
g60
sg47
g61
sg48
g56
sg49
g60
sg50
g58
stRp748
ag1
(g706
g670
(dp749
g45
g56
sg46
g58
sg47
g61
sg48
g65
sg49
g58
sg50
g60
stRp750
ag1
(g706
g670
(dp751
g45
g60
sg46
g58
sg47
g61
sg48
g56
sg49
g58
sg50
g65
stRp752
ag1
(g706
g670
(dp753
g45
g65
sg46
g58
sg47
g61
sg48
g60
sg49
g58
sg50
g56
stRp754
ag1
(g706
g670
(dp755
g45
g65
sg46
g65
sg47
g100
sg48
g60
sg49
g58
sg50
g56
stRp756
ag1
(g706
g670
(dp757
g45
g65
sg46
g65
sg47
g100
sg48
g56
sg49
g60
sg50
g58
stRp758
ag1
(g706
g670
(dp759
g45
g65
sg46
g65
sg47
g100
sg48
g58
sg49
g56
sg50
g60
stRp760
ag1
(g706
g670
(dp761
g45
g56
sg46
g56
sg47
g100
sg48
g65
sg49
g60
sg50
g58
stRp762
ag1
(g706
g670
(dp763
g45
g56
sg46
g56
sg47
g100
sg48
g58
sg49
g65
sg50
g60
stRp764
ag1
(g706
g670
(dp765
g45
g56
sg46
g56
sg47
g100
sg48
g60
sg49
g58
sg50
g65
stRp766
ag1
(g706
g670
(dp767
g45
g60
sg46
g60
sg47
g100
sg48
g58
sg49
g65
sg50
g56
stRp768
ag1
(g706
g670
(dp769
g45
g60
sg46
g60
sg47
g100
sg48
g65
sg49
g56
sg50
g58
stRp770
ag1
(g706
g670
(dp771
g45
g60
sg46
g60
sg47
g100
sg48
g56
sg49
g58
sg50
g65
stRp772
ag1
(g706
g670
(dp773
g45
g58
sg46
g58
sg47
g100
sg48
g65
sg49
g60
sg50
g56
stRp774
ag1
(g706
g670
(dp775
g45
g58
sg46
g58
sg47
g100
sg48
g56
sg49
g65
sg50
g60
stRp776
ag1
(g706
g670
(dp777
g45
g58
sg46
g58
sg47
g100
sg48
g60
sg49
g56
sg50
g65
stRp778
ag1
(g706
g670
(dp779
g45
g56
sg46
g65
sg47
g69
sg48
g58
sg49
g60
sg50
g65
stRp780
ag1
(g706
g670
(dp781
g45
g58
sg46
g65
sg47
g69
sg48
g60
sg49
g56
sg50
g65
stRp782
ag1
(g706
g670
(dp783
g45
g60
sg46
g65
sg47
g69
sg48
g56
sg49
g58
sg50
g65
stRp784
ag1
(g706
g670
(dp785
g45
g58
sg46
g56
sg47
g69
sg48
g60
sg49
g65
sg50
g56
stRp786
ag1
(g706
g670
(dp787
g45
g60
sg46
g56
sg47
g69
sg48
g65
sg49
g58
sg50
g56
stRp788
ag1
(g706
g670
(dp789
g45
g65
sg46
g56
sg47
g69
sg48
g58
sg49
g60
sg50
g56
stRp790
ag1
(g706
g670
(dp791
g45
g56
sg46
g60
sg47
g69
sg48
g65
sg49
g58
sg50
g60
stRp792
ag1
(g706
g670
(dp793
g45
g58
sg46
g60
sg47
g69
sg48
g56
sg49
g65
sg50
g60
stRp794
ag1
(g706
g670
(dp795
g45
g65
sg46
g60
sg47
g69
sg48
g58
sg49
g56
sg50
g60
stRp796
ag1
(g706
g670
(dp797
g45
g56
sg46
g58
sg47
g69
sg48
g60
sg49
g65
sg50
g58
stRp798
ag1
(g706
g670
(dp799
g45
g60
sg46
g58
sg47
g69
sg48
g65
sg49
g56
sg50
g58
stRp800
ag1
(g706
g670
(dp801
g45
g65
sg46
g58
sg47
g69
sg48
g56
sg49
g60
sg50
g58
stRp802
asS'seed'
p803
NsS'thisIndex'
p804
I9
sS'thisN'
p805
I48
sS'thisTrialN'
p806
I0
sS'nTotal'
p807
I48
sS'_warnUseOfNext'
p808
I01
sbag1
(g657
g3
NtRp809
(dp810
g660
V\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a larger size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a#########start of task1########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'task1'\u000a\u000a # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()\u000a
p811
sg662
(lp812
sg664
L458316880L
sg10
S'task2'
p813
sg6
g666
sg667
I1
sg22
I01
sg23
g24
sg668
g1
(g669
g670
(dp814
g672
g673
(g674
g675
g676
S'b'
tRp815
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g673
(g674
g675
g676
S'b'
tRp816
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg685
g673
(g674
g675
g676
S'b'
tRp817
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x00A\x00\x004B\x00\x00\xe0@\x00\x00\xa0@\x00\x000A\x00\x00PA\x00\x00$B\x00\x00\x14B\x00\x00\xf0A\x00\x00\x1cB\x00\x00\xb0A\x00\x00\x98A\x00\x008B\x00\x00\x80?\x00\x00\x80@\x00\x00pA\x00\x00\x08B\x00\x00 A\x00\x00\xc0A\x00\x00(B\x00\x00\x0cB\x00\x00\xc0@\x00\x00\xd0A\x00\x00`A\x00\x00\x10A\x00\x00 B\x00\x00\x88A\x00\x00\x00@\x00\x000B\x00\x00<B\x00\x00\xe0A\x00\x00\xa0A\x00\x00\xc8A\x00\x00\xe8A\x00\x00,B\x00\x00\x10B\x00\x00@@\x00\x00\x00B\x00\x00\x80A\x00\x00\xf8A\x00\x00\xd8A\x00\x00\x18B\x00\x00\xa8A\x00\x00\xb8A\x00\x00\x90A\x00\x00@A\x00\x00\x04B\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g673
(g674
g675
g676
S'b'
tRp818
(I1
(L48L
L1L
tg678
I00
S'\xe9HU?-\xf2\xdf?(\x9a\xcd?\xab\xefc@r\xb4\xd9?\xd7\xba\xa0?\x84\x82\x94?\\\xb9w?JL\x7f?\xc3\x17\xa2?\x00\x947@\xe8\x82\x90?\xd3\xbcB@|8b?\xe9\x1b\xb0?\x883\x8c?#;}?T\xf58?u\x16{?S\xc8\x89?\x16\x1d4?\xd3\xd8\xca?\xe8\\\x90?>\xf6\x80?FV\xb7?\x82:\xb4?]\xc3\xd1?\xc5\xb3\xa6?z\x8fy?aN\x94?\x8fU\xf4?V\x95\x9b?\xfe6\xa2?\x8f\xd6\xa8?xl\xc9?\xfb\xb2k?\xd1\xf4\xb6?\xfcU\xb2?o\xe1\xbe?\x83\x96\xd7?\xe1/\x19?\xac\xea\xdb?\xa2\xc6\x89?\xf9W\x81?\xb4f\xa8?%+\x96?\xca\xff!@u\x07g?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g680
(g675
(I0
tS'b'
tRp819
(I1
(L48L
L1L
tg682
I00
(lp820
g419
ag641
ag413
ag401
ag437
ag449
ag617
ag593
ag551
ag605
ag503
ag485
ag647
ag375
ag394
ag461
ag575
ag431
ag515
ag623
ag581
ag407
ag527
ag455
ag425
ag611
ag473
ag382
ag635
ag653
ag539
ag491
ag521
ag545
ag629
ag587
ag388
ag563
ag467
ag557
ag533
ag599
ag497
ag509
ag479
ag443
ag569
ag366
atbstRp821
(dp822
g689
(dp823
g672
I01
sg21
I01
sg20
I01
sg685
I01
sg19
I00
ssg691
g809
sg692
(lp824
g672
ag685
ag19
ag20
ag21
asg694
(lp825
L48L
aI1
asbsg696
g697
sg698
g680
(g675
(I0
tS'b'
tRp826
(I1
(L48L
L1L
tg682
I00
(lp827
I47
aI13
aI27
aI36
aI14
aI3
aI21
aI2
aI0
aI24
aI17
aI4
aI45
aI5
aI23
aI15
aI38
aI26
aI44
aI11
aI31
aI42
aI10
aI43
aI18
aI32
aI22
aI40
aI30
aI33
aI8
aI39
aI37
aI46
aI16
aI20
aI35
aI7
aI41
aI9
aI25
aI6
aI19
aI34
aI28
aI1
aI12
aI29
atbsg701
I01
sg702
I1
sg703
I-1
sg704
(lp828
g1
(g706
g670
(dp829
g355
g359
sg363
g356
sg364
g400
sg367
g356
sg358
g361
sg360
g368
stRp830
ag1
(g706
g670
(dp831
g355
g368
sg363
g356
sg364
g400
sg367
g356
sg358
g359
sg360
g361
stRp832
ag1
(g706
g670
(dp833
g355
g361
sg363
g356
sg364
g400
sg367
g356
sg358
g368
sg360
g359
stRp834
ag1
(g706
g670
(dp835
g355
g356
sg363
g368
sg364
g400
sg367
g368
sg358
g359
sg360
g361
stRp836
ag1
(g706
g670
(dp837
g355
g361
sg363
g368
sg364
g400
sg367
g368
sg358
g356
sg360
g359
stRp838
ag1
(g706
g670
(dp839
g355
g359
sg363
g368
sg364
g400
sg367
g368
sg358
g361
sg360
g356
stRp840
ag1
(g706
g670
(dp841
g355
g361
sg363
g359
sg364
g400
sg367
g359
sg358
g356
sg360
g368
stRp842
ag1
(g706
g670
(dp843
g355
g356
sg363
g359
sg364
g400
sg367
g359
sg358
g368
sg360
g361
stRp844
ag1
(g706
g670
(dp845
g355
g368
sg363
g359
sg364
g400
sg367
g359
sg358
g361
sg360
g356
stRp846
ag1
(g706
g670
(dp847
g355
g356
sg363
g361
sg364
g400
sg367
g361
sg358
g359
sg360
g368
stRp848
ag1
(g706
g670
(dp849
g355
g368
sg363
g361
sg364
g400
sg367
g361
sg358
g356
sg360
g359
stRp850
ag1
(g706
g670
(dp851
g355
g359
sg363
g361
sg364
g400
sg367
g361
sg358
g368
sg360
g356
stRp852
ag1
(g706
g670
(dp853
g355
g368
sg363
g356
sg364
g374
sg367
g359
sg358
g356
sg360
g361
stRp854
ag1
(g706
g670
(dp855
g355
g361
sg363
g356
sg364
g374
sg367
g368
sg358
g356
sg360
g359
stRp856
ag1
(g706
g670
(dp857
g355
g359
sg363
g356
sg364
g374
sg367
g361
sg358
g356
sg360
g368
stRp858
ag1
(g706
g670
(dp859
g355
g361
sg363
g368
sg364
g374
sg367
g356
sg358
g368
sg360
g359
stRp860
ag1
(g706
g670
(dp861
g355
g359
sg363
g368
sg364
g374
sg367
g361
sg358
g368
sg360
g356
stRp862
ag1
(g706
g670
(dp863
g355
g356
sg363
g368
sg364
g374
sg367
g359
sg358
g368
sg360
g361
stRp864
ag1
(g706
g670
(dp865
g355
g368
sg363
g359
sg364
g374
sg367
g361
sg358
g359
sg360
g356
stRp866
ag1
(g706
g670
(dp867
g355
g361
sg363
g359
sg364
g374
sg367
g356
sg358
g359
sg360
g368
stRp868
ag1
(g706
g670
(dp869
g355
g356
sg363
g359
sg364
g374
sg367
g368
sg358
g359
sg360
g361
stRp870
ag1
(g706
g670
(dp871
g355
g368
sg363
g361
sg364
g374
sg367
g356
sg358
g361
sg360
g359
stRp872
ag1
(g706
g670
(dp873
g355
g359
sg363
g361
sg364
g374
sg367
g368
sg358
g361
sg360
g356
stRp874
ag1
(g706
g670
(dp875
g355
g356
sg363
g361
sg364
g374
sg367
g359
sg358
g361
sg360
g368
stRp876
ag1
(g706
g670
(dp877
g355
g356
sg363
g356
sg364
g381
sg367
g359
sg358
g361
sg360
g368
stRp878
ag1
(g706
g670
(dp879
g355
g356
sg363
g356
sg364
g381
sg367
g368
sg358
g359
sg360
g361
stRp880
ag1
(g706
g670
(dp881
g355
g356
sg363
g356
sg364
g381
sg367
g361
sg358
g368
sg360
g359
stRp882
ag1
(g706
g670
(dp883
g355
g368
sg363
g368
sg364
g381
sg367
g356
sg358
g359
sg360
g361
stRp884
ag1
(g706
g670
(dp885
g355
g368
sg363
g368
sg364
g381
sg367
g361
sg358
g356
sg360
g359
stRp886
ag1
(g706
g670
(dp887
g355
g368
sg363
g368
sg364
g381
sg367
g359
sg358
g361
sg360
g356
stRp888
ag1
(g706
g670
(dp889
g355
g359
sg363
g359
sg364
g381
sg367
g361
sg358
g356
sg360
g368
stRp890
ag1
(g706
g670
(dp891
g355
g359
sg363
g359
sg364
g381
sg367
g356
sg358
g368
sg360
g361
stRp892
ag1
(g706
g670
(dp893
g355
g359
sg363
g359
sg364
g381
sg367
g368
sg358
g361
sg360
g356
stRp894
ag1
(g706
g670
(dp895
g355
g361
sg363
g361
sg364
g381
sg367
g356
sg358
g359
sg360
g368
stRp896
ag1
(g706
g670
(dp897
g355
g361
sg363
g361
sg364
g381
sg367
g368
sg358
g356
sg360
g359
stRp898
ag1
(g706
g670
(dp899
g355
g361
sg363
g361
sg364
g381
sg367
g359
sg358
g368
sg360
g356
stRp900
ag1
(g706
g670
(dp901
g355
g368
sg363
g356
sg364
g365
sg367
g361
sg358
g359
sg360
g356
stRp902
ag1
(g706
g670
(dp903
g355
g361
sg363
g356
sg364
g365
sg367
g359
sg358
g368
sg360
g356
stRp904
ag1
(g706
g670
(dp905
g355
g359
sg363
g356
sg364
g365
sg367
g368
sg358
g361
sg360
g356
stRp906
ag1
(g706
g670
(dp907
g355
g361
sg363
g368
sg364
g365
sg367
g359
sg358
g356
sg360
g368
stRp908
ag1
(g706
g670
(dp909
g355
g359
sg363
g368
sg364
g365
sg367
g356
sg358
g361
sg360
g368
stRp910
ag1
(g706
g670
(dp911
g355
g356
sg363
g368
sg364
g365
sg367
g361
sg358
g359
sg360
g368
stRp912
ag1
(g706
g670
(dp913
g355
g368
sg363
g359
sg364
g365
sg367
g356
sg358
g361
sg360
g359
stRp914
ag1
(g706
g670
(dp915
g355
g361
sg363
g359
sg364
g365
sg367
g368
sg358
g356
sg360
g359
stRp916
ag1
(g706
g670
(dp917
g355
g356
sg363
g359
sg364
g365
sg367
g361
sg358
g368
sg360
g359
stRp918
ag1
(g706
g670
(dp919
g355
g368
sg363
g361
sg364
g365
sg367
g359
sg358
g356
sg360
g361
stRp920
ag1
(g706
g670
(dp921
g355
g359
sg363
g361
sg364
g365
sg367
g356
sg358
g368
sg360
g361
stRp922
ag1
(g706
g670
(dp923
g355
g356
sg363
g361
sg364
g365
sg367
g368
sg358
g359
sg360
g361
stRp924
asg803
Nsg804
I29
sg805
I48
sg806
I0
sg807
I48
sg808
I01
sbasS'savePickle'
p925
I00
sb.