ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cEyetracking\u005cDocuments\u005cadamant-squeegee\u005cBrook\u005cVWM_task\u005cdata/test_test1_2015_Dec_17_1228
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'test1'
p11
sS'dataNames'
p12
(lp13
S'start.keys'
p14
aS'start.rt'
p15
aS'answer2.keys'
p16
aS'answer2.corr'
p17
aS'answer2.rt'
p18
aS'answer1.keys'
p19
aS'answer1.corr'
p20
aS'answer1.rt'
p21
asS'autoLog'
p22
I01
sS'extraInfo'
p23
(dp24
S'date'
p25
V2015_Dec_17_1228
p26
sS'frameRate'
p27
cnumpy.core.multiarray
scalar
p28
(cnumpy
dtype
p29
(S'f8'
I0
I1
tRp30
(I3
S'<'
NNNI-1
I-1
I0
tbS'\xf9\xeep%a\xd3q@'
tRp31
sS'expName'
p32
g11
sS'session'
p33
V001
p34
sS'participant'
p35
Vtest
p36
ssS'loopsUnfinished'
p37
(lp38
sS'saveWideText'
p39
I01
sS'thisEntry'
p40
(dp41
sS'version'
p42
S''
sS'_paramNamesSoFar'
p43
(lp44
Vdownbox
p45
aVtargettest
p46
aVcorrAns
p47
aVupbox
p48
aVrightbox
p49
aVleftbox
p50
asS'entries'
p51
(lp52
(dp53
g15
F2.0681749355835564
sg32
g11
sg14
S'return'
p54
sg33
g34
sg25
g26
sg35
g36
sg27
g31
sa(dp55
g33
g34
sg35
g36
sg27
g31
sg18
F0.74345088694531114
sg15
F4.1120256023323236
sg32
g11
sg14
S'return'
p56
sg16
S'right'
p57
sg25
g26
sg17
I0
sa(dp58
g45
Vyellow
p59
sg35
g36
sg21
F0.69014434675045777
sS'task1.thisTrialN'
p60
I0
sg48
Vblue
p61
sg20
I0
sg19
S'down'
p62
sg27
g31
sg49
Vgreen
p63
sg46
g63
sg32
g11
sg33
g34
sg47
Vleft
p64
sS'task1.thisIndex'
p65
I14
sg25
g26
sS'task1.thisRepN'
p66
I0
sS'task1.thisN'
p67
I0
sg50
Vred
p68
sa(dp69
g45
g61
sg35
g36
sg21
F0.6723967796906436
sS'task1.thisTrialN'
p70
I1
sg48
g59
sg20
I0
sg19
S'down'
p71
sg27
g31
sg49
g68
sg46
g61
sg32
g11
sg33
g34
sg47
Vup
p72
sS'task1.thisIndex'
p73
I35
sg25
g26
sS'task1.thisRepN'
p74
I0
sS'task1.thisN'
p75
I1
sg50
g63
sa(dp76
g45
g63
sg35
g36
sg21
F1.4130358627699025
sS'task1.thisTrialN'
p77
I2
sg48
g61
sg20
I0
sg19
S'left'
p78
sg27
g31
sg49
g59
sg46
g68
sg32
g11
sg33
g34
sg47
Vright
p79
sS'task1.thisIndex'
p80
I41
sg25
g26
sS'task1.thisRepN'
p81
I0
sS'task1.thisN'
p82
I2
sg50
g68
sa(dp83
g45
g61
sg35
g36
sg21
F1.3178464373338556
sS'task1.thisTrialN'
p84
I3
sg48
g68
sg20
I0
sg19
S'right'
p85
sg27
g31
sg49
g63
sg46
g61
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p86
I34
sg25
g26
sS'task1.thisRepN'
p87
I0
sS'task1.thisN'
p88
I3
sg50
g59
sa(dp89
g45
g61
sg35
g36
sg21
F2.4377521480707856
sS'task1.thisTrialN'
p90
I4
sg48
g68
sg20
I0
sg19
S'down'
p91
sg27
g31
sg49
g63
sg46
g63
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p92
I13
sg25
g26
sS'task1.thisRepN'
p93
I0
sS'task1.thisN'
p94
I4
sg50
g59
sa(dp95
g45
g68
sg35
g36
sg21
F2.8696904545595316
sS'task1.thisTrialN'
p96
I5
sg48
g59
sg20
I0
sg19
S'up'
p97
sg27
g31
sg49
g63
sg46
g61
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p98
I45
sg25
g26
sS'task1.thisRepN'
p99
I0
sS'task1.thisN'
p100
I5
sg50
g61
sa(dp101
g45
g63
sg35
g36
sg21
F0.55122359182041691
sS'task1.thisTrialN'
p102
I6
sg48
g59
sg20
I1
sg19
S'left'
p103
sg27
g31
sg49
g61
sg46
g61
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p104
I23
sg25
g26
sS'task1.thisRepN'
p105
I0
sS'task1.thisN'
p106
I6
sg50
g68
sa(dp107
g45
g63
sg35
g36
sg21
F0.91678504152423557
sS'task1.thisTrialN'
p108
I7
sg48
g61
sg20
I1
sg19
S'right'
p109
sg27
g31
sg49
g68
sg46
g59
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p110
I44
sg25
g26
sS'task1.thisRepN'
p111
I0
sS'task1.thisN'
p112
I7
sg50
g59
sa(dp113
g45
g68
sg35
g36
sg21
F0.48289691827585557
sS'task1.thisTrialN'
p114
I8
sg48
g61
sg20
I0
sg19
S'down'
p115
sg27
g31
sg49
g63
sg46
g68
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p116
I28
sg25
g26
sS'task1.thisRepN'
p117
I0
sS'task1.thisN'
p118
I8
sg50
g59
sa(dp119
g45
g68
sg35
g36
sg21
F0.18153089166753489
sS'task1.thisTrialN'
p120
I9
sg48
g59
sg20
I0
sg19
S'up'
p121
sg27
g31
sg49
g61
sg46
g59
sg32
g11
sg33
g34
sg47
Vdown
p122
sS'task1.thisIndex'
p123
I8
sg25
g26
sS'task1.thisRepN'
p124
I0
sS'task1.thisN'
p125
I9
sg50
g63
sa(dp126
g45
g59
sg35
g36
sg21
F0.42278302177328442
sS'task1.thisTrialN'
p127
I10
sg48
g61
sg20
I1
sg19
S'up'
p128
sg27
g31
sg49
g63
sg46
g59
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p129
I30
sg25
g26
sS'task1.thisRepN'
p130
I0
sS'task1.thisN'
p131
I10
sg50
g68
sa(dp132
g45
g61
sg35
g36
sg21
F0.50150422684851037
sS'task1.thisTrialN'
p133
I11
sg48
g59
sg20
I1
sg19
S'right'
p134
sg27
g31
sg49
g68
sg46
g63
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p135
I37
sg25
g26
sS'task1.thisRepN'
p136
I0
sS'task1.thisN'
p137
I11
sg50
g63
sa(dp138
g45
g63
sg35
g36
sg21
F0.39982567778429257
sS'task1.thisTrialN'
p139
I12
sg48
g59
sg20
I0
sg19
S'left'
p140
sg27
g31
sg49
g68
sg46
g59
sg32
g11
sg33
g34
sg47
g122
sS'task1.thisIndex'
p141
I7
sg25
g26
sS'task1.thisRepN'
p142
I0
sS'task1.thisN'
p143
I12
sg50
g61
sa(dp144
g45
g63
sg35
g36
sg21
F0.43929134201812303
sS'task1.thisTrialN'
p145
I13
sg48
g59
sg20
I0
sg19
S'down'
p146
sg27
g31
sg49
g61
sg46
g63
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p147
I24
sg25
g26
sS'task1.thisRepN'
p148
I0
sS'task1.thisN'
p149
I13
sg50
g68
sa(dp150
g45
g61
sg35
g36
sg21
F0.82162545040182522
sS'task1.thisTrialN'
p151
I14
sg48
g68
sg20
I0
sg19
S'up'
p152
sg27
g31
sg49
g63
sg46
g68
sg32
g11
sg33
g34
sg47
g122
sS'task1.thisIndex'
p153
I4
sg25
g26
sS'task1.thisRepN'
p154
I0
sS'task1.thisN'
p155
I14
sg50
g59
sa(dp156
g45
g63
sg35
g36
sg21
F0.58329772463616791
sS'task1.thisTrialN'
p157
I15
sg48
g59
sg20
I0
sg19
S'down'
p158
sg27
g31
sg49
g68
sg46
g68
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p159
I17
sg25
g26
sS'task1.thisRepN'
p160
I0
sS'task1.thisN'
p161
I15
sg50
g61
sa(dp162
g45
g68
sg35
g36
sg21
F0.35840378080956725
sS'task1.thisTrialN'
p163
I16
sg48
g61
sg20
I0
sg19
S'right'
p164
sg27
g31
sg49
g63
sg46
g61
sg32
g11
sg33
g34
sg47
g122
sS'task1.thisIndex'
p165
I10
sg25
g26
sS'task1.thisRepN'
p166
I0
sS'task1.thisN'
p167
I16
sg50
g59
sa(dp168
g45
g63
sg35
g36
sg21
F0.43907159465379664
sS'task1.thisTrialN'
p169
I17
sg48
g68
sg20
I0
sg19
S'left'
p170
sg27
g31
sg49
g59
sg46
g63
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p171
I25
sg25
g26
sS'task1.thisRepN'
p172
I0
sS'task1.thisN'
p173
I17
sg50
g61
sa(dp174
g45
g68
sg35
g36
sg21
F0.90206164731603167
sS'task1.thisTrialN'
p175
I18
sg48
g61
sg20
I1
sg19
S'right'
p176
sg27
g31
sg49
g59
sg46
g63
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p177
I36
sg25
g26
sS'task1.thisRepN'
p178
I0
sS'task1.thisN'
p179
I18
sg50
g63
sa(dp180
g45
g61
sg35
g36
sg21
F0.39193530380953234
sS'task1.thisTrialN'
p181
I19
sg48
g63
sg20
I0
sg19
S'up'
p182
sg27
g31
sg49
g68
sg46
g63
sg32
g11
sg33
g34
sg47
g122
sS'task1.thisIndex'
p183
I2
sg25
g26
sS'task1.thisRepN'
p184
I0
sS'task1.thisN'
p185
I19
sg50
g59
sa(dp186
g45
g63
sg35
g36
sg21
F0.05004722162334474
sS'task1.thisTrialN'
p187
I20
sg48
g68
sg20
I0
sg19
S'down'
p188
sg27
g31
sg49
g59
sg46
g61
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p189
I47
sg25
g26
sS'task1.thisRepN'
p190
I0
sS'task1.thisN'
p191
I20
sg50
g61
sa(dp192
g45
g59
sg35
g36
sg21
F0.64514457772588685
sS'task1.thisTrialN'
p193
I21
sg48
g68
sg20
I0
sg19
S'up'
p194
sg27
g31
sg49
g61
sg46
g68
sg32
g11
sg33
g34
sg47
g122
sS'task1.thisIndex'
p195
I5
sg25
g26
sS'task1.thisRepN'
p196
I0
sS'task1.thisN'
p197
I21
sg50
g63
sa(dp198
g45
g68
sg35
g36
sg21
F0.56750735271475605
sS'task1.thisTrialN'
p199
I22
sg48
g63
sg20
I0
sg19
S'left'
p200
sg27
g31
sg49
g59
sg46
g68
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p201
I27
sg25
g26
sS'task1.thisRepN'
p202
I0
sS'task1.thisN'
p203
I22
sg50
g61
sa(dp204
g45
g68
sg35
g36
sg21
F0.4058615123240088
sS'task1.thisTrialN'
p205
I23
sg48
g59
sg20
I0
sg19
S'right'
p206
sg27
g31
sg49
g61
sg46
g68
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p207
I29
sg25
g26
sS'task1.thisRepN'
p208
I0
sS'task1.thisN'
p209
I23
sg50
g63
sa(dp210
g45
g68
sg35
g36
sg21
F0.9341341761366948
sS'task1.thisTrialN'
p211
I24
sg48
g63
sg20
I0
sg19
S'down'
p212
sg27
g31
sg49
g61
sg46
g59
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p213
I42
sg25
g26
sS'task1.thisRepN'
p214
I0
sS'task1.thisN'
p215
I24
sg50
g59
sa(dp216
g45
g68
sg35
g36
sg21
F0.9022887730588991
sS'task1.thisTrialN'
p217
I25
sg48
g63
sg20
I0
sg19
S'up'
p218
sg27
g31
sg49
g59
sg46
g63
sg32
g11
sg33
g34
sg47
g122
sS'task1.thisIndex'
p219
I1
sg25
g26
sS'task1.thisRepN'
p220
I0
sS'task1.thisN'
p221
I25
sg50
g61
sa(dp222
g45
g59
sg35
g36
sg21
F0.43832766160585379
sS'task1.thisTrialN'
p223
I26
sg48
g61
sg20
I0
sg19
S'right'
p224
sg27
g31
sg49
g68
sg46
g61
sg32
g11
sg33
g34
sg47
g122
sS'task1.thisIndex'
p225
I11
sg25
g26
sS'task1.thisRepN'
p226
I0
sS'task1.thisN'
p227
I26
sg50
g63
sa(dp228
g45
g68
sg35
g36
sg21
F0.61503533922586939
sS'task1.thisTrialN'
p229
I27
sg48
g61
sg20
I0
sg19
S'down'
p230
sg27
g31
sg49
g59
sg46
g59
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p231
I18
sg25
g26
sS'task1.thisRepN'
p232
I0
sS'task1.thisN'
p233
I27
sg50
g63
sa(dp234
g45
g59
sg35
g36
sg21
F0.1988415303912916
sS'task1.thisTrialN'
p235
I28
sg48
g68
sg20
I1
sg19
S'up'
p236
sg27
g31
sg49
g61
sg46
g59
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p237
I32
sg25
g26
sS'task1.thisRepN'
p238
I0
sS'task1.thisN'
p239
I28
sg50
g63
sa(dp240
g45
g59
sg35
g36
sg21
F0.48512230143819579
sS'task1.thisTrialN'
p241
I29
sg48
g63
sg20
I1
sg19
S'right'
p242
sg27
g31
sg49
g61
sg46
g68
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p243
I40
sg25
g26
sS'task1.thisRepN'
p244
I0
sS'task1.thisN'
p245
I29
sg50
g68
sa(dp246
g45
g63
sg35
g36
sg21
F0.68989027388533941
sS'task1.thisTrialN'
p247
I30
sg48
g68
sg20
I0
sg19
S'down'
p248
sg27
g31
sg49
g59
sg46
g59
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p249
I20
sg25
g26
sS'task1.thisRepN'
p250
I0
sS'task1.thisN'
p251
I30
sg50
g61
sa(dp252
g45
g59
sg35
g36
sg21
F0.58269622637635621
sS'task1.thisTrialN'
p253
I31
sg48
g61
sg20
I0
sg19
S'up'
p254
sg27
g31
sg49
g68
sg46
g68
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p255
I16
sg25
g26
sS'task1.thisRepN'
p256
I0
sS'task1.thisN'
p257
I31
sg50
g63
sa(dp258
g45
g61
sg35
g36
sg21
F0.89908110313831457
sS'task1.thisTrialN'
p259
I32
sg48
g63
sg20
I0
sg19
S'right'
p260
sg27
g31
sg49
g68
sg46
g68
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p261
I15
sg25
g26
sS'task1.thisRepN'
p262
I0
sS'task1.thisN'
p263
I32
sg50
g59
sa(dp264
g45
g59
sg35
g36
sg21
F0.72592916243229411
sS'task1.thisTrialN'
p265
I33
sg48
g68
sg20
I0
sg19
S'down'
p266
sg27
g31
sg49
g61
sg46
g61
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p267
I22
sg25
g26
sS'task1.thisRepN'
p268
I0
sS'task1.thisN'
p269
I33
sg50
g63
sa(dp270
g45
g61
sg35
g36
sg21
F0.66157301900170751
sS'task1.thisTrialN'
p271
I34
sg48
g63
sg20
I1
sg19
S'left'
p272
sg27
g31
sg49
g59
sg46
g59
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p273
I19
sg25
g26
sS'task1.thisRepN'
p274
I0
sS'task1.thisN'
p275
I34
sg50
g68
sa(dp276
g45
g59
sg35
g36
sg21
F0.83579963659894929
sS'task1.thisTrialN'
p277
I35
sg48
g63
sg20
I1
sg19
S'up'
p278
sg27
g31
sg49
g68
sg46
g59
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p279
I31
sg25
g26
sS'task1.thisRepN'
p280
I0
sS'task1.thisN'
p281
I35
sg50
g61
sa(dp282
g45
g59
sg35
g36
sg21
F0.78870152084414258
sS'task1.thisTrialN'
p283
I36
sg48
g68
sg20
I0
sg19
S'down'
p284
sg27
g31
sg49
g61
sg46
g63
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p285
I38
sg25
g26
sS'task1.thisRepN'
p286
I0
sS'task1.thisN'
p287
I36
sg50
g63
sa(dp288
g45
g68
sg35
g36
sg21
F0.59924368410793249
sS'task1.thisTrialN'
p289
I37
sg48
g59
sg20
I0
sg19
S'down'
p290
sg27
g31
sg49
g63
sg46
g63
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p291
I12
sg25
g26
sS'task1.thisRepN'
p292
I0
sS'task1.thisN'
p293
I37
sg50
g61
sa(dp294
g45
g59
sg35
g36
sg21
F0.77332113013676462
sS'task1.thisTrialN'
p295
I38
sg48
g63
sg20
I0
sg19
S'right'
p296
sg27
g31
sg49
g61
sg46
g63
sg32
g11
sg33
g34
sg47
g122
sS'task1.thisIndex'
p297
I0
sg25
g26
sS'task1.thisRepN'
p298
I0
sS'task1.thisN'
p299
I38
sg50
g68
sa(dp300
g45
g63
sg35
g36
sg21
F1.4467470332501762
sS'task1.thisTrialN'
p301
I39
sg48
g61
sg20
I1
sg19
S'down'
p302
sg27
g31
sg49
g59
sg46
g61
sg32
g11
sg33
g34
sg47
g122
sS'task1.thisIndex'
p303
I9
sg25
g26
sS'task1.thisRepN'
p304
I0
sS'task1.thisN'
p305
I39
sg50
g68
sa(dp306
g45
g61
sg35
g36
sg21
F0.38822430014488418
sS'task1.thisTrialN'
p307
I40
sg48
g63
sg20
I0
sg19
S'left'
p308
sg27
g31
sg49
g59
sg46
g61
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p309
I33
sg25
g26
sS'task1.thisRepN'
p310
I0
sS'task1.thisN'
p311
I40
sg50
g68
sa(dp312
g45
g61
sg35
g36
sg21
F0.4388515264902253
sS'task1.thisTrialN'
p313
I41
sg48
g59
sg20
I0
sg19
S'right'
p314
sg27
g31
sg49
g63
sg46
g59
sg32
g11
sg33
g34
sg47
g122
sS'task1.thisIndex'
p315
I6
sg25
g26
sS'task1.thisRepN'
p316
I0
sS'task1.thisN'
p317
I41
sg50
g68
sa(dp318
g45
g63
sg35
g36
sg21
F0.77033801956599746
sS'task1.thisTrialN'
p319
I42
sg48
g61
sg20
I1
sg19
S'up'
p320
sg27
g31
sg49
g68
sg46
g63
sg32
g11
sg33
g34
sg47
g72
sS'task1.thisIndex'
p321
I26
sg25
g26
sS'task1.thisRepN'
p322
I0
sS'task1.thisN'
p323
I42
sg50
g59
sa(dp324
g45
g68
sg35
g36
sg21
F0.80838543110280625
sS'task1.thisTrialN'
p325
I43
sg48
g63
sg20
I0
sg19
S'down'
p326
sg27
g31
sg49
g61
sg46
g61
sg32
g11
sg33
g34
sg47
g64
sS'task1.thisIndex'
p327
I21
sg25
g26
sS'task1.thisRepN'
p328
I0
sS'task1.thisN'
p329
I43
sg50
g59
sa(dp330
g45
g59
sg35
g36
sg21
F0.11593453902446527
sS'task1.thisTrialN'
p331
I44
sg48
g63
sg20
I0
sg19
S'up'
p332
sg27
g31
sg49
g68
sg46
g61
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p333
I46
sg25
g26
sS'task1.thisRepN'
p334
I0
sS'task1.thisN'
p335
I44
sg50
g61
sa(dp336
g45
g61
sg35
g36
sg21
F2.1023201472082746
sS'task1.thisTrialN'
p337
I45
sg48
g59
sg20
I0
sg19
S'left'
p338
sg27
g31
sg49
g63
sg46
g68
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p339
I39
sg25
g26
sS'task1.thisRepN'
p340
I0
sS'task1.thisN'
p341
I45
sg50
g68
sa(dp342
g45
g61
sg35
g36
sg21
F0.5654738073972112
sS'task1.thisTrialN'
p343
I46
sg48
g68
sg20
I1
sg19
S'right'
p344
sg27
g31
sg49
g63
sg46
g59
sg32
g11
sg33
g34
sg47
g79
sS'task1.thisIndex'
p345
I43
sg25
g26
sS'task1.thisRepN'
p346
I0
sS'task1.thisN'
p347
I46
sg50
g59
sa(dp348
g45
g63
sg35
g36
sg21
F0.82430059386319954
sS'task1.thisTrialN'
p349
I47
sg48
g68
sg20
I1
sg19
S'down'
p350
sg27
g31
sg49
g59
sg46
g68
sg32
g11
sg33
g34
sg47
g122
sS'task1.thisIndex'
p351
I3
sg25
g26
sS'task1.thisRepN'
p352
I0
sS'task1.thisN'
p353
I47
sg50
g61
sasS'loops'
p354
(lp355
g1
(cpsychopy.data
TrialHandler
p356
g3
NtRp357
(dp358
S'origin'
p359
Vfrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a smaller size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()
p360
sS'thisTrial'
p361
(lp362
sS'_exp'
p363
L541638160L
sg10
S'task2'
p364
sg6
S'C:/Users/Eyetracking/Documents/adamant-squeegee/Brook/VWM_task/VWMtask_b.py'
p365
sS'thisRepN'
p366
I1
sg22
I01
sg23
g24
sS'data'
p367
g1
(cpsychopy.data
DataHandler
p368
c__builtin__
dict
p369
(dp370
S'ran'
p371
cnumpy.ma.core
_mareconstruct
p372
(cnumpy.ma.core
MaskedArray
p373
cnumpy
ndarray
p374
(I0
tp375
S'b'
tRp376
(I1
(L48L
L1L
tg29
(S'f4'
I0
I1
tRp377
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
g372
(g373
g374
g375
S'b'
tRp378
(I1
(L48L
L1L
tg377
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p379
g372
(g373
g374
g375
S'b'
tRp380
(I1
(L48L
L1L
tg377
I00
S'\x00\x00@@\x00\x00\x08B\x00\x00PA\x00\x00\xc0@\x00\x00\xe0@\x00\x00(B\x00\x00\xb0A\x00\x00\xc0A\x00\x00\xe8A\x00\x004B\x00\x00\x00@\x00\x00\x10A\x00\x00\xe0A\x00\x00\x80?\x00\x008B\x00\x00\x14B\x00\x00<B\x00\x00\x88A\x00\x00$B\x00\x000A\x00\x00\xf0A\x00\x00\x04B\x00\x00 B\x00\x00,B\x00\x00\xa0@\x00\x00\x80@\x00\x00\xc8A\x00\x00\xf8A\x00\x00\xd8A\x00\x00\x00B\x00\x00 A\x00\x00\x80A\x00\x00\x0cB\x00\x000B\x00\x00\x00A\x00\x00\xb8A\x00\x00\xd0A\x00\x00@A\x00\x00\x00\x00\x00\x00`A\x00\x00\x98A\x00\x00\x18B\x00\x00pA\x00\x00\x90A\x00\x00\xa8A\x00\x00\x10B\x00\x00\x1cB\x00\x00\xa0A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg18
g372
(g373
g374
g375
S'b'
tRp381
(I1
(L48L
L1L
tg377
I00
S"\xa5\xa6\x0c?\xf5\x1f\x1b?\xe5b\t@\xe69\xa0>\xb8\xd0\xca>\x13\x0c\xd6>1\xcf ?ek^?\x92\x97D?\n\xe6Z?q\x98m?\x89\x17\x19?o\x8c\xcb?Z\xde{?\xce\xb2\xec@\xb6\xd2\x1c?\xccR>?\x1aI\x00?7\x03\xd8>4\xa0\xf0>\x8fGb?\x00@;?,\x92\x07?\xd7E\xd1?\x9a\x05\xf9>z\x91\n@jcW?\xf7\xc9\x8d?t\xba\x87?\x86e\x18?\xb7\xc4\x12?9\xd1\x0f?@a\xf7>\t\x8f\x12A\x1ch\xa4?e\xc2Y?<\xc5)?\xb5\xb1\xaf><\x9b\xea>+\xc2\x80?Gj\xe8>'\xfd\xce>p\x00\xf2><\xf34?\xf4t=?\x1a\x02\xf0>tI(@\xa8\xf63?"
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg16
cnumpy.core.multiarray
_reconstruct
p382
(g374
(I0
tS'b'
tRp383
(I1
(L48L
L1L
tg29
(S'O8'
I0
I1
tRp384
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp385
S'down'
p386
aS'down'
p387
aS'down'
p388
aS'up'
p389
aS'up'
p390
aS'left'
p391
aS'down'
p392
aS'down'
p393
aS'down'
p394
aS'down'
p395
aS'up'
p396
aS'down'
p397
aS'left'
p398
aS'left'
p399
aS'down'
p400
aS'right'
p401
ag57
aS'down'
p402
aS'up'
p403
aS'down'
p404
aS'right'
p405
aS'up'
p406
aS'down'
p407
aS'right'
p408
aS'down'
p409
aS'down'
p410
aS'up'
p411
aS'down'
p412
aS'up'
p413
aS'down'
p414
aS'up'
p415
aS'down'
p416
aS'right'
p417
aS'left'
p418
aS'down'
p419
aS'right'
p420
aS'right'
p421
aS'right'
p422
aS'down'
p423
aS'down'
p424
aS'up'
p425
aS'down'
p426
aS'down'
p427
aS'right'
p428
aS'right'
p429
aS'left'
p430
aS'up'
p431
aS'left'
p432
atbstRp433
(dp434
S'isNumeric'
p435
(dp436
g371
I01
sg18
I01
sg17
I01
sg379
I01
sg16
I00
ssS'trials'
p437
g357
sS'dataTypes'
p438
(lp439
g371
ag379
ag16
ag17
ag18
asS'dataShape'
p440
(lp441
L48L
aI1
asbsS'method'
p442
S'fullRandom'
p443
sS'sequenceIndices'
p444
g382
(g374
(I0
tS'b'
tRp445
(I1
(L48L
L1L
tg384
I00
(lp446
I38
aI13
aI10
aI0
aI25
aI24
aI3
aI4
aI34
aI11
aI30
aI19
aI37
aI2
aI39
aI42
aI31
aI17
aI43
aI40
aI47
aI44
aI6
aI35
aI7
aI26
aI36
aI28
aI12
aI8
aI20
aI27
aI29
aI21
aI1
aI32
aI45
aI15
aI41
aI46
aI22
aI18
aI5
aI23
aI33
aI9
aI14
aI16
atbsS'finished'
p447
I01
sS'nReps'
p448
I1
sS'nRemaining'
p449
I-1
sS'trialList'
p450
(lp451
g1
(cpsychopy.data
TrialType
p452
g369
(dp453
Vdownbox
p454
Vyellow
p455
sVtargettest
p456
Vgreen
p457
sVcorrAns
p458
Vdown
p459
sVupbox
p460
g457
sVrightbox
p461
Vblue
p462
sVleftbox
p463
Vred
p464
stRp465
ag1
(g452
g369
(dp466
g454
g464
sg456
g457
sg458
g459
sg460
g457
sg461
g455
sg463
g462
stRp467
ag1
(g452
g369
(dp468
g454
g462
sg456
g457
sg458
g459
sg460
g457
sg461
g464
sg463
g455
stRp469
ag1
(g452
g369
(dp470
g454
g457
sg456
g464
sg458
g459
sg460
g464
sg461
g455
sg463
g462
stRp471
ag1
(g452
g369
(dp472
g454
g462
sg456
g464
sg458
g459
sg460
g464
sg461
g457
sg463
g455
stRp473
ag1
(g452
g369
(dp474
g454
g455
sg456
g464
sg458
g459
sg460
g464
sg461
g462
sg463
g457
stRp475
ag1
(g452
g369
(dp476
g454
g462
sg456
g455
sg458
g459
sg460
g455
sg461
g457
sg463
g464
stRp477
ag1
(g452
g369
(dp478
g454
g457
sg456
g455
sg458
g459
sg460
g455
sg461
g464
sg463
g462
stRp479
ag1
(g452
g369
(dp480
g454
g464
sg456
g455
sg458
g459
sg460
g455
sg461
g462
sg463
g457
stRp481
ag1
(g452
g369
(dp482
g454
g457
sg456
g462
sg458
g459
sg460
g462
sg461
g455
sg463
g464
stRp483
ag1
(g452
g369
(dp484
g454
g464
sg456
g462
sg458
g459
sg460
g462
sg461
g457
sg463
g455
stRp485
ag1
(g452
g369
(dp486
g454
g455
sg456
g462
sg458
g459
sg460
g462
sg461
g464
sg463
g457
stRp487
ag1
(g452
g369
(dp488
g454
g464
sg456
g457
sg458
Vleft
p489
sg460
g455
sg461
g457
sg463
g462
stRp490
ag1
(g452
g369
(dp491
g454
g462
sg456
g457
sg458
g489
sg460
g464
sg461
g457
sg463
g455
stRp492
ag1
(g452
g369
(dp493
g454
g455
sg456
g457
sg458
g489
sg460
g462
sg461
g457
sg463
g464
stRp494
ag1
(g452
g369
(dp495
g454
g462
sg456
g464
sg458
g489
sg460
g457
sg461
g464
sg463
g455
stRp496
ag1
(g452
g369
(dp497
g454
g455
sg456
g464
sg458
g489
sg460
g462
sg461
g464
sg463
g457
stRp498
ag1
(g452
g369
(dp499
g454
g457
sg456
g464
sg458
g489
sg460
g455
sg461
g464
sg463
g462
stRp500
ag1
(g452
g369
(dp501
g454
g464
sg456
g455
sg458
g489
sg460
g462
sg461
g455
sg463
g457
stRp502
ag1
(g452
g369
(dp503
g454
g462
sg456
g455
sg458
g489
sg460
g457
sg461
g455
sg463
g464
stRp504
ag1
(g452
g369
(dp505
g454
g457
sg456
g455
sg458
g489
sg460
g464
sg461
g455
sg463
g462
stRp506
ag1
(g452
g369
(dp507
g454
g464
sg456
g462
sg458
g489
sg460
g457
sg461
g462
sg463
g455
stRp508
ag1
(g452
g369
(dp509
g454
g455
sg456
g462
sg458
g489
sg460
g464
sg461
g462
sg463
g457
stRp510
ag1
(g452
g369
(dp511
g454
g457
sg456
g462
sg458
g489
sg460
g455
sg461
g462
sg463
g464
stRp512
ag1
(g452
g369
(dp513
g454
g457
sg456
g457
sg458
Vup
p514
sg460
g455
sg461
g462
sg463
g464
stRp515
ag1
(g452
g369
(dp516
g454
g457
sg456
g457
sg458
g514
sg460
g464
sg461
g455
sg463
g462
stRp517
ag1
(g452
g369
(dp518
g454
g457
sg456
g457
sg458
g514
sg460
g462
sg461
g464
sg463
g455
stRp519
ag1
(g452
g369
(dp520
g454
g464
sg456
g464
sg458
g514
sg460
g457
sg461
g455
sg463
g462
stRp521
ag1
(g452
g369
(dp522
g454
g464
sg456
g464
sg458
g514
sg460
g462
sg461
g457
sg463
g455
stRp523
ag1
(g452
g369
(dp524
g454
g464
sg456
g464
sg458
g514
sg460
g455
sg461
g462
sg463
g457
stRp525
ag1
(g452
g369
(dp526
g454
g455
sg456
g455
sg458
g514
sg460
g462
sg461
g457
sg463
g464
stRp527
ag1
(g452
g369
(dp528
g454
g455
sg456
g455
sg458
g514
sg460
g457
sg461
g464
sg463
g462
stRp529
ag1
(g452
g369
(dp530
g454
g455
sg456
g455
sg458
g514
sg460
g464
sg461
g462
sg463
g457
stRp531
ag1
(g452
g369
(dp532
g454
g462
sg456
g462
sg458
g514
sg460
g457
sg461
g455
sg463
g464
stRp533
ag1
(g452
g369
(dp534
g454
g462
sg456
g462
sg458
g514
sg460
g464
sg461
g457
sg463
g455
stRp535
ag1
(g452
g369
(dp536
g454
g462
sg456
g462
sg458
g514
sg460
g455
sg461
g464
sg463
g457
stRp537
ag1
(g452
g369
(dp538
g454
g464
sg456
g457
sg458
Vright
p539
sg460
g462
sg461
g455
sg463
g457
stRp540
ag1
(g452
g369
(dp541
g454
g462
sg456
g457
sg458
g539
sg460
g455
sg461
g464
sg463
g457
stRp542
ag1
(g452
g369
(dp543
g454
g455
sg456
g457
sg458
g539
sg460
g464
sg461
g462
sg463
g457
stRp544
ag1
(g452
g369
(dp545
g454
g462
sg456
g464
sg458
g539
sg460
g455
sg461
g457
sg463
g464
stRp546
ag1
(g452
g369
(dp547
g454
g455
sg456
g464
sg458
g539
sg460
g457
sg461
g462
sg463
g464
stRp548
ag1
(g452
g369
(dp549
g454
g457
sg456
g464
sg458
g539
sg460
g462
sg461
g455
sg463
g464
stRp550
ag1
(g452
g369
(dp551
g454
g464
sg456
g455
sg458
g539
sg460
g457
sg461
g462
sg463
g455
stRp552
ag1
(g452
g369
(dp553
g454
g462
sg456
g455
sg458
g539
sg460
g464
sg461
g457
sg463
g455
stRp554
ag1
(g452
g369
(dp555
g454
g457
sg456
g455
sg458
g539
sg460
g462
sg461
g464
sg463
g455
stRp556
ag1
(g452
g369
(dp557
g454
g464
sg456
g462
sg458
g539
sg460
g455
sg461
g457
sg463
g462
stRp558
ag1
(g452
g369
(dp559
g454
g455
sg456
g462
sg458
g539
sg460
g457
sg461
g464
sg463
g462
stRp560
ag1
(g452
g369
(dp561
g454
g457
sg456
g462
sg458
g539
sg460
g464
sg461
g455
sg463
g462
stRp562
asS'seed'
p563
NsS'thisIndex'
p564
I16
sS'thisN'
p565
I48
sS'thisTrialN'
p566
I0
sS'nTotal'
p567
I48
sS'_warnUseOfNext'
p568
I01
sbag1
(g356
g3
NtRp569
(dp570
g359
Vfrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a smaller size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    \u000a    # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()
p571
sg361
(lp572
sg363
L541638160L
sg10
S'task1'
p573
sg6
g365
sg366
I1
sg22
I01
sg23
g24
sg367
g1
(g368
g369
(dp574
g371
g372
(g373
g374
g375
S'b'
tRp575
(I1
(L48L
L1L
tg377
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g372
(g373
g374
g375
S'b'
tRp576
(I1
(L48L
L1L
tg377
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g382
(g374
(I0
tS'b'
tRp577
(I1
(L48L
L1L
tg384
I00
(lp578
g296
ag218
ag182
ag350
ag152
ag194
ag314
ag140
ag121
ag302
ag164
ag224
ag290
ag91
ag62
ag260
ag254
ag158
ag230
ag272
ag248
ag326
ag266
ag103
ag146
ag170
ag320
ag200
ag115
ag206
ag128
ag278
ag236
ag308
ag85
ag71
ag176
ag134
ag284
ag338
ag242
ag78
ag212
ag344
ag109
ag97
ag332
ag188
atbsg21
g372
(g373
g374
g375
S'b'
tRp579
(I1
(L48L
L1L
tg377
I00
S'`\xf8E?f\xfcf?\xbf\xab\xc8>]\x05S?\x0cVR?2(%?&\xb1\xe0>\xf4\xb5\xcc><\xe39>\x02/\xb9?\xb3\x80\xb7>|l\xe0>\th\x19?"\x04\x1c@M\xad0?.*f?\x94+\x15?\x00S\x15?\xf5r\x1d?\xd9\\)?\xa6\x9c0?Y\xf2N?~\xd69?\xfd\x1c\r?\xcb\xea\xe0>\xfe\xcd\xe0>\xdf4E?)H\x11?D>\xf7>\x15\xcd\xcf>\x04w\xd8>\xf7\xf6U?\x1d\x9dK>V\xc5\xc6>1\xaf\xa8?2",?\x83\xedf?\x95b\x00?X\xe8I?j\x8c\x06@\xf3a\xf8>\\\xde\xb4?k#o?\xe4\xc2\x10?m\xb2j?\x02\xa97@\x16o\xed=Q\xfeL='
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg379
g372
(g373
g374
g375
S'b'
tRp580
(I1
(L48L
L1L
tg377
I00
S'\x00\x00\x18B\x00\x00\xc8A\x00\x00\x98A\x00\x00<B\x00\x00`A\x00\x00\xa8A\x00\x00$B\x00\x00@A\x00\x00\x10A\x00\x00\x1cB\x00\x00\x80A\x00\x00\xd0A\x00\x00\x14B\x00\x00\x80@\x00\x00\x00\x00\x00\x00\x00B\x00\x00\xf8A\x00\x00pA\x00\x00\xd8A\x00\x00\x08B\x00\x00\xf0A\x00\x00,B\x00\x00\x04B\x00\x00\xc0@\x00\x00PA\x00\x00\x88A\x00\x00(B\x00\x00\xb0A\x00\x00\x00A\x00\x00\xb8A\x00\x00 A\x00\x00\x0cB\x00\x00\xe0A\x00\x00 B\x00\x00@@\x00\x00\x80?\x00\x00\x90A\x00\x000A\x00\x00\x10B\x00\x004B\x00\x00\xe8A\x00\x00\x00@\x00\x00\xc0A\x00\x008B\x00\x00\xe0@\x00\x00\xa0@\x00\x000B\x00\x00\xa0A'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp581
(dp582
g435
(dp583
g371
I01
sg20
I01
sg19
I00
sg21
I01
sg379
I01
ssg437
g569
sg438
(lp584
g371
ag379
ag19
ag20
ag21
asg440
(lp585
L48L
aI1
asbsg442
g443
sg444
g382
(g374
(I0
tS'b'
tRp586
(I1
(L48L
L1L
tg384
I00
(lp587
I14
aI35
aI41
aI34
aI13
aI45
aI23
aI44
aI28
aI8
aI30
aI37
aI7
aI24
aI4
aI17
aI10
aI25
aI36
aI2
aI47
aI5
aI27
aI29
aI42
aI1
aI11
aI18
aI32
aI40
aI20
aI16
aI15
aI22
aI19
aI31
aI38
aI12
aI0
aI9
aI33
aI6
aI26
aI21
aI46
aI39
aI43
aI3
atbsg447
I01
sg448
I1
sg449
I-1
sg450
(lp588
g1
(g452
g369
(dp589
g45
g59
sg46
g63
sg47
g122
sg48
g63
sg49
g61
sg50
g68
stRp590
ag1
(g452
g369
(dp591
g45
g68
sg46
g63
sg47
g122
sg48
g63
sg49
g59
sg50
g61
stRp592
ag1
(g452
g369
(dp593
g45
g61
sg46
g63
sg47
g122
sg48
g63
sg49
g68
sg50
g59
stRp594
ag1
(g452
g369
(dp595
g45
g63
sg46
g68
sg47
g122
sg48
g68
sg49
g59
sg50
g61
stRp596
ag1
(g452
g369
(dp597
g45
g61
sg46
g68
sg47
g122
sg48
g68
sg49
g63
sg50
g59
stRp598
ag1
(g452
g369
(dp599
g45
g59
sg46
g68
sg47
g122
sg48
g68
sg49
g61
sg50
g63
stRp600
ag1
(g452
g369
(dp601
g45
g61
sg46
g59
sg47
g122
sg48
g59
sg49
g63
sg50
g68
stRp602
ag1
(g452
g369
(dp603
g45
g63
sg46
g59
sg47
g122
sg48
g59
sg49
g68
sg50
g61
stRp604
ag1
(g452
g369
(dp605
g45
g68
sg46
g59
sg47
g122
sg48
g59
sg49
g61
sg50
g63
stRp606
ag1
(g452
g369
(dp607
g45
g63
sg46
g61
sg47
g122
sg48
g61
sg49
g59
sg50
g68
stRp608
ag1
(g452
g369
(dp609
g45
g68
sg46
g61
sg47
g122
sg48
g61
sg49
g63
sg50
g59
stRp610
ag1
(g452
g369
(dp611
g45
g59
sg46
g61
sg47
g122
sg48
g61
sg49
g68
sg50
g63
stRp612
ag1
(g452
g369
(dp613
g45
g68
sg46
g63
sg47
g64
sg48
g59
sg49
g63
sg50
g61
stRp614
ag1
(g452
g369
(dp615
g45
g61
sg46
g63
sg47
g64
sg48
g68
sg49
g63
sg50
g59
stRp616
ag1
(g452
g369
(dp617
g45
g59
sg46
g63
sg47
g64
sg48
g61
sg49
g63
sg50
g68
stRp618
ag1
(g452
g369
(dp619
g45
g61
sg46
g68
sg47
g64
sg48
g63
sg49
g68
sg50
g59
stRp620
ag1
(g452
g369
(dp621
g45
g59
sg46
g68
sg47
g64
sg48
g61
sg49
g68
sg50
g63
stRp622
ag1
(g452
g369
(dp623
g45
g63
sg46
g68
sg47
g64
sg48
g59
sg49
g68
sg50
g61
stRp624
ag1
(g452
g369
(dp625
g45
g68
sg46
g59
sg47
g64
sg48
g61
sg49
g59
sg50
g63
stRp626
ag1
(g452
g369
(dp627
g45
g61
sg46
g59
sg47
g64
sg48
g63
sg49
g59
sg50
g68
stRp628
ag1
(g452
g369
(dp629
g45
g63
sg46
g59
sg47
g64
sg48
g68
sg49
g59
sg50
g61
stRp630
ag1
(g452
g369
(dp631
g45
g68
sg46
g61
sg47
g64
sg48
g63
sg49
g61
sg50
g59
stRp632
ag1
(g452
g369
(dp633
g45
g59
sg46
g61
sg47
g64
sg48
g68
sg49
g61
sg50
g63
stRp634
ag1
(g452
g369
(dp635
g45
g63
sg46
g61
sg47
g64
sg48
g59
sg49
g61
sg50
g68
stRp636
ag1
(g452
g369
(dp637
g45
g63
sg46
g63
sg47
g72
sg48
g59
sg49
g61
sg50
g68
stRp638
ag1
(g452
g369
(dp639
g45
g63
sg46
g63
sg47
g72
sg48
g68
sg49
g59
sg50
g61
stRp640
ag1
(g452
g369
(dp641
g45
g63
sg46
g63
sg47
g72
sg48
g61
sg49
g68
sg50
g59
stRp642
ag1
(g452
g369
(dp643
g45
g68
sg46
g68
sg47
g72
sg48
g63
sg49
g59
sg50
g61
stRp644
ag1
(g452
g369
(dp645
g45
g68
sg46
g68
sg47
g72
sg48
g61
sg49
g63
sg50
g59
stRp646
ag1
(g452
g369
(dp647
g45
g68
sg46
g68
sg47
g72
sg48
g59
sg49
g61
sg50
g63
stRp648
ag1
(g452
g369
(dp649
g45
g59
sg46
g59
sg47
g72
sg48
g61
sg49
g63
sg50
g68
stRp650
ag1
(g452
g369
(dp651
g45
g59
sg46
g59
sg47
g72
sg48
g63
sg49
g68
sg50
g61
stRp652
ag1
(g452
g369
(dp653
g45
g59
sg46
g59
sg47
g72
sg48
g68
sg49
g61
sg50
g63
stRp654
ag1
(g452
g369
(dp655
g45
g61
sg46
g61
sg47
g72
sg48
g63
sg49
g59
sg50
g68
stRp656
ag1
(g452
g369
(dp657
g45
g61
sg46
g61
sg47
g72
sg48
g68
sg49
g63
sg50
g59
stRp658
ag1
(g452
g369
(dp659
g45
g61
sg46
g61
sg47
g72
sg48
g59
sg49
g68
sg50
g63
stRp660
ag1
(g452
g369
(dp661
g45
g68
sg46
g63
sg47
g79
sg48
g61
sg49
g59
sg50
g63
stRp662
ag1
(g452
g369
(dp663
g45
g61
sg46
g63
sg47
g79
sg48
g59
sg49
g68
sg50
g63
stRp664
ag1
(g452
g369
(dp665
g45
g59
sg46
g63
sg47
g79
sg48
g68
sg49
g61
sg50
g63
stRp666
ag1
(g452
g369
(dp667
g45
g61
sg46
g68
sg47
g79
sg48
g59
sg49
g63
sg50
g68
stRp668
ag1
(g452
g369
(dp669
g45
g59
sg46
g68
sg47
g79
sg48
g63
sg49
g61
sg50
g68
stRp670
ag1
(g452
g369
(dp671
g45
g63
sg46
g68
sg47
g79
sg48
g61
sg49
g59
sg50
g68
stRp672
ag1
(g452
g369
(dp673
g45
g68
sg46
g59
sg47
g79
sg48
g63
sg49
g61
sg50
g59
stRp674
ag1
(g452
g369
(dp675
g45
g61
sg46
g59
sg47
g79
sg48
g68
sg49
g63
sg50
g59
stRp676
ag1
(g452
g369
(dp677
g45
g63
sg46
g59
sg47
g79
sg48
g61
sg49
g68
sg50
g59
stRp678
ag1
(g452
g369
(dp679
g45
g68
sg46
g61
sg47
g79
sg48
g59
sg49
g63
sg50
g61
stRp680
ag1
(g452
g369
(dp681
g45
g59
sg46
g61
sg47
g79
sg48
g63
sg49
g68
sg50
g61
stRp682
ag1
(g452
g369
(dp683
g45
g63
sg46
g61
sg47
g79
sg48
g68
sg49
g59
sg50
g61
stRp684
asg563
Nsg564
I3
sg565
I48
sg566
I0
sg567
I48
sg568
I01
sbasS'savePickle'
p685
I00
sb.