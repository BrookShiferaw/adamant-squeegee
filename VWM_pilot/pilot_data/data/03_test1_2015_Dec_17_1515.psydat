ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
VC:\u005cUsers\u005cEyetracking\u005cDocuments\u005cadamant-squeegee\u005cBrook\u005cVWM_task\u005cdata/03_test1_2015_Dec_17_1515
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'test1'
p11
sS'dataNames'
p12
(lp13
S'start.keys'
p14
aS'start.rt'
p15
aS'answer1.keys'
p16
aS'answer1.corr'
p17
aS'answer1.rt'
p18
aS'answer2.keys'
p19
aS'answer2.corr'
p20
aS'answer2.rt'
p21
asS'autoLog'
p22
I01
sS'extraInfo'
p23
(dp24
S'date'
p25
V2015_Dec_17_1515
p26
sS'frameRate'
p27
cnumpy.core.multiarray
scalar
p28
(cnumpy
dtype
p29
(S'f8'
I0
I1
tRp30
(I3
S'<'
NNNI-1
I-1
I0
tbS'1\x87i\xfd#\xc6q@'
tRp31
sS'expName'
p32
g11
sS'session'
p33
V02
p34
sS'participant'
p35
V03
p36
ssS'loopsUnfinished'
p37
(lp38
sS'saveWideText'
p39
I01
sS'thisEntry'
p40
(dp41
sS'version'
p42
S''
sS'_paramNamesSoFar'
p43
(lp44
Vdownbox
p45
aVtargettest
p46
aVcorrAns
p47
aVupbox
p48
aVrightbox
p49
aVleftbox
p50
asS'entries'
p51
(lp52
(dp53
g15
F2.824955344769478
sg32
g11
sg14
S'return'
p54
sg33
g34
sg25
g26
sg35
g36
sg27
g31
sa(dp55
g45
Vgreen
p56
sg35
g36
sg18
F1.3567731591265328
sS'task1.thisTrialN'
p57
I0
sg48
Vyellow
p58
sg17
I1
sg16
S'left'
p59
sg27
g31
sg49
Vblue
p60
sg46
g60
sg32
g11
sg33
g34
sg47
Vleft
p61
sS'task1.thisIndex'
p62
I23
sg25
g26
sS'task1.thisRepN'
p63
I0
sS'task1.thisN'
p64
I0
sg50
Vred
p65
sa(dp66
g45
g60
sg35
g36
sg18
F1.4265758292021928
sS'task1.thisTrialN'
p67
I1
sg48
g58
sg17
I1
sg16
S'right'
p68
sg27
g31
sg49
g56
sg46
g65
sg32
g11
sg33
g34
sg47
Vright
p69
sS'task1.thisIndex'
p70
I39
sg25
g26
sS'task1.thisRepN'
p71
I0
sS'task1.thisN'
p72
I1
sg50
g65
sa(dp73
g45
g65
sg35
g36
sg18
F0.99722990001282596
sS'task1.thisTrialN'
p74
I2
sg48
g60
sg17
I1
sg16
S'left'
p75
sg27
g31
sg49
g58
sg46
g58
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p76
I18
sg25
g26
sS'task1.thisRepN'
p77
I0
sS'task1.thisN'
p78
I2
sg50
g56
sa(dp79
g45
g56
sg35
g36
sg18
F1.1525351467462315
sS'task1.thisTrialN'
p80
I3
sg48
g65
sg17
I1
sg16
S'right'
p81
sg27
g31
sg49
g58
sg46
g60
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p82
I47
sg25
g26
sS'task1.thisRepN'
p83
I0
sS'task1.thisN'
p84
I3
sg50
g60
sa(dp85
g45
g65
sg35
g36
sg18
F1.7505360552495404
sS'task1.thisTrialN'
p86
I4
sg48
g58
sg17
I1
sg16
S'left'
p87
sg27
g31
sg49
g56
sg46
g56
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p88
I12
sg25
g26
sS'task1.thisRepN'
p89
I0
sS'task1.thisN'
p90
I4
sg50
g60
sa(dp91
g45
g56
sg35
g36
sg18
F1.2383986223594547
sS'task1.thisTrialN'
p92
I5
sg48
g60
sg17
I1
sg16
S'up'
p93
sg27
g31
sg49
g65
sg46
g56
sg32
g11
sg33
g34
sg47
Vup
p94
sS'task1.thisIndex'
p95
I26
sg25
g26
sS'task1.thisRepN'
p96
I0
sS'task1.thisN'
p97
I5
sg50
g58
sa(dp98
g45
g56
sg35
g36
sg18
F1.7162516168264119
sS'task1.thisTrialN'
p99
I6
sg48
g58
sg17
I1
sg16
S'up'
p100
sg27
g31
sg49
g60
sg46
g56
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p101
I24
sg25
g26
sS'task1.thisRepN'
p102
I0
sS'task1.thisN'
p103
I6
sg50
g65
sa(dp104
g45
g56
sg35
g36
sg18
F1.6038388100150769
sS'task1.thisTrialN'
p105
I7
sg48
g60
sg17
I1
sg16
S'right'
p106
sg27
g31
sg49
g58
sg46
g65
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p107
I41
sg25
g26
sS'task1.thisRepN'
p108
I0
sS'task1.thisN'
p109
I7
sg50
g65
sa(dp110
g45
g58
sg35
g36
sg18
F1.1448799184927339
sS'task1.thisTrialN'
p111
I8
sg48
g60
sg17
I1
sg16
S'down'
p112
sg27
g31
sg49
g65
sg46
g60
sg32
g11
sg33
g34
sg47
Vdown
p113
sS'task1.thisIndex'
p114
I11
sg25
g26
sS'task1.thisRepN'
p115
I0
sS'task1.thisN'
p116
I8
sg50
g56
sa(dp117
g45
g56
sg35
g36
sg18
F0.94539903555050842
sS'task1.thisTrialN'
p118
I9
sg48
g60
sg17
I1
sg16
S'down'
p119
sg27
g31
sg49
g58
sg46
g60
sg32
g11
sg33
g34
sg47
g113
sS'task1.thisIndex'
p120
I9
sg25
g26
sS'task1.thisRepN'
p121
I0
sS'task1.thisN'
p122
I9
sg50
g65
sa(dp123
g45
g65
sg35
g36
sg18
F1.6343006066963426
sS'task1.thisTrialN'
p124
I10
sg48
g60
sg17
I1
sg16
S'right'
p125
sg27
g31
sg49
g58
sg46
g56
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p126
I36
sg25
g26
sS'task1.thisRepN'
p127
I0
sS'task1.thisN'
p128
I10
sg50
g56
sa(dp129
g45
g56
sg35
g36
sg18
F0.64582852134662971
sS'task1.thisTrialN'
p130
I11
sg48
g60
sg17
I1
sg16
S'right'
p131
sg27
g31
sg49
g65
sg46
g58
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p132
I44
sg25
g26
sS'task1.thisRepN'
p133
I0
sS'task1.thisN'
p134
I11
sg50
g58
sa(dp135
g45
g56
sg35
g36
sg18
F1.2397745295802451
sS'task1.thisTrialN'
p136
I12
sg48
g58
sg17
I0
sg16
S'down'
p137
sg27
g31
sg49
g65
sg46
g65
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p138
I17
sg25
g26
sS'task1.thisRepN'
p139
I0
sS'task1.thisN'
p140
I12
sg50
g60
sa(dp141
g45
g56
sg35
g36
sg18
F1.3984587529375858
sS'task1.thisTrialN'
p142
I13
sg48
g58
sg17
I1
sg16
S'down'
p143
sg27
g31
sg49
g65
sg46
g58
sg32
g11
sg33
g34
sg47
g113
sS'task1.thisIndex'
p144
I7
sg25
g26
sS'task1.thisRepN'
p145
I0
sS'task1.thisN'
p146
I13
sg50
g60
sa(dp147
g45
g60
sg35
g36
sg18
F2.5028727556891681
sS'task1.thisTrialN'
p148
I14
sg48
g65
sg17
I1
sg16
S'down'
p149
sg27
g31
sg49
g56
sg46
g65
sg32
g11
sg33
g34
sg47
g113
sS'task1.thisIndex'
p150
I4
sg25
g26
sS'task1.thisRepN'
p151
I0
sS'task1.thisN'
p152
I14
sg50
g58
sa(dp153
g45
g65
sg35
g36
sg18
F0.74126528286797111
sS'task1.thisTrialN'
p154
I15
sg48
g58
sg17
I1
sg16
S'down'
p155
sg27
g31
sg49
g60
sg46
g58
sg32
g11
sg33
g34
sg47
g113
sS'task1.thisIndex'
p156
I8
sg25
g26
sS'task1.thisRepN'
p157
I0
sS'task1.thisN'
p158
I15
sg50
g56
sa(dp159
g45
g58
sg35
g36
sg18
F1.2220757239792874
sS'task1.thisTrialN'
p160
I16
sg48
g60
sg17
I1
sg16
S'up'
p161
sg27
g31
sg49
g56
sg46
g58
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p162
I30
sg25
g26
sS'task1.thisRepN'
p163
I0
sS'task1.thisN'
p164
I16
sg50
g65
sa(dp165
g45
g58
sg35
g36
sg18
F1.1771596835114906
sS'task1.thisTrialN'
p166
I17
sg48
g56
sg17
I1
sg16
S'up'
p167
sg27
g31
sg49
g65
sg46
g58
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p168
I31
sg25
g26
sS'task1.thisRepN'
p169
I0
sS'task1.thisN'
p170
I17
sg50
g60
sa(dp171
g45
g60
sg35
g36
sg18
F1.2344434906008246
sS'task1.thisTrialN'
p172
I18
sg48
g65
sg17
I1
sg16
S'left'
p173
sg27
g31
sg49
g56
sg46
g56
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p174
I13
sg25
g26
sS'task1.thisRepN'
p175
I0
sS'task1.thisN'
p176
I18
sg50
g58
sa(dp177
g45
g58
sg35
g36
sg18
F0.99950596942835546
sS'task1.thisTrialN'
p178
I19
sg48
g65
sg17
I1
sg16
S'down'
p179
sg27
g31
sg49
g60
sg46
g65
sg32
g11
sg33
g34
sg47
g113
sS'task1.thisIndex'
p180
I5
sg25
g26
sS'task1.thisRepN'
p181
I0
sS'task1.thisN'
p182
I19
sg50
g56
sa(dp183
g45
g58
sg35
g36
sg18
F1.1842374734369514
sS'task1.thisTrialN'
p184
I20
sg48
g65
sg17
I1
sg16
S'up'
p185
sg27
g31
sg49
g60
sg46
g58
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p186
I32
sg25
g26
sS'task1.thisRepN'
p187
I0
sS'task1.thisN'
p188
I20
sg50
g56
sa(dp189
g45
g60
sg35
g36
sg18
F1.8445824735917995
sS'task1.thisTrialN'
p190
I21
sg48
g56
sg17
I1
sg16
S'left'
p191
sg27
g31
sg49
g58
sg46
g58
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p192
I19
sg25
g26
sS'task1.thisRepN'
p193
I0
sS'task1.thisN'
p194
I21
sg50
g65
sa(dp195
g45
g65
sg35
g36
sg18
F0.67839636393546243
sS'task1.thisTrialN'
p196
I22
sg48
g60
sg17
I1
sg16
S'up'
p197
sg27
g31
sg49
g56
sg46
g65
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p198
I28
sg25
g26
sS'task1.thisRepN'
p199
I0
sS'task1.thisN'
p200
I22
sg50
g58
sa(dp201
g45
g60
sg35
g36
sg18
F0.94905582417231926
sS'task1.thisTrialN'
p202
I23
sg48
g65
sg17
I1
sg16
S'up'
p203
sg27
g31
sg49
g56
sg46
g60
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p204
I34
sg25
g26
sS'task1.thisRepN'
p205
I0
sS'task1.thisN'
p206
I23
sg50
g58
sa(dp207
g45
g65
sg35
g36
sg18
F1.1728205552644795
sS'task1.thisTrialN'
p208
I24
sg48
g56
sg17
I1
sg16
S'right'
p209
sg27
g31
sg49
g60
sg46
g58
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p210
I42
sg25
g26
sS'task1.thisRepN'
p211
I0
sS'task1.thisN'
p212
I24
sg50
g58
sa(dp213
g45
g65
sg35
g36
sg18
F0.87080908092320897
sS'task1.thisTrialN'
p214
I25
sg48
g58
sg17
I1
sg16
S'up'
p215
sg27
g31
sg49
g60
sg46
g65
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p216
I29
sg25
g26
sS'task1.thisRepN'
p217
I0
sS'task1.thisN'
p218
I25
sg50
g56
sa(dp219
g45
g58
sg35
g36
sg18
F1.0980406875878543
sS'task1.thisTrialN'
p220
I26
sg48
g56
sg17
I1
sg16
S'down'
p221
sg27
g31
sg49
g60
sg46
g56
sg32
g11
sg33
g34
sg47
g113
sS'task1.thisIndex'
p222
I0
sg25
g26
sS'task1.thisRepN'
p223
I0
sS'task1.thisN'
p224
I26
sg50
g65
sa(dp225
g45
g58
sg35
g36
sg18
F1.7257216054331366
sS'task1.thisTrialN'
p226
I27
sg48
g56
sg17
I1
sg16
S'right'
p227
sg27
g31
sg49
g60
sg46
g65
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p228
I40
sg25
g26
sS'task1.thisRepN'
p229
I0
sS'task1.thisN'
p230
I27
sg50
g65
sa(dp231
g45
g56
sg35
g36
sg18
F2.5048719755068305
sS'task1.thisTrialN'
p232
I28
sg48
g65
sg17
I1
sg16
S'up'
p233
sg27
g31
sg49
g58
sg46
g56
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p234
I25
sg25
g26
sS'task1.thisRepN'
p235
I0
sS'task1.thisN'
p236
I28
sg50
g60
sa(dp237
g45
g65
sg35
g36
sg18
F1.2860497957153711
sS'task1.thisTrialN'
p238
I29
sg48
g56
sg17
I1
sg16
S'up'
p239
sg27
g31
sg49
g58
sg46
g65
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p240
I27
sg25
g26
sS'task1.thisRepN'
p241
I0
sS'task1.thisN'
p242
I29
sg50
g60
sa(dp243
g45
g56
sg35
g36
sg18
F0.77399352499196539
sS'task1.thisTrialN'
p244
I30
sg48
g65
sg17
I1
sg16
S'left'
p245
sg27
g31
sg49
g58
sg46
g58
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p246
I20
sg25
g26
sS'task1.thisRepN'
p247
I0
sS'task1.thisN'
p248
I30
sg50
g60
sa(dp249
g45
g65
sg35
g36
sg18
F2.7408630008303589
sS'task1.thisTrialN'
p250
I31
sg48
g56
sg17
I1
sg16
S'down'
p251
sg27
g31
sg49
g58
sg46
g56
sg32
g11
sg33
g34
sg47
g113
sS'task1.thisIndex'
p252
I1
sg25
g26
sS'task1.thisRepN'
p253
I0
sS'task1.thisN'
p254
I31
sg50
g60
sa(dp255
g45
g65
sg35
g36
sg18
F1.9308437400559342
sS'task1.thisTrialN'
p256
I32
sg48
g56
sg17
I1
sg16
S'left'
p257
sg27
g31
sg49
g60
sg46
g60
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p258
I21
sg25
g26
sS'task1.thisRepN'
p259
I0
sS'task1.thisN'
p260
I32
sg50
g58
sa(dp261
g45
g60
sg35
g36
sg18
F1.1572861810036557
sS'task1.thisTrialN'
p262
I33
sg48
g56
sg17
I1
sg16
S'up'
p263
sg27
g31
sg49
g58
sg46
g60
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p264
I33
sg25
g26
sS'task1.thisRepN'
p265
I0
sS'task1.thisN'
p266
I33
sg50
g65
sa(dp267
g45
g60
sg35
g36
sg18
F1.015731665691419
sS'task1.thisTrialN'
p268
I34
sg48
g58
sg17
I1
sg16
S'right'
p269
sg27
g31
sg49
g65
sg46
g56
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p270
I37
sg25
g26
sS'task1.thisRepN'
p271
I0
sS'task1.thisN'
p272
I34
sg50
g56
sa(dp273
g45
g60
sg35
g36
sg18
F2.2699674966388557
sS'task1.thisTrialN'
p274
I35
sg48
g56
sg17
I1
sg16
S'left'
p275
sg27
g31
sg49
g65
sg46
g65
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p276
I15
sg25
g26
sS'task1.thisRepN'
p277
I0
sS'task1.thisN'
p278
I35
sg50
g58
sa(dp279
g45
g60
sg35
g36
sg18
F2.0559059750739834
sS'task1.thisTrialN'
p280
I36
sg48
g56
sg17
I0
sg16
S'right'
p281
sg27
g31
sg49
g65
sg46
g56
sg32
g11
sg33
g34
sg47
g113
sS'task1.thisIndex'
p282
I2
sg25
g26
sS'task1.thisRepN'
p283
I0
sS'task1.thisN'
p284
I36
sg50
g58
sa(dp285
g45
g58
sg35
g36
sg18
F1.0281238130428392
sS'task1.thisTrialN'
p286
I37
sg48
g60
sg17
I0
sg16
S'right'
p287
sg27
g31
sg49
g56
sg46
g56
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p288
I14
sg25
g26
sS'task1.thisRepN'
p289
I0
sS'task1.thisN'
p290
I37
sg50
g65
sa(dp291
g45
g60
sg35
g36
sg18
F1.0106720227267942
sS'task1.thisTrialN'
p292
I38
sg48
g65
sg17
I1
sg16
S'right'
p293
sg27
g31
sg49
g56
sg46
g58
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p294
I43
sg25
g26
sS'task1.thisRepN'
p295
I0
sS'task1.thisN'
p296
I38
sg50
g58
sa(dp297
g45
g58
sg35
g36
sg18
F2.1044935609206732
sS'task1.thisTrialN'
p298
I39
sg48
g56
sg17
I1
sg16
S'right'
p299
sg27
g31
sg49
g65
sg46
g60
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p300
I46
sg25
g26
sS'task1.thisRepN'
p301
I0
sS'task1.thisN'
p302
I39
sg50
g60
sa(dp303
g45
g65
sg35
g36
sg18
F2.1826020397693355
sS'task1.thisTrialN'
p304
I40
sg48
g60
sg17
I1
sg16
S'down'
p305
sg27
g31
sg49
g56
sg46
g60
sg32
g11
sg33
g34
sg47
g113
sS'task1.thisIndex'
p306
I10
sg25
g26
sS'task1.thisRepN'
p307
I0
sS'task1.thisN'
p308
I40
sg50
g58
sa(dp309
g45
g58
sg35
g36
sg18
F0.91923081364984682
sS'task1.thisTrialN'
p310
I41
sg48
g65
sg17
I0
sg16
S'right'
p311
sg27
g31
sg49
g60
sg46
g60
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p312
I22
sg25
g26
sS'task1.thisRepN'
p313
I0
sS'task1.thisN'
p314
I41
sg50
g56
sa(dp315
g45
g60
sg35
g36
sg18
F0.80657804913062137
sS'task1.thisTrialN'
p316
I42
sg48
g58
sg17
I1
sg16
S'down'
p317
sg27
g31
sg49
g56
sg46
g58
sg32
g11
sg33
g34
sg47
g113
sS'task1.thisIndex'
p318
I6
sg25
g26
sS'task1.thisRepN'
p319
I0
sS'task1.thisN'
p320
I42
sg50
g65
sa(dp321
g45
g60
sg35
g36
sg18
F1.7804181680075999
sS'task1.thisTrialN'
p322
I43
sg48
g58
sg17
I0
sg16
S'right'
p323
sg27
g31
sg49
g65
sg46
g60
sg32
g11
sg33
g34
sg47
g94
sS'task1.thisIndex'
p324
I35
sg25
g26
sS'task1.thisRepN'
p325
I0
sS'task1.thisN'
p326
I43
sg50
g56
sa(dp327
g45
g65
sg35
g36
sg18
F2.0560705450006935
sS'task1.thisTrialN'
p328
I44
sg48
g58
sg17
I1
sg16
S'right'
p329
sg27
g31
sg49
g56
sg46
g60
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p330
I45
sg25
g26
sS'task1.thisRepN'
p331
I0
sS'task1.thisN'
p332
I44
sg50
g60
sa(dp333
g45
g58
sg35
g36
sg18
F1.1894510999554768
sS'task1.thisTrialN'
p334
I45
sg48
g60
sg17
I0
sg16
S'right'
p335
sg27
g31
sg49
g65
sg46
g65
sg32
g11
sg33
g34
sg47
g61
sS'task1.thisIndex'
p336
I16
sg25
g26
sS'task1.thisRepN'
p337
I0
sS'task1.thisN'
p338
I45
sg50
g56
sa(dp339
g45
g58
sg35
g36
sg18
F1.1081301392005116
sS'task1.thisTrialN'
p340
I46
sg48
g65
sg17
I1
sg16
S'right'
p341
sg27
g31
sg49
g60
sg46
g56
sg32
g11
sg33
g34
sg47
g69
sS'task1.thisIndex'
p342
I38
sg25
g26
sS'task1.thisRepN'
p343
I0
sS'task1.thisN'
p344
I46
sg50
g56
sa(dp345
g45
g56
sg35
g36
sg18
F0.7057451264190604
sS'task1.thisTrialN'
p346
I47
sg48
g65
sg17
I0
sg16
S'left'
p347
sg27
g31
sg49
g58
sg46
g65
sg32
g11
sg33
g34
sg47
g113
sS'task1.thisIndex'
p348
I3
sg25
g26
sS'task1.thisRepN'
p349
I0
sS'task1.thisN'
p350
I47
sg50
g60
sa(dp351
g15
F1.590493247820632
sg32
g11
sg14
S'return'
p352
sg33
g34
sg25
g26
sg35
g36
sg27
g31
sa(dp353
S'task2.thisRepN'
p354
I0
sVdownbox
p355
Vred
p356
sg35
g36
sS'task2.thisIndex'
p357
I8
sg27
g31
sVrightbox
p358
Vblue
p359
sg21
F1.0174732838531781
sVleftbox
p360
Vgreen
p361
sS'task2.thisN'
p362
I0
sVtargettest
p363
Vyellow
p364
sg32
g11
sg33
g34
sVcorrAns
p365
Vdown
p366
sg19
S'up'
p367
sg25
g26
sVupbox
p368
g364
sg20
I0
sS'task2.thisTrialN'
p369
I0
sa(dp370
S'task2.thisRepN'
p371
I0
sg355
g364
sg35
g36
sS'task2.thisIndex'
p372
I11
sg27
g31
sg358
g356
sg21
F0.78715815650866716
sg360
g361
sS'task2.thisN'
p373
I1
sg363
g359
sg32
g11
sg33
g34
sg365
g366
sg19
S'down'
p374
sg25
g26
sg368
g359
sg20
I1
sS'task2.thisTrialN'
p375
I1
sa(dp376
S'task2.thisRepN'
p377
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p378
I36
sg27
g31
sg358
g364
sg21
F0.93421822549316857
sg360
g361
sS'task2.thisN'
p379
I2
sg363
g361
sg32
g11
sg33
g34
sg365
Vright
p380
sg19
S'right'
p381
sg25
g26
sg368
g359
sg20
I1
sS'task2.thisTrialN'
p382
I2
sa(dp383
S'task2.thisRepN'
p384
I0
sg355
g364
sg35
g36
sS'task2.thisIndex'
p385
I46
sg27
g31
sg358
g356
sg21
F1.190825082381707
sg360
g359
sS'task2.thisN'
p386
I3
sg363
g359
sg32
g11
sg33
g34
sg365
g380
sg19
S'right'
p387
sg25
g26
sg368
g361
sg20
I1
sS'task2.thisTrialN'
p388
I3
sa(dp389
S'task2.thisRepN'
p390
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p391
I23
sg27
g31
sg358
g359
sg21
F0.75824902733620547
sg360
g356
sS'task2.thisN'
p392
I4
sg363
g359
sg32
g11
sg33
g34
sg365
Vleft
p393
sg19
S'left'
p394
sg25
g26
sg368
g364
sg20
I1
sS'task2.thisTrialN'
p395
I4
sa(dp396
S'task2.thisRepN'
p397
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p398
I47
sg27
g31
sg358
g364
sg21
F0.92828055547033728
sg360
g359
sS'task2.thisN'
p399
I5
sg363
g359
sg32
g11
sg33
g34
sg365
g380
sg19
S'right'
p400
sg25
g26
sg368
g356
sg20
I1
sS'task2.thisTrialN'
p401
I5
sa(dp402
S'task2.thisRepN'
p403
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p404
I20
sg27
g31
sg358
g364
sg21
F0.98261718148569344
sg360
g359
sS'task2.thisN'
p405
I6
sg363
g364
sg32
g11
sg33
g34
sg365
g393
sg19
S'right'
p406
sg25
g26
sg368
g356
sg20
I0
sS'task2.thisTrialN'
p407
I6
sa(dp408
S'task2.thisRepN'
p409
I0
sg355
g364
sg35
g36
sS'task2.thisIndex'
p410
I22
sg27
g31
sg358
g359
sg21
F0.62848002833379724
sg360
g361
sS'task2.thisN'
p411
I7
sg363
g359
sg32
g11
sg33
g34
sg365
g393
sg19
S'right'
p412
sg25
g26
sg368
g356
sg20
I0
sS'task2.thisTrialN'
p413
I7
sa(dp414
S'task2.thisRepN'
p415
I0
sg355
g364
sg35
g36
sS'task2.thisIndex'
p416
I0
sg27
g31
sg358
g359
sg21
F2.0489581087731494
sg360
g356
sS'task2.thisN'
p417
I8
sg363
g361
sg32
g11
sg33
g34
sg365
g366
sg19
S'right'
p418
sg25
g26
sg368
g361
sg20
I0
sS'task2.thisTrialN'
p419
I8
sa(dp420
S'task2.thisRepN'
p421
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p422
I25
sg27
g31
sg358
g364
sg21
F0.77242160953937855
sg360
g359
sS'task2.thisN'
p423
I9
sg363
g361
sg32
g11
sg33
g34
sg365
Vup
p424
sg19
S'up'
p425
sg25
g26
sg368
g356
sg20
I1
sS'task2.thisTrialN'
p426
I9
sa(dp427
S'task2.thisRepN'
p428
I0
sg355
g364
sg35
g36
sS'task2.thisIndex'
p429
I16
sg27
g31
sg358
g356
sg21
F1.3976708704176417
sg360
g361
sS'task2.thisN'
p430
I10
sg363
g356
sg32
g11
sg33
g34
sg365
g393
sg19
S'down'
p431
sg25
g26
sg368
g359
sg20
I0
sS'task2.thisTrialN'
p432
I10
sa(dp433
S'task2.thisRepN'
p434
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p435
I33
sg27
g31
sg358
g364
sg21
F1.2551228403808636
sg360
g356
sS'task2.thisN'
p436
I11
sg363
g359
sg32
g11
sg33
g34
sg365
g424
sg19
S'up'
p437
sg25
g26
sg368
g361
sg20
I1
sS'task2.thisTrialN'
p438
I11
sa(dp439
S'task2.thisRepN'
p440
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p441
I9
sg27
g31
sg358
g364
sg21
F0.93019348033521965
sg360
g356
sS'task2.thisN'
p442
I12
sg363
g359
sg32
g11
sg33
g34
sg365
g366
sg19
S'down'
p443
sg25
g26
sg368
g359
sg20
I1
sS'task2.thisTrialN'
p444
I12
sa(dp445
S'task2.thisRepN'
p446
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p447
I10
sg27
g31
sg358
g361
sg21
F0.80481429583232966
sg360
g364
sS'task2.thisN'
p448
I13
sg363
g359
sg32
g11
sg33
g34
sg365
g366
sg19
S'down'
p449
sg25
g26
sg368
g359
sg20
I1
sS'task2.thisTrialN'
p450
I13
sa(dp451
S'task2.thisRepN'
p452
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p453
I34
sg27
g31
sg358
g361
sg21
F0.7605754622072709
sg360
g364
sS'task2.thisN'
p454
I14
sg363
g359
sg32
g11
sg33
g34
sg365
g424
sg19
S'up'
p455
sg25
g26
sg368
g356
sg20
I1
sS'task2.thisTrialN'
p456
I14
sa(dp457
S'task2.thisRepN'
p458
I0
sg355
g364
sg35
g36
sS'task2.thisIndex'
p459
I38
sg27
g31
sg358
g359
sg21
F2.1434199619143328
sg360
g361
sS'task2.thisN'
p460
I15
sg363
g361
sg32
g11
sg33
g34
sg365
g380
sg19
S'right'
p461
sg25
g26
sg368
g356
sg20
I1
sS'task2.thisTrialN'
p462
I15
sa(dp463
S'task2.thisRepN'
p464
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p465
I3
sg27
g31
sg358
g364
sg21
F0.86728029113146476
sg360
g359
sS'task2.thisN'
p466
I16
sg363
g356
sg32
g11
sg33
g34
sg365
g366
sg19
S'down'
p467
sg25
g26
sg368
g356
sg20
I1
sS'task2.thisTrialN'
p468
I16
sa(dp469
S'task2.thisRepN'
p470
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p471
I17
sg27
g31
sg358
g356
sg21
F1.5930670187754004
sg360
g359
sS'task2.thisN'
p472
I17
sg363
g356
sg32
g11
sg33
g34
sg365
g393
sg19
S'down'
p473
sg25
g26
sg368
g364
sg20
I0
sS'task2.thisTrialN'
p474
I17
sa(dp475
S'task2.thisRepN'
p476
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p477
I4
sg27
g31
sg358
g361
sg21
F2.1354391226032021
sg360
g364
sS'task2.thisN'
p478
I18
sg363
g356
sg32
g11
sg33
g34
sg365
g366
sg19
S'down'
p479
sg25
g26
sg368
g356
sg20
I1
sS'task2.thisTrialN'
p480
I18
sa(dp481
S'task2.thisRepN'
p482
I0
sg355
g364
sg35
g36
sS'task2.thisIndex'
p483
I30
sg27
g31
sg358
g361
sg21
F1.9187893941270886
sg360
g356
sS'task2.thisN'
p484
I19
sg363
g364
sg32
g11
sg33
g34
sg365
g424
sg19
S'right'
p485
sg25
g26
sg368
g359
sg20
I0
sS'task2.thisTrialN'
p486
I19
sa(dp487
S'task2.thisRepN'
p488
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p489
I7
sg27
g31
sg358
g356
sg21
F1.4468577089301107
sg360
g359
sS'task2.thisN'
p490
I20
sg363
g364
sg32
g11
sg33
g34
sg365
g366
sg19
S'down'
p491
sg25
g26
sg368
g364
sg20
I1
sS'task2.thisTrialN'
p492
I20
sa(dp493
S'task2.thisRepN'
p494
I0
sg355
g364
sg35
g36
sS'task2.thisIndex'
p495
I31
sg27
g31
sg358
g356
sg21
F1.6161019961400598
sg360
g359
sS'task2.thisN'
p496
I21
sg363
g364
sg32
g11
sg33
g34
sg365
g424
sg19
S'up'
p497
sg25
g26
sg368
g361
sg20
I1
sS'task2.thisTrialN'
p498
I21
sa(dp499
S'task2.thisRepN'
p500
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p501
I13
sg27
g31
sg358
g361
sg21
F1.154435239648592
sg360
g364
sS'task2.thisN'
p502
I22
sg363
g361
sg32
g11
sg33
g34
sg365
g393
sg19
S'left'
p503
sg25
g26
sg368
g356
sg20
I1
sS'task2.thisTrialN'
p504
I22
sa(dp505
S'task2.thisRepN'
p506
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p507
I45
sg27
g31
sg358
g361
sg21
F1.2701811488204839
sg360
g359
sS'task2.thisN'
p508
I23
sg363
g359
sg32
g11
sg33
g34
sg365
g380
sg19
S'right'
p509
sg25
g26
sg368
g364
sg20
I1
sS'task2.thisTrialN'
p510
I23
sa(dp511
S'task2.thisRepN'
p512
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p513
I24
sg27
g31
sg358
g359
sg21
F0.83747517015217454
sg360
g356
sS'task2.thisN'
p514
I24
sg363
g361
sg32
g11
sg33
g34
sg365
g424
sg19
S'up'
p515
sg25
g26
sg368
g364
sg20
I1
sS'task2.thisTrialN'
p516
I24
sa(dp517
S'task2.thisRepN'
p518
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p519
I18
sg27
g31
sg358
g364
sg21
F1.9233258138028759
sg360
g361
sS'task2.thisN'
p520
I25
sg363
g364
sg32
g11
sg33
g34
sg365
g393
sg19
S'right'
p521
sg25
g26
sg368
g359
sg20
I0
sS'task2.thisTrialN'
p522
I25
sa(dp523
S'task2.thisRepN'
p524
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p525
I41
sg27
g31
sg358
g364
sg21
F2.327299102789766
sg360
g356
sS'task2.thisN'
p526
I26
sg363
g356
sg32
g11
sg33
g34
sg365
g380
sg19
S'right'
p527
sg25
g26
sg368
g359
sg20
I1
sS'task2.thisTrialN'
p528
I26
sa(dp529
S'task2.thisRepN'
p530
I0
sg355
g364
sg35
g36
sS'task2.thisIndex'
p531
I5
sg27
g31
sg358
g359
sg21
F1.331478473099196
sg360
g361
sS'task2.thisN'
p532
I27
sg363
g356
sg32
g11
sg33
g34
sg365
g366
sg19
S'left'
p533
sg25
g26
sg368
g356
sg20
I0
sS'task2.thisTrialN'
p534
I27
sa(dp535
S'task2.thisRepN'
p536
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p537
I28
sg27
g31
sg358
g361
sg21
F1.5703268557590491
sg360
g364
sS'task2.thisN'
p538
I28
sg363
g356
sg32
g11
sg33
g34
sg365
g424
sg19
S'up'
p539
sg25
g26
sg368
g359
sg20
I1
sS'task2.thisTrialN'
p540
I28
sa(dp541
S'task2.thisRepN'
p542
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p543
I35
sg27
g31
sg358
g356
sg21
F0.4540798584366712
sg360
g361
sS'task2.thisN'
p544
I29
sg363
g359
sg32
g11
sg33
g34
sg365
g424
sg19
S'up'
p545
sg25
g26
sg368
g364
sg20
I1
sS'task2.thisTrialN'
p546
I29
sa(dp547
S'task2.thisRepN'
p548
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p549
I12
sg27
g31
sg358
g361
sg21
F0.75769917772777262
sg360
g359
sS'task2.thisN'
p550
I30
sg363
g361
sg32
g11
sg33
g34
sg365
g393
sg19
S'left'
p551
sg25
g26
sg368
g364
sg20
I1
sS'task2.thisTrialN'
p552
I30
sa(dp553
S'task2.thisRepN'
p554
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p555
I1
sg27
g31
sg358
g364
sg21
F1.0254817118857318
sg360
g359
sS'task2.thisN'
p556
I31
sg363
g361
sg32
g11
sg33
g34
sg365
g366
sg19
S'down'
p557
sg25
g26
sg368
g361
sg20
I1
sS'task2.thisTrialN'
p558
I31
sa(dp559
S'task2.thisRepN'
p560
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p561
I29
sg27
g31
sg358
g359
sg21
F0.89614515003086126
sg360
g361
sS'task2.thisN'
p562
I32
sg363
g356
sg32
g11
sg33
g34
sg365
g424
sg19
S'up'
p563
sg25
g26
sg368
g364
sg20
I1
sS'task2.thisTrialN'
p564
I32
sa(dp565
S'task2.thisRepN'
p566
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p567
I2
sg27
g31
sg358
g356
sg21
F0.88768343290939811
sg360
g364
sS'task2.thisN'
p568
I33
sg363
g361
sg32
g11
sg33
g34
sg365
g366
sg19
S'down'
p569
sg25
g26
sg368
g361
sg20
I1
sS'task2.thisTrialN'
p570
I33
sa(dp571
S'task2.thisRepN'
p572
I0
sg355
g364
sg35
g36
sS'task2.thisIndex'
p573
I32
sg27
g31
sg358
g359
sg21
F0.59782992259715684
sg360
g361
sS'task2.thisN'
p574
I34
sg363
g364
sg32
g11
sg33
g34
sg365
g424
sg19
S'up'
p575
sg25
g26
sg368
g356
sg20
I1
sS'task2.thisTrialN'
p576
I34
sa(dp577
S'task2.thisRepN'
p578
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p579
I43
sg27
g31
sg358
g361
sg21
F1.2985487691585149
sg360
g364
sS'task2.thisN'
p580
I35
sg363
g364
sg32
g11
sg33
g34
sg365
g380
sg19
S'left'
p581
sg25
g26
sg368
g356
sg20
I0
sS'task2.thisTrialN'
p582
I35
sa(dp583
S'task2.thisRepN'
p584
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p585
I19
sg27
g31
sg358
g364
sg21
F1.8919057902949135
sg360
g356
sS'task2.thisN'
p586
I36
sg363
g364
sg32
g11
sg33
g34
sg365
g393
sg19
S'left'
p587
sg25
g26
sg368
g361
sg20
I1
sS'task2.thisTrialN'
p588
I36
sa(dp589
S'task2.thisRepN'
p590
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p591
I42
sg27
g31
sg358
g359
sg21
F2.2124119727341167
sg360
g364
sS'task2.thisN'
p592
I37
sg363
g364
sg32
g11
sg33
g34
sg365
g380
sg19
S'right'
p593
sg25
g26
sg368
g361
sg20
I1
sS'task2.thisTrialN'
p594
I37
sa(dp595
S'task2.thisRepN'
p596
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p597
I15
sg27
g31
sg358
g356
sg21
F0.68131723948499712
sg360
g364
sS'task2.thisN'
p598
I38
sg363
g356
sg32
g11
sg33
g34
sg365
g393
sg19
S'up'
p599
sg25
g26
sg368
g361
sg20
I0
sS'task2.thisTrialN'
p600
I38
sa(dp601
S'task2.thisRepN'
p602
I0
sg355
g364
sg35
g36
sS'task2.thisIndex'
p603
I40
sg27
g31
sg358
g359
sg21
F1.7079509408395097
sg360
g356
sS'task2.thisN'
p604
I39
sg363
g356
sg32
g11
sg33
g34
sg365
g380
sg19
S'right'
p605
sg25
g26
sg368
g361
sg20
I1
sS'task2.thisTrialN'
p606
I39
sa(dp607
S'task2.thisRepN'
p608
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p609
I44
sg27
g31
sg358
g356
sg21
F1.0616636768190801
sg360
g364
sS'task2.thisN'
p610
I40
sg363
g364
sg32
g11
sg33
g34
sg365
g380
sg19
S'right'
p611
sg25
g26
sg368
g359
sg20
I1
sS'task2.thisTrialN'
p612
I40
sa(dp613
S'task2.thisRepN'
p614
I0
sg355
g364
sg35
g36
sS'task2.thisIndex'
p615
I14
sg27
g31
sg358
g361
sg21
F1.5876740655767207
sg360
g356
sS'task2.thisN'
p616
I41
sg363
g361
sg32
g11
sg33
g34
sg365
g393
sg19
S'right'
p617
sg25
g26
sg368
g359
sg20
I0
sS'task2.thisTrialN'
p618
I41
sa(dp619
S'task2.thisRepN'
p620
I0
sg355
g361
sg35
g36
sS'task2.thisIndex'
p621
I26
sg27
g31
sg358
g356
sg21
F1.0434795022210892
sg360
g364
sS'task2.thisN'
p622
I42
sg363
g361
sg32
g11
sg33
g34
sg365
g424
sg19
S'up'
p623
sg25
g26
sg368
g359
sg20
I1
sS'task2.thisTrialN'
p624
I42
sa(dp625
S'task2.thisRepN'
p626
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p627
I37
sg27
g31
sg358
g356
sg21
F1.2381445494957006
sg360
g361
sS'task2.thisN'
p628
I43
sg363
g361
sg32
g11
sg33
g34
sg365
g380
sg19
S'right'
p629
sg25
g26
sg368
g364
sg20
I1
sS'task2.thisTrialN'
p630
I43
sa(dp631
S'task2.thisRepN'
p632
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p633
I27
sg27
g31
sg358
g364
sg21
F0.89770551671790599
sg360
g359
sS'task2.thisN'
p634
I44
sg363
g356
sg32
g11
sg33
g34
sg365
g424
sg19
S'up'
p635
sg25
g26
sg368
g361
sg20
I1
sS'task2.thisTrialN'
p636
I44
sa(dp637
S'task2.thisRepN'
p638
I0
sg355
g356
sg35
g36
sS'task2.thisIndex'
p639
I21
sg27
g31
sg358
g359
sg21
F1.5556721125522017
sg360
g364
sS'task2.thisN'
p640
I45
sg363
g359
sg32
g11
sg33
g34
sg365
g393
sg19
S'right'
p641
sg25
g26
sg368
g361
sg20
I0
sS'task2.thisTrialN'
p642
I45
sa(dp643
S'task2.thisRepN'
p644
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p645
I6
sg27
g31
sg358
g361
sg21
F1.8953162052293919
sg360
g356
sS'task2.thisN'
p646
I46
sg363
g364
sg32
g11
sg33
g34
sg365
g366
sg19
S'right'
p647
sg25
g26
sg368
g364
sg20
I0
sS'task2.thisTrialN'
p648
I46
sa(dp649
S'task2.thisRepN'
p650
I0
sg355
g359
sg35
g36
sS'task2.thisIndex'
p651
I39
sg27
g31
sg358
g361
sg21
F1.1727127667763853
sg360
g356
sS'task2.thisN'
p652
I47
sg363
g356
sg32
g11
sg33
g34
sg365
g380
sg19
S'right'
p653
sg25
g26
sg368
g364
sg20
I1
sS'task2.thisTrialN'
p654
I47
sasS'loops'
p655
(lp656
g1
(cpsychopy.data
TrialHandler
p657
g3
NtRp658
(dp659
S'origin'
p660
V\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a larger size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a#########start of task1########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'task1'\u000a\u000a # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()\u000a
p661
sS'thisTrial'
p662
(lp663
sS'_exp'
p664
L458710096L
sg10
S'task1'
p665
sg6
S'C:/Users/Eyetracking/Documents/adamant-squeegee/Brook/VWM_task/VWMtask_a.py'
p666
sS'thisRepN'
p667
I1
sg22
I01
sg23
g24
sS'data'
p668
g1
(cpsychopy.data
DataHandler
p669
c__builtin__
dict
p670
(dp671
S'ran'
p672
cnumpy.ma.core
_mareconstruct
p673
(cnumpy.ma.core
MaskedArray
p674
cnumpy
ndarray
p675
(I0
tp676
S'b'
tRp677
(I1
(L48L
L1L
tg29
(S'f4'
I0
I1
tRp678
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg17
g673
(g674
g675
g676
S'b'
tRp679
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg16
cnumpy.core.multiarray
_reconstruct
p680
(g675
(I0
tS'b'
tRp681
(I1
(L48L
L1L
tg29
(S'O8'
I0
I1
tRp682
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp683
g221
ag251
ag281
ag347
ag149
ag179
ag317
ag143
ag155
ag119
ag305
ag112
ag87
ag173
ag287
ag275
ag335
ag137
ag75
ag191
ag245
ag257
ag311
ag59
ag100
ag233
ag93
ag239
ag197
ag215
ag161
ag167
ag185
ag263
ag203
ag323
ag125
ag269
ag341
ag68
ag227
ag106
ag209
ag293
ag131
ag329
ag299
ag81
atbsg18
g673
(g674
g675
g676
S'b'
tRp684
(I1
(L48L
L1L
tg678
I00
S'\x99\x8c\x8c?Mj/@\xf7\x93\x03@\xb6\xab4?\x11/ @\xa0\xdf\x7f?\xe6{N?\xb2\x00\xb3?\x90\xc3=?\xac\x05r?\xc0\xaf\x0b@m\x8b\x92?\x91\x11\xe0??\x02\x9e?\x90\x99\x83?&G\x11@\xef?\x98?\xef\xb0\x9e?uJ\x7f?G\x1b\xec?q$F?\xe3%\xf7?\xb6Rk?\xbe\xaa\xad?"\xae\xdb?\xd3O @\xd9\x83\x9e?H\x9d\xa4?b\xab-?X\xed^?\xfal\x9c?+\xad\x96?\x18\x95\x97?\xf4!\x94?S\xf5r?\xbe\xe4\xe3?\xc30\xd1?\x7f\x03\x82?5\xd7\x8d?\t\x9a\xb6?r\xe4\xdc?\x97J\xcd?\xfc\x1e\x96?\xb3]\x81?\x05U%?\xa9\x96\x03@\x06\xb0\x06@F\x86\x93?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p685
g673
(g674
g675
g676
S'b'
tRp686
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\xd0A\x00\x00\xf8A\x00\x00\x10B\x00\x00<B\x00\x00`A\x00\x00\x98A\x00\x00(B\x00\x00PA\x00\x00pA\x00\x00\x10A\x00\x00 B\x00\x00\x00A\x00\x00\x80@\x00\x00\x90A\x00\x00\x14B\x00\x00\x0cB\x00\x004B\x00\x00@A\x00\x00\x00@\x00\x00\xa8A\x00\x00\xf0A\x00\x00\x00B\x00\x00$B\x00\x00\x00\x00\x00\x00\xc0@\x00\x00\xe0A\x00\x00\xa0@\x00\x00\xe8A\x00\x00\xb0A\x00\x00\xc8A\x00\x00\x80A\x00\x00\x88A\x00\x00\xa0A\x00\x00\x04B\x00\x00\xb8A\x00\x00,B\x00\x00 A\x00\x00\x08B\x00\x008B\x00\x00\x80?\x00\x00\xd8A\x00\x00\xe0@\x00\x00\xc0A\x00\x00\x18B\x00\x000A\x00\x000B\x00\x00\x1cB\x00\x00@@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbstRp687
(dp688
S'isNumeric'
p689
(dp690
g672
I01
sg17
I01
sg16
I00
sg18
I01
sg685
I01
ssS'trials'
p691
g658
sS'dataTypes'
p692
(lp693
g672
ag685
ag16
ag17
ag18
asS'dataShape'
p694
(lp695
L48L
aI1
asbsS'method'
p696
S'fullRandom'
p697
sS'sequenceIndices'
p698
g680
(g675
(I0
tS'b'
tRp699
(I1
(L48L
L1L
tg682
I00
(lp700
I23
aI39
aI18
aI47
aI12
aI26
aI24
aI41
aI11
aI9
aI36
aI44
aI17
aI7
aI4
aI8
aI30
aI31
aI13
aI5
aI32
aI19
aI28
aI34
aI42
aI29
aI0
aI40
aI25
aI27
aI20
aI1
aI21
aI33
aI37
aI15
aI2
aI14
aI43
aI46
aI10
aI22
aI6
aI35
aI45
aI16
aI38
aI3
atbsS'finished'
p701
I01
sS'nReps'
p702
I1
sS'nRemaining'
p703
I-1
sS'trialList'
p704
(lp705
g1
(cpsychopy.data
TrialType
p706
g670
(dp707
g45
g58
sg46
g56
sg47
g113
sg48
g56
sg49
g60
sg50
g65
stRp708
ag1
(g706
g670
(dp709
g45
g65
sg46
g56
sg47
g113
sg48
g56
sg49
g58
sg50
g60
stRp710
ag1
(g706
g670
(dp711
g45
g60
sg46
g56
sg47
g113
sg48
g56
sg49
g65
sg50
g58
stRp712
ag1
(g706
g670
(dp713
g45
g56
sg46
g65
sg47
g113
sg48
g65
sg49
g58
sg50
g60
stRp714
ag1
(g706
g670
(dp715
g45
g60
sg46
g65
sg47
g113
sg48
g65
sg49
g56
sg50
g58
stRp716
ag1
(g706
g670
(dp717
g45
g58
sg46
g65
sg47
g113
sg48
g65
sg49
g60
sg50
g56
stRp718
ag1
(g706
g670
(dp719
g45
g60
sg46
g58
sg47
g113
sg48
g58
sg49
g56
sg50
g65
stRp720
ag1
(g706
g670
(dp721
g45
g56
sg46
g58
sg47
g113
sg48
g58
sg49
g65
sg50
g60
stRp722
ag1
(g706
g670
(dp723
g45
g65
sg46
g58
sg47
g113
sg48
g58
sg49
g60
sg50
g56
stRp724
ag1
(g706
g670
(dp725
g45
g56
sg46
g60
sg47
g113
sg48
g60
sg49
g58
sg50
g65
stRp726
ag1
(g706
g670
(dp727
g45
g65
sg46
g60
sg47
g113
sg48
g60
sg49
g56
sg50
g58
stRp728
ag1
(g706
g670
(dp729
g45
g58
sg46
g60
sg47
g113
sg48
g60
sg49
g65
sg50
g56
stRp730
ag1
(g706
g670
(dp731
g45
g65
sg46
g56
sg47
g61
sg48
g58
sg49
g56
sg50
g60
stRp732
ag1
(g706
g670
(dp733
g45
g60
sg46
g56
sg47
g61
sg48
g65
sg49
g56
sg50
g58
stRp734
ag1
(g706
g670
(dp735
g45
g58
sg46
g56
sg47
g61
sg48
g60
sg49
g56
sg50
g65
stRp736
ag1
(g706
g670
(dp737
g45
g60
sg46
g65
sg47
g61
sg48
g56
sg49
g65
sg50
g58
stRp738
ag1
(g706
g670
(dp739
g45
g58
sg46
g65
sg47
g61
sg48
g60
sg49
g65
sg50
g56
stRp740
ag1
(g706
g670
(dp741
g45
g56
sg46
g65
sg47
g61
sg48
g58
sg49
g65
sg50
g60
stRp742
ag1
(g706
g670
(dp743
g45
g65
sg46
g58
sg47
g61
sg48
g60
sg49
g58
sg50
g56
stRp744
ag1
(g706
g670
(dp745
g45
g60
sg46
g58
sg47
g61
sg48
g56
sg49
g58
sg50
g65
stRp746
ag1
(g706
g670
(dp747
g45
g56
sg46
g58
sg47
g61
sg48
g65
sg49
g58
sg50
g60
stRp748
ag1
(g706
g670
(dp749
g45
g65
sg46
g60
sg47
g61
sg48
g56
sg49
g60
sg50
g58
stRp750
ag1
(g706
g670
(dp751
g45
g58
sg46
g60
sg47
g61
sg48
g65
sg49
g60
sg50
g56
stRp752
ag1
(g706
g670
(dp753
g45
g56
sg46
g60
sg47
g61
sg48
g58
sg49
g60
sg50
g65
stRp754
ag1
(g706
g670
(dp755
g45
g56
sg46
g56
sg47
g94
sg48
g58
sg49
g60
sg50
g65
stRp756
ag1
(g706
g670
(dp757
g45
g56
sg46
g56
sg47
g94
sg48
g65
sg49
g58
sg50
g60
stRp758
ag1
(g706
g670
(dp759
g45
g56
sg46
g56
sg47
g94
sg48
g60
sg49
g65
sg50
g58
stRp760
ag1
(g706
g670
(dp761
g45
g65
sg46
g65
sg47
g94
sg48
g56
sg49
g58
sg50
g60
stRp762
ag1
(g706
g670
(dp763
g45
g65
sg46
g65
sg47
g94
sg48
g60
sg49
g56
sg50
g58
stRp764
ag1
(g706
g670
(dp765
g45
g65
sg46
g65
sg47
g94
sg48
g58
sg49
g60
sg50
g56
stRp766
ag1
(g706
g670
(dp767
g45
g58
sg46
g58
sg47
g94
sg48
g60
sg49
g56
sg50
g65
stRp768
ag1
(g706
g670
(dp769
g45
g58
sg46
g58
sg47
g94
sg48
g56
sg49
g65
sg50
g60
stRp770
ag1
(g706
g670
(dp771
g45
g58
sg46
g58
sg47
g94
sg48
g65
sg49
g60
sg50
g56
stRp772
ag1
(g706
g670
(dp773
g45
g60
sg46
g60
sg47
g94
sg48
g56
sg49
g58
sg50
g65
stRp774
ag1
(g706
g670
(dp775
g45
g60
sg46
g60
sg47
g94
sg48
g65
sg49
g56
sg50
g58
stRp776
ag1
(g706
g670
(dp777
g45
g60
sg46
g60
sg47
g94
sg48
g58
sg49
g65
sg50
g56
stRp778
ag1
(g706
g670
(dp779
g45
g65
sg46
g56
sg47
g69
sg48
g60
sg49
g58
sg50
g56
stRp780
ag1
(g706
g670
(dp781
g45
g60
sg46
g56
sg47
g69
sg48
g58
sg49
g65
sg50
g56
stRp782
ag1
(g706
g670
(dp783
g45
g58
sg46
g56
sg47
g69
sg48
g65
sg49
g60
sg50
g56
stRp784
ag1
(g706
g670
(dp785
g45
g60
sg46
g65
sg47
g69
sg48
g58
sg49
g56
sg50
g65
stRp786
ag1
(g706
g670
(dp787
g45
g58
sg46
g65
sg47
g69
sg48
g56
sg49
g60
sg50
g65
stRp788
ag1
(g706
g670
(dp789
g45
g56
sg46
g65
sg47
g69
sg48
g60
sg49
g58
sg50
g65
stRp790
ag1
(g706
g670
(dp791
g45
g65
sg46
g58
sg47
g69
sg48
g56
sg49
g60
sg50
g58
stRp792
ag1
(g706
g670
(dp793
g45
g60
sg46
g58
sg47
g69
sg48
g65
sg49
g56
sg50
g58
stRp794
ag1
(g706
g670
(dp795
g45
g56
sg46
g58
sg47
g69
sg48
g60
sg49
g65
sg50
g58
stRp796
ag1
(g706
g670
(dp797
g45
g65
sg46
g60
sg47
g69
sg48
g58
sg49
g56
sg50
g60
stRp798
ag1
(g706
g670
(dp799
g45
g58
sg46
g60
sg47
g69
sg48
g56
sg49
g65
sg50
g60
stRp800
ag1
(g706
g670
(dp801
g45
g56
sg46
g60
sg47
g69
sg48
g65
sg49
g58
sg50
g60
stRp802
asS'seed'
p803
NsS'thisIndex'
p804
I3
sS'thisN'
p805
I48
sS'thisTrialN'
p806
I0
sS'nTotal'
p807
I48
sS'_warnUseOfNext'
p808
I01
sbag1
(g657
g3
NtRp809
(dp810
g660
V\u000afrom __future__ import division  # so that 1/3=0.333 instead of 1/3=0\u000afrom psychopy import visual, core, data, logging, sound, gui, parallel\u000a\u000a\u000a#Pylink imports\u000afrom pylink import *\u000afrom pygame import *\u000a\u000afrom psychopy.constants import *  # things like STARTED, FINISHED\u000aimport numpy as np  # whole numpy lib is available, prepend 'np.'\u000afrom numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray\u000afrom numpy.random import random, randint, normal, shuffle\u000a\u000aimport os  # handy system and path functions\u000a\u000a# Ensure that relative paths start from the same directory as this script\u000a_thisDir = os.path.dirname(os.path.abspath(__file__))\u000aos.chdir(_thisDir)\u000a\u000a# Store info about the experiment session\u000aexpName = 'test1'  # from the Builder filename that created this script\u000aexpInfo = {'participant':'', 'session':'001'}\u000adlg = gui.DlgFromDict(dictionary=expInfo, title=expName)\u000aif dlg.OK == False: core.quit()  # user pressed cancel\u000aexpInfo['date'] = data.getDateStr()  # add a simple timestamp\u000aexpInfo['expName'] = expName\u000a\u000a# Data file name stem = absolute path + name; later add .psyexp, .csv, .log, etc\u000afilename = _thisDir + os.sep + 'data/%s_%s_%s' %(expInfo['participant'], expName, expInfo['date'])\u000a\u000a# An ExperimentHandler isn't essential but helps with data saving\u000athisExp = data.ExperimentHandler(name=expName, version='',\u000a    extraInfo=expInfo, runtimeInfo=None,\u000a    originPath=None,\u000a    savePickle=True, saveWideText=True,\u000a    dataFileName=filename)\u000a#save a log file for detail verbose info\u000alogFile = logging.LogFile(filename+'.log', level=logging.EXP)\u000alogging.console.setLevel(logging.WARNING)  # this outputs to the screen, not a file\u000a\u000aendExpNow = False  # flag for 'escape' or other condition => quit the exp\u000a\u000a#Makes vairable to pass to eyetracker EDF file\u000a#NOTE: MAX 4 characters (including .edf)\u000asubj=str(expInfo['participant'])\u000a\u000a                    ####BEGIN EYELINK CODE####\u000a\u000a#Makes an instance of the eyetracker to interact with\u000atracker = EyeLink()\u000a\u000a#Gets display information so it doesn't need to be manually set \u000a#NOTE: Change this if specific resolution is required. \u000adisp = getDisplayInformation()\u000a\u000a                ###START EYETRACKER CALIBRATION###\u000a\u000a#Opens a window for the eyetracker to display graphics on. \u000adisplay.init()\u000a#display.set_mode((disp.width, disp.height), FULLSCREEN |DOUBLEBUF,32)\u000adisplay.set_mode((800,600), FULLSCREEN)\u000amouse.set_visible(False)\u000aopenGraphics()\u000a\u000a#Opens the EDF file.\u000aedfFileName = subj + ".EDF";\u000atracker.openDataFile(edfFileName)       \u000a    \u000apylink.flushGetkeyQueue(); \u000atracker.setOfflineMode();                          \u000a\u000a#Gets the display surface and sends a message to EDF file;\u000asurf = display.get_surface()\u000atracker.sendCommand("screen_pixel_coords =  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000atracker.sendMessage("DISPLAY_COORDS  0 0 %d %d" %(surf.get_rect().w - 1, surf.get_rect().h - 1))\u000a\u000atracker_software_ver = 0\u000aeyelink_ver = tracker.getTrackerVersion()\u000aif eyelink_ver == 3:\u000a    tvstr = tracker.getTrackerVersionString()\u000a    vindex = tvstr.find("EYELINK CL")\u000a    tracker_software_ver = int(float(tvstr[(vindex + len("EYELINK CL")):].strip()))\u000a    \u000a\u000aif eyelink_ver>=2:\u000a    tracker.sendCommand("select_parser_configuration 0")\u000a    if eyelink_ver == 2: #turn off scenelink camera stuff\u000a        tracker.sendCommand("scene_camera_gazemap = NO")\u000aelse:\u000a    tracker.sendCommand("saccade_velocity_threshold = 35")\u000a    tracker.sendCommand("saccade_acceleration_threshold = 9500")\u000a \u000atracker.sendCommand("file_sample_data  = LEFT,GAZE,AREA,GAZERES,STATUS,INPUT")\u000a \u000asetCalibrationColors((255, 255, 255), (0, 0, 0));   #Sets the calibration target and background color\u000asetTargetSize(int(surf.get_rect().w/70), int(surf.get_rect().w/300));   #select best size for calibration target\u000asetCalibrationSounds("", "", "");\u000asetDriftCorrectSounds("", "off", "off");\u000a\u000atracker.doTrackerSetup()\u000a\u000acloseGraphics()\u000a\u000amsecDelay(100)\u000a\u000a# Start Code - component code to be run before the window creation\u000a\u000a# Setup the display window\u000awin = visual.Window(size=(disp.width, disp.height), fullscr=False, screen=0, allowGUI=False, allowStencil=False,\u000a    monitor='testMonitor', color=[0,0,0], colorSpace='rgb',\u000a    blendMode='avg', useFBO=True,\u000a    )\u000a# store frame rate of monitor if we can measure it successfully\u000aexpInfo['frameRate']=win.getActualFrameRate()\u000aif expInfo['frameRate']!=None:\u000a    frameDur = 1.0/round(expInfo['frameRate'])\u000aelse:\u000a    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess\u000a\u000afrom psychopy import event\u000a    \u000a  # Initialize components for Routine "instruct"\u000ainstructClock = core.Clock()\u000ainstruction = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 1: \u005cn\u005cnFour coloured squares will appear inside a display box and disappear. Remember the location of each colour everytime they appear as a group.  After a brief delay, one of them will reappear in the center. \u005cn\u005cnYour task is to indicate the direction it has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to begin.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a    \u000a  # Initialize components for Routine "instruct2"\u000ainstruct2Clock = core.Clock()\u000ainstruction2 = visual.TextStim(win=win, ori=0, name='instruction',\u000a    text= "Task 2: \u005cn\u005cnThis task is the same as Task 1. The only differennce is that it has a larger size display box. \u005cn\u005cnPlease continue to indicate the direction the box has moved from its most recent location to the centre by pressing either 'up', 'down', 'left', or 'right' arrow keys on the keyboard as fast as you can. \u005cn\u005cn Press 'enter' to continue.",    font='Arial',\u000a    pos=[0, 0], height=0.08, wrapWidth=None,\u000a    color='white', colorSpace='rgb', opacity=1,\u000a    depth=0.0)\u000a\u000a# Initialize components for Routine "centralTask"\u000acentralTaskClock = core.Clock()\u000atargetcontainer = visual.Rect(win=win, name='targetcontainer',units='deg', \u000a    width=[3, 3][0], height=[3, 3][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000aupcue = visual.Rect(win=win, name='upcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-1.0, \u000ainterpolate=True)\u000adowncue = visual.Rect(win=win, name='downcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -1],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aleftcue = visual.Rect(win=win, name='leftcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000arightcue = visual.Rect(win=win, name='rightcue',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[1, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000atargetbox = visual.Rect(win=win, name='targetbox',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000aISI = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI')\u000a\u000a# Initialize components for Routine "peripheralTask"\u000aperipheralTaskClock = core.Clock()\u000atargetframe = visual.Rect(win=win, name='targetframe',units='deg', \u000a    width=[30, 30][0], height=[30, 30][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=u'black', lineColorSpace='rgb',\u000a    fillColor=u'grey', fillColorSpace='rgb',\u000a    opacity=1,depth=0.0, \u000ainterpolate=True)\u000atargetbox2 = visual.Rect(win=win, name='targetbox2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-2.0, \u000ainterpolate=True)\u000aupcue2 = visual.Rect(win=win, name='upcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, 14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-3.0, \u000ainterpolate=True)\u000adowncue2 = visual.Rect(win=win, name='downcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[0, -14],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-4.0, \u000ainterpolate=True)\u000aleftcue2 = visual.Rect(win=win, name='leftcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[-14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-5.0, \u000ainterpolate=True)\u000arightcue2 = visual.Rect(win=win, name='rightcue2',units='deg', \u000a    width=[0.5, 0.5][0], height=[0.5, 0.5][1],\u000a    ori=0, pos=[14, 0],\u000a    lineWidth=1, lineColor=1.0, lineColorSpace='rgb',\u000a    fillColor=1.0, fillColorSpace='rgb',\u000a    opacity=1,depth=-6.0, \u000ainterpolate=True)\u000aISI_2 = core.StaticPeriod(win=win, screenHz=expInfo['frameRate'], name='ISI_2')\u000a\u000a# Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct"-------\u000at = 0\u000ainstructClock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstructComponents = []\u000ainstructComponents.append(instruction)\u000ainstructComponents.append(start)\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instructClock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction* updates\u000a    if t >= 0.0 and instruction.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction.tStart = t  # underestimates by a little under one frame\u000a        instruction.frameNStart = frameN  # exact frame index\u000a        instruction.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instructComponents:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct"-------\u000afor thisComponent in instructComponents:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a\u000a#########start of task1########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask1 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task1')\u000athisExp.addLoop(task1)  # add the loop to the experiment\u000athisTask1 = task1.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask1.rgb)\u000aif thisTask1 != None:\u000a    for paramName in thisTask1.keys():\u000a        exec(paramName + '= thisTask1.' + paramName)\u000a\u000afor thisTask1 in task1:\u000a    currentLoop = task1\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask1.rgb)\u000a    if thisTask1 != None:\u000a        for paramName in thisTask1.keys():\u000a            exec(paramName + '= thisTask1.' + paramName)\u000a    \u000a    #------Prepare to start Routine "centralTask"-------\u000a    t = 0\u000a    centralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    upcue.setLineColor(upbox)\u000a    upcue.setFillColor(upbox)\u000a    downcue.setLineColor(downbox)\u000a    downcue.setFillColor(downbox)\u000a    leftcue.setLineColor(leftbox)\u000a    leftcue.setFillColor(leftbox)\u000a    rightcue.setLineColor(rightbox)\u000a    rightcue.setFillColor(rightbox)\u000a    targetbox.setLineColor(targettest)\u000a    targetbox.setFillColor(targettest)\u000a    answer1 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer1.status = NOT_STARTED\u000a    # keep track of which components have finished\u000a    centralTaskComponents = []\u000a    centralTaskComponents.append(targetcontainer)\u000a    centralTaskComponents.append(upcue)\u000a    centralTaskComponents.append(downcue)\u000a    centralTaskComponents.append(leftcue)\u000a    centralTaskComponents.append(rightcue)\u000a    centralTaskComponents.append(targetbox)\u000a    centralTaskComponents.append(answer1)\u000a    centralTaskComponents.append(ISI)\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "centralTask"-------\u000a    tracker.startRecording(1,1,1,1)   \u000a    continueRoutine = True\u000a    while continueRoutine:\u000a        # get current time\u000a        t = centralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetcontainer* updates\u000a        if t >= 0.0 and targetcontainer.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetcontainer.tStart = t  # underestimates by a little under one frame\u000a            targetcontainer.frameNStart = frameN  # exact frame index\u000a            targetcontainer.setAutoDraw(True)\u000a        \u000a        # *upcue* updates\u000a        if t >= .5 and upcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue.tStart = t  # underestimates by a little under one frame\u000a            upcue.frameNStart = frameN  # exact frame index\u000a            upcue.setAutoDraw(True)\u000a        if upcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue.setAutoDraw(False)\u000a        \u000a        # *downcue* updates\u000a        if t >= 0.5 and downcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue.tStart = t  # underestimates by a little under one frame\u000a            downcue.frameNStart = frameN  # exact frame index\u000a            downcue.setAutoDraw(True)\u000a        if downcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue.setAutoDraw(False)\u000a        \u000a        # *leftcue* updates\u000a        if t >= 0.5 and leftcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue.tStart = t  # underestimates by a little under one frame\u000a            leftcue.frameNStart = frameN  # exact frame index\u000a            leftcue.setAutoDraw(True)\u000a        if leftcue.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue.setAutoDraw(False)\u000a        \u000a        # *rightcue* updates\u000a        if t >= .5 and rightcue.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue.tStart = t  # underestimates by a little under one frame\u000a            rightcue.frameNStart = frameN  # exact frame index\u000a            rightcue.setAutoDraw(True)\u000a        if rightcue.status == STARTED and t >= (.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue.setAutoDraw(False)\u000a        \u000a        # *targetbox* updates\u000a        if t >= 3.5 and targetbox.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox.tStart = t  # underestimates by a little under one frame\u000a            targetbox.frameNStart = frameN  # exact frame index\u000a            targetbox.setAutoDraw(True)\u000a        \u000a        # *answer1* updates\u000a        if t >= 3.5 and answer1.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer1.tStart = t  # underestimates by a little under one frame\u000a            answer1.frameNStart = frameN  # exact frame index\u000a            answer1.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer1.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer1.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer1.keys = theseKeys[-1]  # just the last key pressed\u000a                answer1.rt = answer1.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer1.keys == str(corrAns)) or (answer1.keys == corrAns):\u000a                    answer1.corr = 1\u000a                else:\u000a                    answer1.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        # *ISI* period\u000a        if t >= 1.5 and ISI.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI.tStart = t  # underestimates by a little under one frame\u000a            ISI.frameNStart = frameN  # exact frame index\u000a            ISI.start(2)\u000a        elif ISI.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in centralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "centralTask"-------\u000a    for thisComponent in centralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()        \u000a    # check responses\u000a    if answer1.keys in ['', [], None]:  # No response was made\u000a       answer1.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer1.corr = 1  # correct non-response\u000a       else: answer1.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task1 (TrialHandler)\u000a    task1.addData('answer1.keys',answer1.keys)\u000a    task1.addData('answer1.corr', answer1.corr)\u000a    if answer1.keys != None:  # we had a response\u000a        task1.addData('answer1.rt', answer1.rt)\u000a    # the Routine "centralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a# completed 1 repeats of 'task1'\u000a\u000a # Create some handy timers\u000aglobalClock = core.Clock()  # to track the time since experiment started\u000aroutineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine \u000a\u000a#------Prepare to start Routine "instruct2"-------\u000at = 0\u000ainstruct2Clock.reset()  # clock \u000aframeN = -1\u000a# update component parameters for each repeat\u000astart = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000astart.status = NOT_STARTED\u000a# keep track of which components have finished\u000ainstruct2Components = []\u000ainstruct2Components.append(instruction2)\u000ainstruct2Components.append(start)\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, 'status'):\u000a        thisComponent.status = NOT_STARTED\u000a\u000a#-------Start Routine "instruct2"-------\u000acontinueRoutine = True\u000awhile continueRoutine:\u000a    # get current time\u000a    t = instruct2Clock.getTime()\u000a    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a    # update/draw components on each frame\u000a    \u000a    # *instruction2* updates\u000a    if t >= 0.0 and instruction2.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        instruction2.tStart = t  # underestimates by a little under one frame\u000a        instruction2.frameNStart = frameN  # exact frame index\u000a        instruction2.setAutoDraw(True)\u000a    \u000a    # *start* updates\u000a    if t >= 0.0 and start.status == NOT_STARTED:\u000a        # keep track of start time/frame for later\u000a        start.tStart = t  # underestimates by a little under one frame\u000a        start.frameNStart = frameN  # exact frame index\u000a        start.status = STARTED\u000a        # keyboard checking is just starting\u000a        start.clock.reset()  # now t=0\u000a        event.clearEvents(eventType='keyboard')\u000a    if start.status == STARTED:\u000a        theseKeys = event.getKeys(keyList=['return'])\u000a        \u000a        # check for quit:\u000a        if "escape" in theseKeys:\u000a            endExpNow = True\u000a        if len(theseKeys) > 0:  # at least one key was pressed\u000a            start.keys = theseKeys[-1]  # just the last key pressed\u000a            start.rt = start.clock.getTime()\u000a            # a response ends the routine\u000a            continueRoutine = False\u000a    \u000a    # check if all components have finished\u000a    if not continueRoutine:  # a component has requested a forced-end of Routine\u000a        break\u000a    continueRoutine = False  # will revert to True if at least one component still running\u000a    for thisComponent in instruct2Components:\u000a        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a            continueRoutine = True\u000a            break  # at least one component has not yet finished\u000a    \u000a    # check for quit (the Esc key)\u000a    if endExpNow or event.getKeys(keyList=["escape"]):\u000a        core.quit()\u000a    \u000a    # refresh the screen\u000a    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a        win.flip()\u000a\u000a#-------Ending Routine "instruct2"-------\u000afor thisComponent in instruct2Components:\u000a    if hasattr(thisComponent, "setAutoDraw"):\u000a        thisComponent.setAutoDraw(False)\u000a# check responses\u000aif start.keys in ['', [], None]:  # No response was made\u000a   start.keys=None\u000a# store data for thisExp (ExperimentHandler)\u000athisExp.addData('start.keys',start.keys)\u000aif start.keys != None:  # we had a response\u000a    thisExp.addData('start.rt', start.rt)\u000athisExp.nextEntry()\u000a# the Routine "instruct2" was not non-slip safe, so reset the non-slip timer\u000aroutineTimer.reset()\u000a\u000a#########start of task2########\u000a\u000a# set up handler to look after randomisation of conditions etc\u000atask2 = data.TrialHandler(nReps=1, method='fullRandom', \u000a    extraInfo=expInfo, originPath=None,\u000a    trialList=data.importConditions(u'trail1.xlsx'),\u000a    seed=None, name='task2')\u000athisExp.addLoop(task2)  # add the loop to the experiment\u000athisTask2 = task2.trialList[0]  # so we can initialise stimuli with some values\u000a# abbreviate parameter names if possible (e.g. rgb=thisTask2.rgb)\u000aif thisTask2 != None:\u000a    for paramName in thisTask2.keys():\u000a        exec(paramName + '= thisTask2.' + paramName)\u000a\u000afor thisTask2 in task2:\u000a    currentLoop = task2\u000a    # abbreviate parameter names if possible (e.g. rgb = thisTask2.rgb)\u000a    if thisTask2 != None:\u000a        for paramName in thisTask2.keys():\u000a            exec(paramName + '= thisTask2.' + paramName)\u000a    \u000a    #------Prepare to start Routine "peripheralTask"-------\u000a    t = 0\u000a    peripheralTaskClock.reset()  # clock \u000a    frameN = -1\u000a    # update component parameters for each repeat\u000a    answer2 = event.BuilderKeyResponse()  # create an object of type KeyResponse\u000a    answer2.status = NOT_STARTED\u000a    targetbox2.setFillColor(targettest)\u000a    targetbox2.setLineColor(targettest)\u000a    upcue2.setFillColor(upbox)\u000a    upcue2.setLineColor(upbox)\u000a    downcue2.setFillColor(downbox)\u000a    downcue2.setLineColor(downbox)\u000a    leftcue2.setFillColor(leftbox)\u000a    leftcue2.setLineColor(leftbox)\u000a    rightcue2.setFillColor(rightbox)\u000a    rightcue2.setLineColor(rightbox)\u000a    # keep track of which components have finished\u000a    peripheralTaskComponents = []\u000a    peripheralTaskComponents.append(targetframe)\u000a    peripheralTaskComponents.append(answer2)\u000a    peripheralTaskComponents.append(targetbox2)\u000a    peripheralTaskComponents.append(upcue2)\u000a    peripheralTaskComponents.append(downcue2)\u000a    peripheralTaskComponents.append(leftcue2)\u000a    peripheralTaskComponents.append(rightcue2)\u000a    peripheralTaskComponents.append(ISI_2)\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, 'status'):\u000a            thisComponent.status = NOT_STARTED\u000a    \u000a    #-------Start Routine "peripheralTask"-------\u000a    continueRoutine = True\u000a    tracker.startRecording(1,1,1,1)\u000a    while continueRoutine:\u000a        # get current time\u000a        t = peripheralTaskClock.getTime()\u000a        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)\u000a        # update/draw components on each frame\u000a        \u000a        # *targetframe* updates\u000a        if t >= 0.0 and targetframe.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetframe.tStart = t  # underestimates by a little under one frame\u000a            targetframe.frameNStart = frameN  # exact frame index\u000a            targetframe.setAutoDraw(True)\u000a        \u000a        # *answer2* updates\u000a        if t >= 3.5 and answer2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            answer2.tStart = t  # underestimates by a little under one frame\u000a            answer2.frameNStart = frameN  # exact frame index\u000a            answer2.status = STARTED\u000a            # keyboard checking is just starting\u000a            answer2.clock.reset()  # now t=0\u000a            event.clearEvents(eventType='keyboard')\u000a        if answer2.status == STARTED:\u000a            theseKeys = event.getKeys(keyList=['up', 'down', 'left', 'right'])\u000a            \u000a            # check for quit:\u000a            if "escape" in theseKeys:\u000a                endExpNow = True\u000a            if len(theseKeys) > 0:  # at least one key was pressed\u000a                answer2.keys = theseKeys[-1]  # just the last key pressed\u000a                answer2.rt = answer2.clock.getTime()\u000a                # was this 'correct'?\u000a                if (answer2.keys == str(corrAns)) or (answer2.keys == corrAns):\u000a                    answer2.corr = 1\u000a                else:\u000a                    answer2.corr = 0\u000a                # a response ends the routine\u000a                continueRoutine = False\u000a        \u000a        # *targetbox2* updates\u000a        if t >= 3.5 and targetbox2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            targetbox2.tStart = t  # underestimates by a little under one frame\u000a            targetbox2.frameNStart = frameN  # exact frame index\u000a            targetbox2.setAutoDraw(True)\u000a        \u000a        # *upcue2* updates\u000a        if t >= 0.5 and upcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            upcue2.tStart = t  # underestimates by a little under one frame\u000a            upcue2.frameNStart = frameN  # exact frame index\u000a            upcue2.setAutoDraw(True)\u000a        if upcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            upcue2.setAutoDraw(False)\u000a        \u000a        # *downcue2* updates\u000a        if t >= 0.5 and downcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            downcue2.tStart = t  # underestimates by a little under one frame\u000a            downcue2.frameNStart = frameN  # exact frame index\u000a            downcue2.setAutoDraw(True)\u000a        if downcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            downcue2.setAutoDraw(False)\u000a        \u000a        # *leftcue2* updates\u000a        if t >= 0.5 and leftcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            leftcue2.tStart = t  # underestimates by a little under one frame\u000a            leftcue2.frameNStart = frameN  # exact frame index\u000a            leftcue2.setAutoDraw(True)\u000a        if leftcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            leftcue2.setAutoDraw(False)\u000a        \u000a        # *rightcue2* updates\u000a        if t >= 0.5 and rightcue2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            rightcue2.tStart = t  # underestimates by a little under one frame\u000a            rightcue2.frameNStart = frameN  # exact frame index\u000a            rightcue2.setAutoDraw(True)\u000a        if rightcue2.status == STARTED and t >= (0.5 + (1-win.monitorFramePeriod*0.75)): #most of one frame period left\u000a            rightcue2.setAutoDraw(False)\u000a        # *ISI_2* period\u000a        if t >= 1.5 and ISI_2.status == NOT_STARTED:\u000a            # keep track of start time/frame for later\u000a            ISI_2.tStart = t  # underestimates by a little under one frame\u000a            ISI_2.frameNStart = frameN  # exact frame index\u000a            ISI_2.start(2)\u000a        elif ISI_2.status == STARTED: #one frame should pass before updating params and completing\u000a            ISI_2.complete() #finish the static period\u000a        \u000a        # check if all components have finished\u000a        if not continueRoutine:  # a component has requested a forced-end of Routine\u000a            break\u000a        continueRoutine = False  # will revert to True if at least one component still running\u000a        for thisComponent in peripheralTaskComponents:\u000a            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:\u000a                continueRoutine = True\u000a                break  # at least one component has not yet finished\u000a        \u000a        # check for quit (the Esc key)\u000a        if endExpNow or event.getKeys(keyList=["escape"]):\u000a            core.quit()\u000a        \u000a        # refresh the screen\u000a        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen\u000a            win.flip()\u000a    \u000a    #-------Ending Routine "peripheralTask"-------\u000a    for thisComponent in peripheralTaskComponents:\u000a        if hasattr(thisComponent, "setAutoDraw"):\u000a            thisComponent.setAutoDraw(False)\u000a    tracker.stopRecording()       \u000a    # check responses\u000a    if answer2.keys in ['', [], None]:  # No response was made\u000a       answer2.keys=None\u000a       # was no response the correct answer?!\u000a       if str(corrAns).lower() == 'none': answer2.corr = 1  # correct non-response\u000a       else: answer2.corr = 0  # failed to respond (incorrectly)\u000a    # store data for task2 (TrialHandler)\u000a    task2.addData('answer2.keys',answer2.keys)\u000a    task2.addData('answer2.corr', answer2.corr)\u000a    if answer2.keys != None:  # we had a response\u000a        task2.addData('answer2.rt', answer2.rt)\u000a    # the Routine "peripheralTask" was not non-slip safe, so reset the non-slip timer\u000a    routineTimer.reset()\u000a    thisExp.nextEntry()\u000a    \u000a    #Ends eyetracker mode, sends data to stim pc.    \u000amsecDelay(10)\u000atracker.closeDataFile\u000atracker.receiveDataFile(edfFileName, edfFileName)\u000atracker.close() \u000a \u000aroutineTimer.reset()\u000awin.close()\u000acore.quit()\u000a
p811
sg662
(lp812
sg664
L458710096L
sg10
S'task2'
p813
sg6
g666
sg667
I1
sg22
I01
sg23
g24
sg668
g1
(g669
g670
(dp814
g672
g673
(g674
g675
g676
S'b'
tRp815
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg20
g673
(g674
g675
g676
S'b'
tRp816
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg685
g673
(g674
g675
g676
S'b'
tRp817
(I1
(L48L
L1L
tg678
I00
S'\x00\x00\x00A\x00\x00\xf8A\x00\x00\x04B\x00\x00\x80A\x00\x00\x90A\x00\x00\xd8A\x00\x008B\x00\x00\xa0A\x00\x00\x00\x00\x00\x00@A\x00\x00PA\x00\x00\x80?\x00\x00\xf0A\x00\x00\xb0A\x00\x00$B\x00\x00\x18B\x00\x00 A\x00\x00\x88A\x00\x00\xc8A\x00\x00\x10B\x00\x00\xc0@\x00\x004B\x00\x00\xe0@\x00\x00\x80@\x00\x00\xc0A\x00\x00\x10A\x00\x00(B\x00\x000B\x00\x00\xe0A\x00\x00\x00B\x00\x00\x98A\x00\x00\xa8A\x00\x00\x08B\x00\x000A\x00\x00`A\x00\x00\xe8A\x00\x00\x00@\x00\x00,B\x00\x00pA\x00\x00<B\x00\x00\x1cB\x00\x00\xd0A\x00\x00\x14B\x00\x00\x0cB\x00\x00 B\x00\x00\xb8A\x00\x00@@\x00\x00\xa0@'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg21
g673
(g674
g675
g676
S'b'
tRp818
(I1
(L48L
L1L
tg678
I00
S'!"\x03@\xfcB\x83?9?c?\x15\x06^?\t\xab\x08@\xe3m\xaa?\xb9\x99\xf2?\xa22\xb9?\x91<\x82?)!n?O\x08N?2\x83I?\x93\xf8A?\x89\xc4\x93?\xe78\xcb?\xcej.?\xe1\xe6\xb2?\x9f\xe9\xcb?\x8a/\xf6?\xf8)\xf2?\xcd\x8c{?D \xc7?\x11\xe4 ?\x9c\x1cB?\xc6dV?l\xbdE?\xbd\x90\x85?\x07\xd0e?x\x00\xc9?\xc5ie?\xe4\x9a\xf5?n\xdc\xce?b\x0b\x19?\xdd\xa7\xa0?\x13\xb5B?(}\xe8>\xed(o?\x85{\x9e?\xcb-\t@t\x1b\x96?#\x9e\xda?x\xf2\x14@(\x98\r@\xd96\xa6?\x98\xe4\x87?L\x95\xa2?\xf5l\x98?\xcb\xa3m?'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg19
g680
(g675
(I0
tS'b'
tRp819
(I1
(L48L
L1L
tg682
I00
(lp820
g418
ag557
ag569
ag467
ag479
ag533
ag647
ag491
ag367
ag443
ag449
ag374
ag551
ag503
ag617
ag599
ag431
ag473
ag521
ag587
ag406
ag641
ag412
ag394
ag515
ag425
ag623
ag635
ag539
ag563
ag485
ag497
ag575
ag437
ag455
ag545
ag381
ag629
ag461
ag653
ag605
ag527
ag593
ag581
ag611
ag509
ag387
ag400
atbstRp821
(dp822
g689
(dp823
g672
I01
sg21
I01
sg20
I01
sg685
I01
sg19
I00
ssg691
g809
sg692
(lp824
g672
ag685
ag19
ag20
ag21
asg694
(lp825
L48L
aI1
asbsg696
g697
sg698
g680
(g675
(I0
tS'b'
tRp826
(I1
(L48L
L1L
tg682
I00
(lp827
I8
aI11
aI36
aI46
aI23
aI47
aI20
aI22
aI0
aI25
aI16
aI33
aI9
aI10
aI34
aI38
aI3
aI17
aI4
aI30
aI7
aI31
aI13
aI45
aI24
aI18
aI41
aI5
aI28
aI35
aI12
aI1
aI29
aI2
aI32
aI43
aI19
aI42
aI15
aI40
aI44
aI14
aI26
aI37
aI27
aI21
aI6
aI39
atbsg701
I01
sg702
I1
sg703
I-1
sg704
(lp828
g1
(g706
g670
(dp829
g355
g364
sg363
g361
sg365
g366
sg368
g361
sg358
g359
sg360
g356
stRp830
ag1
(g706
g670
(dp831
g355
g356
sg363
g361
sg365
g366
sg368
g361
sg358
g364
sg360
g359
stRp832
ag1
(g706
g670
(dp833
g355
g359
sg363
g361
sg365
g366
sg368
g361
sg358
g356
sg360
g364
stRp834
ag1
(g706
g670
(dp835
g355
g361
sg363
g356
sg365
g366
sg368
g356
sg358
g364
sg360
g359
stRp836
ag1
(g706
g670
(dp837
g355
g359
sg363
g356
sg365
g366
sg368
g356
sg358
g361
sg360
g364
stRp838
ag1
(g706
g670
(dp839
g355
g364
sg363
g356
sg365
g366
sg368
g356
sg358
g359
sg360
g361
stRp840
ag1
(g706
g670
(dp841
g355
g359
sg363
g364
sg365
g366
sg368
g364
sg358
g361
sg360
g356
stRp842
ag1
(g706
g670
(dp843
g355
g361
sg363
g364
sg365
g366
sg368
g364
sg358
g356
sg360
g359
stRp844
ag1
(g706
g670
(dp845
g355
g356
sg363
g364
sg365
g366
sg368
g364
sg358
g359
sg360
g361
stRp846
ag1
(g706
g670
(dp847
g355
g361
sg363
g359
sg365
g366
sg368
g359
sg358
g364
sg360
g356
stRp848
ag1
(g706
g670
(dp849
g355
g356
sg363
g359
sg365
g366
sg368
g359
sg358
g361
sg360
g364
stRp850
ag1
(g706
g670
(dp851
g355
g364
sg363
g359
sg365
g366
sg368
g359
sg358
g356
sg360
g361
stRp852
ag1
(g706
g670
(dp853
g355
g356
sg363
g361
sg365
g393
sg368
g364
sg358
g361
sg360
g359
stRp854
ag1
(g706
g670
(dp855
g355
g359
sg363
g361
sg365
g393
sg368
g356
sg358
g361
sg360
g364
stRp856
ag1
(g706
g670
(dp857
g355
g364
sg363
g361
sg365
g393
sg368
g359
sg358
g361
sg360
g356
stRp858
ag1
(g706
g670
(dp859
g355
g359
sg363
g356
sg365
g393
sg368
g361
sg358
g356
sg360
g364
stRp860
ag1
(g706
g670
(dp861
g355
g364
sg363
g356
sg365
g393
sg368
g359
sg358
g356
sg360
g361
stRp862
ag1
(g706
g670
(dp863
g355
g361
sg363
g356
sg365
g393
sg368
g364
sg358
g356
sg360
g359
stRp864
ag1
(g706
g670
(dp865
g355
g356
sg363
g364
sg365
g393
sg368
g359
sg358
g364
sg360
g361
stRp866
ag1
(g706
g670
(dp867
g355
g359
sg363
g364
sg365
g393
sg368
g361
sg358
g364
sg360
g356
stRp868
ag1
(g706
g670
(dp869
g355
g361
sg363
g364
sg365
g393
sg368
g356
sg358
g364
sg360
g359
stRp870
ag1
(g706
g670
(dp871
g355
g356
sg363
g359
sg365
g393
sg368
g361
sg358
g359
sg360
g364
stRp872
ag1
(g706
g670
(dp873
g355
g364
sg363
g359
sg365
g393
sg368
g356
sg358
g359
sg360
g361
stRp874
ag1
(g706
g670
(dp875
g355
g361
sg363
g359
sg365
g393
sg368
g364
sg358
g359
sg360
g356
stRp876
ag1
(g706
g670
(dp877
g355
g361
sg363
g361
sg365
g424
sg368
g364
sg358
g359
sg360
g356
stRp878
ag1
(g706
g670
(dp879
g355
g361
sg363
g361
sg365
g424
sg368
g356
sg358
g364
sg360
g359
stRp880
ag1
(g706
g670
(dp881
g355
g361
sg363
g361
sg365
g424
sg368
g359
sg358
g356
sg360
g364
stRp882
ag1
(g706
g670
(dp883
g355
g356
sg363
g356
sg365
g424
sg368
g361
sg358
g364
sg360
g359
stRp884
ag1
(g706
g670
(dp885
g355
g356
sg363
g356
sg365
g424
sg368
g359
sg358
g361
sg360
g364
stRp886
ag1
(g706
g670
(dp887
g355
g356
sg363
g356
sg365
g424
sg368
g364
sg358
g359
sg360
g361
stRp888
ag1
(g706
g670
(dp889
g355
g364
sg363
g364
sg365
g424
sg368
g359
sg358
g361
sg360
g356
stRp890
ag1
(g706
g670
(dp891
g355
g364
sg363
g364
sg365
g424
sg368
g361
sg358
g356
sg360
g359
stRp892
ag1
(g706
g670
(dp893
g355
g364
sg363
g364
sg365
g424
sg368
g356
sg358
g359
sg360
g361
stRp894
ag1
(g706
g670
(dp895
g355
g359
sg363
g359
sg365
g424
sg368
g361
sg358
g364
sg360
g356
stRp896
ag1
(g706
g670
(dp897
g355
g359
sg363
g359
sg365
g424
sg368
g356
sg358
g361
sg360
g364
stRp898
ag1
(g706
g670
(dp899
g355
g359
sg363
g359
sg365
g424
sg368
g364
sg358
g356
sg360
g361
stRp900
ag1
(g706
g670
(dp901
g355
g356
sg363
g361
sg365
g380
sg368
g359
sg358
g364
sg360
g361
stRp902
ag1
(g706
g670
(dp903
g355
g359
sg363
g361
sg365
g380
sg368
g364
sg358
g356
sg360
g361
stRp904
ag1
(g706
g670
(dp905
g355
g364
sg363
g361
sg365
g380
sg368
g356
sg358
g359
sg360
g361
stRp906
ag1
(g706
g670
(dp907
g355
g359
sg363
g356
sg365
g380
sg368
g364
sg358
g361
sg360
g356
stRp908
ag1
(g706
g670
(dp909
g355
g364
sg363
g356
sg365
g380
sg368
g361
sg358
g359
sg360
g356
stRp910
ag1
(g706
g670
(dp911
g355
g361
sg363
g356
sg365
g380
sg368
g359
sg358
g364
sg360
g356
stRp912
ag1
(g706
g670
(dp913
g355
g356
sg363
g364
sg365
g380
sg368
g361
sg358
g359
sg360
g364
stRp914
ag1
(g706
g670
(dp915
g355
g359
sg363
g364
sg365
g380
sg368
g356
sg358
g361
sg360
g364
stRp916
ag1
(g706
g670
(dp917
g355
g361
sg363
g364
sg365
g380
sg368
g359
sg358
g356
sg360
g364
stRp918
ag1
(g706
g670
(dp919
g355
g356
sg363
g359
sg365
g380
sg368
g364
sg358
g361
sg360
g359
stRp920
ag1
(g706
g670
(dp921
g355
g364
sg363
g359
sg365
g380
sg368
g361
sg358
g356
sg360
g359
stRp922
ag1
(g706
g670
(dp923
g355
g361
sg363
g359
sg365
g380
sg368
g356
sg358
g364
sg360
g359
stRp924
asg803
Nsg804
I39
sg805
I48
sg806
I0
sg807
I48
sg808
I01
sbasS'savePickle'
p925
I00
sb.